{
  "address": "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "DER_Split_Error",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "validationModule",
          "type": "address"
        }
      ],
      "name": "WrongValidationModule",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "expmod_Error",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "k256Decompress_Invalid_Length_Error",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "k256DeriveY_Invalid_Prefix_Error",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "recoverV_Error",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        }
      ],
      "name": "initForSmartAccount",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "dataHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "moduleSignature",
          "type": "bytes"
        }
      ],
      "name": "isValidSignature",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "dataHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "moduleSignature",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        }
      ],
      "name": "isValidSignatureForAddress",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "authenticationData",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "digest",
          "type": "bytes32"
        }
      ],
      "name": "sign",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "v",
              "type": "uint256"
            }
          ],
          "internalType": "struct SignatureRSV",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "initCode",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            },
            {
              "internalType": "uint256",
              "name": "callGasLimit",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "verificationGasLimit",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxFeePerGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxPriorityFeePerGas",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "paymasterAndData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct UserOperation",
          "name": "userOp",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "userOpHash",
          "type": "bytes32"
        }
      ],
      "name": "validateUserOp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xcd343264cbf3f03e26ebcb262612e6a18af7766ff5abd2c27650b386c301da0a",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
    "transactionIndex": 0,
    "gasUsed": "1021468",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc429e4345c67fb7fb3ec4fd26ba334660eaa8164c615f51db860414511689f97",
    "transactionHash": "0xcd343264cbf3f03e26ebcb262612e6a18af7766ff5abd2c27650b386c301da0a",
    "logs": [],
    "blockNumber": 5,
    "cumulativeGasUsed": "1021468",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "daebca65735187f17c67dfc7dd9d0c06",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DER_Split_Error\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"validationModule\",\"type\":\"address\"}],\"name\":\"WrongValidationModule\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"expmod_Error\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"k256Decompress_Invalid_Length_Error\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"k256DeriveY_Invalid_Prefix_Error\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"recoverV_Error\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initForSmartAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"moduleSignature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"moduleSignature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"}],\"name\":\"isValidSignatureForAddress\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"authenticationData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"}],\"name\":\"sign\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"internalType\":\"struct SignatureRSV\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"}],\"name\":\"validateUserOp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/modules/KeyManagementContractRegistryModule/KeyManagement.sol\":\"KeyManagement\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@account-abstraction/contracts/core/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n/**\\n * returned data from validateUserOp.\\n * validateUserOp returns a uint256, with is created by `_packedValidationData` and parsed by `_parseValidationData`\\n * @param aggregator - address(0) - the account validated the signature by itself.\\n *              address(1) - the account failed to validate the signature.\\n *              otherwise - this is an address of a signature aggregator that must be used to validate the signature.\\n * @param validAfter - this UserOp is valid only after this timestamp.\\n * @param validaUntil - this UserOp is valid only up to this timestamp.\\n */\\n    struct ValidationData {\\n        address aggregator;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n    }\\n\\n//extract sigFailed, validAfter, validUntil.\\n// also convert zero validUntil to type(uint48).max\\n    function _parseValidationData(uint validationData) pure returns (ValidationData memory data) {\\n        address aggregator = address(uint160(validationData));\\n        uint48 validUntil = uint48(validationData >> 160);\\n        if (validUntil == 0) {\\n            validUntil = type(uint48).max;\\n        }\\n        uint48 validAfter = uint48(validationData >> (48 + 160));\\n        return ValidationData(aggregator, validAfter, validUntil);\\n    }\\n\\n// intersect account and paymaster ranges.\\n    function _intersectTimeRange(uint256 validationData, uint256 paymasterValidationData) pure returns (ValidationData memory) {\\n        ValidationData memory accountValidationData = _parseValidationData(validationData);\\n        ValidationData memory pmValidationData = _parseValidationData(paymasterValidationData);\\n        address aggregator = accountValidationData.aggregator;\\n        if (aggregator == address(0)) {\\n            aggregator = pmValidationData.aggregator;\\n        }\\n        uint48 validAfter = accountValidationData.validAfter;\\n        uint48 validUntil = accountValidationData.validUntil;\\n        uint48 pmValidAfter = pmValidationData.validAfter;\\n        uint48 pmValidUntil = pmValidationData.validUntil;\\n\\n        if (validAfter < pmValidAfter) validAfter = pmValidAfter;\\n        if (validUntil > pmValidUntil) validUntil = pmValidUntil;\\n        return ValidationData(aggregator, validAfter, validUntil);\\n    }\\n\\n/**\\n * helper to pack the return value for validateUserOp\\n * @param data - the ValidationData to pack\\n */\\n    function _packValidationData(ValidationData memory data) pure returns (uint256) {\\n        return uint160(data.aggregator) | (uint256(data.validUntil) << 160) | (uint256(data.validAfter) << (160 + 48));\\n    }\\n\\n/**\\n * helper to pack the return value for validateUserOp, when not using an aggregator\\n * @param sigFailed - true for signature failure, false for success\\n * @param validUntil last timestamp this UserOperation is valid (or zero for infinite)\\n * @param validAfter first timestamp this UserOperation is valid\\n */\\n    function _packValidationData(bool sigFailed, uint48 validUntil, uint48 validAfter) pure returns (uint256) {\\n        return (sigFailed ? 1 : 0) | (uint256(validUntil) << 160) | (uint256(validAfter) << (160 + 48));\\n    }\\n\\n/**\\n * keccak function over calldata.\\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\\n */\\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\\n        assembly {\\n            let mem := mload(0x40)\\n            let len := data.length\\n            calldatacopy(mem, data.offset, len)\\n            ret := keccak256(mem, len)\\n        }\\n    }\\n\\n\",\"keccak256\":\"0x591c87519f7155d1909210276b77925ab2722a99b7b5d5649aecc36ebbdb045a\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/interfaces/UserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\nimport {calldataKeccak} from \\\"../core/Helpers.sol\\\";\\n\\n/**\\n * User Operation struct\\n * @param sender the sender account of this request.\\n     * @param nonce unique value the sender uses to verify it is not a replay.\\n     * @param initCode if set, the account contract will be created by this constructor/\\n     * @param callData the method call to execute on this account.\\n     * @param callGasLimit the gas limit passed to the callData method call.\\n     * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\\n     * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\\n     * @param maxFeePerGas same as EIP-1559 gas parameter.\\n     * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\\n     * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\\n     * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n     */\\n    struct UserOperation {\\n\\n        address sender;\\n        uint256 nonce;\\n        bytes initCode;\\n        bytes callData;\\n        uint256 callGasLimit;\\n        uint256 verificationGasLimit;\\n        uint256 preVerificationGas;\\n        uint256 maxFeePerGas;\\n        uint256 maxPriorityFeePerGas;\\n        bytes paymasterAndData;\\n        bytes signature;\\n    }\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n\\n    function getSender(UserOperation calldata userOp) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {data := calldataload(userOp)}\\n        return address(uint160(data));\\n    }\\n\\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\\n    // pay above what he signed for.\\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint256) {\\n    unchecked {\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        if (maxFeePerGas == maxPriorityFeePerGas) {\\n            //legacy mode (for networks that don't support basefee opcode)\\n            return maxFeePerGas;\\n        }\\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n    }\\n    }\\n\\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\\n        address sender = getSender(userOp);\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        uint256 callGasLimit = userOp.callGasLimit;\\n        uint256 verificationGasLimit = userOp.verificationGasLimit;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return abi.encode(\\n            sender, nonce,\\n            hashInitCode, hashCallData,\\n            callGasLimit, verificationGasLimit, preVerificationGas,\\n            maxFeePerGas, maxPriorityFeePerGas,\\n            hashPaymasterAndData\\n        );\\n    }\\n\\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\\n        return keccak256(pack(userOp));\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\",\"keccak256\":\"0x61374003361059087fdcf17967a7bba052badeaf5c7f0ae689166f8aafd3a45c\",\"license\":\"GPL-3.0\"},\"@oasisprotocol/sapphire-contracts/contracts/EthereumUtils.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport {Sapphire} from \\\"./Sapphire.sol\\\";\\n\\nstruct SignatureRSV {\\n    bytes32 r;\\n    bytes32 s;\\n    uint256 v;\\n}\\n\\nlibrary EthereumUtils {\\n    uint256 internal constant K256_P =\\n        0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f;\\n\\n    // (p+1)//4\\n    uint256 internal constant K256_P_PLUS_1_OVER_4 =\\n        0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff0c;\\n\\n    address internal constant PRECOMPILE_BIGMODEXP = address(0x5);\\n\\n    error expmod_Error();\\n\\n    function expmod(\\n        uint256 base,\\n        uint256 exponent,\\n        uint256 modulus\\n    ) internal view returns (uint256 out) {\\n        (bool success, bytes memory result) = PRECOMPILE_BIGMODEXP.staticcall(\\n            abi.encodePacked(\\n                uint256(0x20), // length of base\\n                uint256(0x20), // length of exponent\\n                uint256(0x20), // length of modulus\\n                base,\\n                exponent,\\n                modulus\\n            )\\n        );\\n\\n        if (!success) revert expmod_Error();\\n\\n        out = uint256(bytes32(result));\\n    }\\n\\n    error k256DeriveY_Invalid_Prefix_Error();\\n\\n    /**\\n     * @notice Recover Y coordinate from X coordinate and sign bit.\\n     * @param prefix 0x02 or 0x03 indicates sign bit of compressed point.\\n     * @param x X coordinate.\\n     */\\n    function k256DeriveY(\\n        uint8 prefix,\\n        uint256 x\\n    ) internal view returns (uint256 y) {\\n        if (prefix != 0x02 && prefix != 0x03)\\n            revert k256DeriveY_Invalid_Prefix_Error();\\n\\n        // x^3 + ax + b, where a=0, b=7\\n        y = addmod(mulmod(x, mulmod(x, x, K256_P), K256_P), 7, K256_P);\\n\\n        // find square root of quadratic residue\\n        y = expmod(y, K256_P_PLUS_1_OVER_4, K256_P);\\n\\n        // negate y if indicated by sign bit\\n        if ((y + prefix) % 2 != 0) {\\n            y = K256_P - y;\\n        }\\n    }\\n\\n    error k256Decompress_Invalid_Length_Error();\\n\\n    /**\\n     * @notice Decompress SEC P256 k1 point.\\n     * @param pk 33 byte compressed public key.\\n     * @return x X coordinate.\\n     * @return y Y coordinate.\\n     */\\n    function k256Decompress(\\n        bytes memory pk\\n    ) internal view returns (uint256 x, uint256 y) {\\n        if (pk.length != 33) revert k256Decompress_Invalid_Length_Error();\\n        assembly {\\n            // skip 32 byte length prefix, plus one byte sign prefix\\n            x := mload(add(pk, 33))\\n        }\\n        y = k256DeriveY(uint8(pk[0]), x);\\n    }\\n\\n    function k256PubkeyToEthereumAddress(\\n        bytes memory pubkey\\n    ) internal view returns (address) {\\n        (uint256 x, uint256 y) = k256Decompress(pubkey);\\n        return toEthereumAddress(x, y);\\n    }\\n\\n    /**\\n     * @notice Convert SEC P256 k1 curve point to Ethereum address.\\n     * @param x X coordinate.\\n     * @param y Y coordinate.\\n     * @custom:see https://gavwood.com/paper.pdf (pp. 212)\\n     */\\n    function toEthereumAddress(\\n        uint256 x,\\n        uint256 y\\n    ) internal pure returns (address) {\\n        bytes32 digest = keccak256(abi.encodePacked(x, y));\\n\\n        return address(uint160((uint256(digest) << 96) >> 96));\\n    }\\n\\n    error DER_Split_Error();\\n\\n    /**\\n     * @notice Extracts the `r` and `s` parameters from a DER encoded ECDSA\\n     * signature.\\n     *\\n     * The signature is an ASN1 encoded SEQUENCE of the variable length `r` and\\n     * `s` INTEGERs.\\n     *\\n     * ```\\n     * | 0x30 | len(z) | 0x02 | len(r) |  r   | 0x02 | len(s) |  s   | = hex value\\n     * |  1   |   1    |   1  |   1    | 1-33 |  1   |   1    | 1-33 | = byte length\\n     * ```\\n     *\\n     * If the highest bit of either `r` or `s` is set, it will be prefix padded\\n     * with a zero byte. There is exponentially decreasing probability that\\n     * either `r` or `s` will be below 32 bytes. There is a very high\\n     * probability that either `r` or `s` will be 33 bytes. This function only\\n     * works if either `r` or `s` are 256bits or lower.\\n     *\\n     * @param der DER encoded ECDSA signature\\n     * @return rsv ECDSA R point X coordinate, and S scalar\\n     * @custom:see https://bitcoin.stackexchange.com/questions/58853/how-do-you-figure-out-the-r-and-s-out-of-a-signature-using-python\\n     */\\n    function splitDERSignature(\\n        bytes memory der\\n    ) internal pure returns (SignatureRSV memory rsv) {\\n        if (der.length < 8) revert DER_Split_Error();\\n        if (der[0] != 0x30) revert DER_Split_Error();\\n        if (der[2] != 0x02) revert DER_Split_Error();\\n\\n        uint256 zLen = uint8(der[1]);\\n        uint256 rLen = uint8(der[3]);\\n        if (rLen > 33) revert DER_Split_Error();\\n\\n        uint256 sOffset = 4 + rLen;\\n        uint256 sLen = uint8(der[sOffset + 1]);\\n        if (sLen > 33) revert DER_Split_Error();\\n        if (der[sOffset] != 0x02) revert DER_Split_Error();\\n\\n        if (rLen + sLen + 4 != zLen) revert DER_Split_Error();\\n        if (der.length != zLen + 2) revert DER_Split_Error();\\n\\n        sOffset += 2;\\n        uint256 rOffset = 4;\\n\\n        if (rLen == 33) {\\n            if (der[4] != 0x00) revert DER_Split_Error();\\n            rOffset += 1;\\n            rLen -= 1;\\n        }\\n\\n        if (sLen == 33) {\\n            if (der[sOffset] != 0x00) revert DER_Split_Error();\\n            sOffset += 1;\\n            sLen -= 1;\\n        }\\n\\n        bytes32 r;\\n        bytes32 s;\\n\\n        assembly {\\n            r := mload(add(der, add(32, rOffset)))\\n            s := mload(add(der, add(32, sOffset)))\\n        }\\n\\n        // When length of either `r` or `s` is below 32 bytes\\n        // the 32 byte `mload` will suffix it with unknown stuff\\n        // shift right to remove the unknown stuff, prefixing with zeros instead\\n\\n        if (rLen < 32) {\\n            r >>= 8 * (32 - rLen);\\n        }\\n\\n        if (sLen < 32) {\\n            s >>= 8 * (32 - sLen);\\n        }\\n\\n        rsv.r = r;\\n        rsv.s = s;\\n    }\\n\\n    error recoverV_Error();\\n\\n    function recoverV(\\n        address pubkeyAddr,\\n        bytes32 digest,\\n        SignatureRSV memory rsv\\n    ) internal pure {\\n        rsv.v = 27;\\n\\n        if (ecrecover(digest, uint8(rsv.v), rsv.r, rsv.s) != pubkeyAddr) {\\n            rsv.v = 28;\\n\\n            if (ecrecover(digest, uint8(rsv.v), rsv.r, rsv.s) != pubkeyAddr) {\\n                revert recoverV_Error();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Convert a Secp256k1PrehashedKeccak256 signature to one accepted\\n     * by ecrecover.\\n     * @param pubkey 33 byte compressed public key.\\n     * @param digest 32 byte pre-hashed message digest.\\n     * @param signature ASN.1 DER encoded signature, as returned from\\n     * [`Sapphire.sign`](../Sapphire.sol/library.Sapphire.md#sign).\\n     * @return pubkeyAddr 20 byte Ethereum address.\\n     * @return rsv Ethereum EcDSA RSV signature values.\\n     * @custom:see https://gavwood.com/paper.pdf (pp. 206)\\n     */\\n    function toEthereumSignature(\\n        bytes memory pubkey,\\n        bytes32 digest,\\n        bytes memory signature\\n    ) internal view returns (address pubkeyAddr, SignatureRSV memory rsv) {\\n        pubkeyAddr = k256PubkeyToEthereumAddress(pubkey);\\n\\n        rsv = splitDERSignature(signature);\\n\\n        recoverV(pubkeyAddr, digest, rsv);\\n    }\\n\\n    function sign(\\n        address pubkeyAddr,\\n        bytes32 secretKey,\\n        bytes32 digest\\n    ) internal view returns (SignatureRSV memory rsv) {\\n        bytes memory signature = Sapphire.sign(\\n            Sapphire.SigningAlg.Secp256k1PrehashedKeccak256,\\n            abi.encodePacked(secretKey),\\n            abi.encodePacked(digest),\\n            \\\"\\\"\\n        );\\n\\n        rsv = splitDERSignature(signature);\\n\\n        recoverV(pubkeyAddr, digest, rsv);\\n    }\\n\\n    /**\\n     * @notice Generate an Ethereum compatible SEC P256 k1 keypair and\\n     * corresponding public address.\\n     * @return pubkeyAddr Ethereum address.\\n     * @return secretKey Secret key used for signing.\\n     */\\n    function generateKeypair()\\n        internal\\n        view\\n        returns (address pubkeyAddr, bytes32 secretKey)\\n    {\\n        bytes memory randSeed = Sapphire.randomBytes(32, \\\"\\\");\\n\\n        secretKey = bytes32(randSeed);\\n\\n        (bytes memory pk, ) = Sapphire.generateSigningKeyPair(\\n            Sapphire.SigningAlg.Secp256k1PrehashedKeccak256,\\n            randSeed\\n        );\\n\\n        pubkeyAddr = k256PubkeyToEthereumAddress(pk);\\n    }\\n}\\n\",\"keccak256\":\"0x693ff243247cd56be267df50d14113fcddbfdb248215441a18aa34d6e69aa483\",\"license\":\"Apache-2.0\"},\"@oasisprotocol/sapphire-contracts/contracts/Sapphire.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Sapphire\\n * @notice This library provides a number of convenient wrappers for\\n * cryptographic operations such as the x25519 key derivation, Deoxys-II-based\\n * encryption and decryption, signing key generation, message digest signing and\\n * verification, gas padding and hashing.\\n *\\n * Most of the mentioned functions are implemented as Sapphire's precompiles and\\n * are cheap to call.\\n *\\n * #### Calling Precompiles Manually\\n *\\n * You can override the wrappers and call Sapphire precompiles by dispatching\\n * calls to specific well-known contract addresses, as described below. The\\n * __Precompile address__ section of each function will show you the address\\n * of the corresponding precompile.\\n *\\n * Input parameters should be packed into a contiguous memory region with each\\n * chunk of data padded to 32 bytes as usual. The recommended way to construct\\n * parameter byte sequences in Solidity is with `abi.encode` and `abi.decode`,\\n * which will transparently handle things like putting `bytes` lengths in the\\n * correct position.\\n */\\nlibrary Sapphire {\\n    // Oasis-specific, confidential precompiles\\n    address internal constant RANDOM_BYTES =\\n        0x0100000000000000000000000000000000000001;\\n    address internal constant DERIVE_KEY =\\n        0x0100000000000000000000000000000000000002;\\n    address internal constant ENCRYPT =\\n        0x0100000000000000000000000000000000000003;\\n    address internal constant DECRYPT =\\n        0x0100000000000000000000000000000000000004;\\n    address internal constant GENERATE_SIGNING_KEYPAIR =\\n        0x0100000000000000000000000000000000000005;\\n    address internal constant SIGN_DIGEST =\\n        0x0100000000000000000000000000000000000006;\\n    address internal constant VERIFY_DIGEST =\\n        0x0100000000000000000000000000000000000007;\\n    address internal constant CURVE25519_PUBLIC_KEY =\\n        0x0100000000000000000000000000000000000008;\\n    address internal constant GAS_USED =\\n        0x0100000000000000000000000000000000000009;\\n    address internal constant PAD_GAS =\\n        0x010000000000000000000000000000000000000a;\\n\\n    // Oasis-specific, general precompiles\\n    address internal constant SHA512_256 =\\n        0x0100000000000000000000000000000000000101;\\n    address internal constant SHA512 =\\n        0x0100000000000000000000000000000000000102;\\n    address internal constant SHA384 =\\n        0x0100000000000000000000000000000000000104;\\n\\n    type Curve25519PublicKey is bytes32;\\n    type Curve25519SecretKey is bytes32;\\n\\n    enum SigningAlg {\\n        /// Ed25519 signature over the provided message using SHA-512/265 with a domain separator.\\n        /// Can be used to sign transactions for the Oasis consensus layer and SDK paratimes.\\n        Ed25519Oasis,\\n        /// Ed25519 signature over the provided message.\\n        Ed25519Pure,\\n        /// Ed25519 signature over the provided prehashed SHA-512 digest.\\n        Ed25519PrehashedSha512,\\n        /// Secp256k1 signature over the provided message using SHA-512/256 with a domain separator.\\n        /// Can be used to sign transactions for the Oasis consensus layer and SDK paratimes.\\n        Secp256k1Oasis,\\n        /// Secp256k1 over the provided Keccak256 digest.\\n        /// Can be used to sign transactions for Ethereum-compatible networks.\\n        Secp256k1PrehashedKeccak256,\\n        /// Secp256k1 signature over the provided SHA-256 digest.\\n        Secp256k1PrehashedSha256,\\n        /// Sr25519 signature over the provided message.\\n        Sr25519,\\n        /// Secp256r1 signature over the provided SHA-256 digest.\\n        Secp256r1PrehashedSha256,\\n        /// Secp384r1 signature over the provided SHA-384 digest.\\n        Secp384r1PrehashedSha384\\n    }\\n\\n    /**\\n     * @notice Generate `num_bytes` pseudo-random bytes, with an optional\\n     * personalization string (`pers`) added into the hashing algorithm to\\n     * increase domain separation when needed.\\n     *\\n     * #### Precompile address\\n     *\\n     * `0x0100000000000000000000000000000000000001`\\n     *\\n     * #### Gas cost\\n     *\\n     * 10,000 minimum plus 240 per output word plus 60 per word of the\\n     * personalization string.\\n     *\\n     * #### Implementation details\\n     *\\n     * The mode (e.g. simulation or \\\"view call\\\" vs transaction execution) is fed\\n     * to TupleHash (among other block-dependent components) to derive the \\\"key\\n     * id\\\", which is then used to derive a per-block VRF key from\\n     * epoch-ephemeral entropy (using KMAC256 and cSHAKE) so a different key\\n     * id will result in a unique per-block VRF key. This per-block VRF key is\\n     * then used to create the per-block root RNG which is then used to derive\\n     * domain-separated (using Merlin transcripts) per-transaction random RNGs\\n     * which are then exposed via this precompile. The KMAC, cSHAKE and\\n     * TupleHash algorithms are SHA-3 derived functions defined in [NIST\\n     * Special Publication 800-185](https://nvlpubs.nist.gov/nistpubs/specialpublications/nist.sp.800-185.pdf).\\n     *\\n     * #### DANGER: Prior to Sapphire ParaTime 0.6.0\\n     *\\n     * All view queries and simulated transactions (via `eth_call`) would\\n     * receive the same entropy in-between blocks if they use the same\\n     * `num_bytes` and `pers` parameters. If your contract requires\\n     * confidentiality you should generate a secret in the constructor to be\\n     * used with view calls:\\n     *\\n     * ```solidity\\n     * Sapphire.randomBytes(64, abi.encodePacked(msg.sender, this.perContactSecret));\\n     * ```\\n     *\\n     * #### Example\\n     *\\n     * ```solidity\\n     * bytes memory randomPad = Sapphire.randomBytes(64, \\\"\\\");\\n     * ```\\n     *\\n     * @param numBytes The number of bytes to return.\\n     * @param pers An optional personalization string to increase domain\\n     *        separation.\\n     * @return The random bytes. If the number of bytes requested is too large\\n     *         (over 1024), a smaller amount (1024) will be returned.\\n     */\\n    function randomBytes(uint256 numBytes, bytes memory pers)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        (bool success, bytes memory entropy) = RANDOM_BYTES.staticcall(\\n            abi.encode(numBytes, pers)\\n        );\\n        require(success, \\\"randomBytes: failed\\\");\\n        return entropy;\\n    }\\n\\n    /**\\n     * @notice Generates a Curve25519 keypair.\\n     * @param pers An optional personalization string used to add domain\\n     * separation.\\n     * @return pk The Curve25519 public key. Useful for key exchange.\\n     * @return sk The Curve25519 secret key. Pairs well with\\n     * [deriveSymmetricKey](#derivesymmetrickey).\\n     */\\n    function generateCurve25519KeyPair(bytes memory pers)\\n        internal\\n        view\\n        returns (Curve25519PublicKey pk, Curve25519SecretKey sk)\\n    {\\n        bytes memory scalar = randomBytes(32, pers);\\n        // Twiddle some bits, as per RFC 7748 \\u00a75.\\n        scalar[0] &= 0xf8; // Make it a multiple of 8 to avoid small subgroup attacks.\\n        scalar[31] &= 0x7f; // Clamp to < 2^255 - 19\\n        scalar[31] |= 0x40; // Clamp to >= 2^254\\n        (bool success, bytes memory pkBytes) = CURVE25519_PUBLIC_KEY.staticcall(\\n            scalar\\n        );\\n        require(success, \\\"gen curve25519 pk: failed\\\");\\n        return (\\n            Curve25519PublicKey.wrap(bytes32(pkBytes)),\\n            Curve25519SecretKey.wrap(bytes32(scalar))\\n        );\\n    }\\n\\n    /**\\n     * @notice Derive a symmetric key from a pair of keys using x25519.\\n     *\\n     * #### Precompile address\\n     *\\n     * `0x0100000000000000000000000000000000000002`\\n     *\\n     * #### Gas cost\\n     *\\n     * 100,000\\n     *\\n     * #### Example\\n     *\\n     * ```solidity\\n     * bytes32 publicKey = ... ;\\n     * bytes32 privateKey = ... ;\\n     * bytes32 symmetric = Sapphire.deriveSymmetricKey(publicKey, privateKey);\\n     * ```\\n     *\\n     * @param peerPublicKey The peer's public key.\\n     * @param secretKey Your secret key.\\n     * @return A derived symmetric key.\\n     */\\n    function deriveSymmetricKey(\\n        Curve25519PublicKey peerPublicKey,\\n        Curve25519SecretKey secretKey\\n    ) internal view returns (bytes32) {\\n        (bool success, bytes memory symmetric) = DERIVE_KEY.staticcall(\\n            abi.encode(peerPublicKey, secretKey)\\n        );\\n        require(success, \\\"deriveSymmetricKey: failed\\\");\\n        return bytes32(symmetric);\\n    }\\n\\n    /**\\n     * @notice Encrypt and authenticate the plaintext and additional data using\\n     * DeoxysII.\\n     *\\n     * #### Precompile address\\n     *\\n     * `0x0100000000000000000000000000000000000003`\\n     *\\n     * #### Gas cost\\n     *\\n     * 50,000 minimum plus 100 per word of input\\n     *\\n     * #### Example\\n     *\\n     * ```solidity\\n     * bytes32 key = ... ;\\n     * bytes32 nonce = ... ;\\n     * bytes memory text = \\\"plain text\\\";\\n     * bytes memory ad = \\\"additional data\\\";\\n     * bytes memory encrypted = Sapphire.encrypt(key, nonce, text, ad);\\n     * bytes memory decrypted = Sapphire.decrypt(key, nonce, encrypted, ad);\\n     * ```\\n     *\\n     * @param key The key to use for encryption.\\n     * @param nonce The nonce. Note that only the first 15 bytes of this\\n     * parameter are used.\\n     * @param plaintext The plaintext to encrypt and authenticate.\\n     * @param additionalData The additional data to authenticate.\\n     * @return The ciphertext with appended auth tag.\\n     */\\n    function encrypt(\\n        bytes32 key,\\n        bytes32 nonce,\\n        bytes memory plaintext,\\n        bytes memory additionalData\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory ciphertext) = ENCRYPT.staticcall(\\n            abi.encode(key, nonce, plaintext, additionalData)\\n        );\\n        require(success, \\\"encrypt: failed\\\");\\n        return ciphertext;\\n    }\\n\\n    /**\\n     * @notice Decrypt and authenticate the ciphertext and additional data using\\n     * DeoxysII. Reverts if the auth tag is incorrect.\\n     *\\n     * #### Precompile address\\n     *\\n     * `0x0100000000000000000000000000000000000004`\\n     *\\n     * #### Gas cost\\n     *\\n     * 50,000 minimum plus 100 per word of input\\n     *\\n     * #### Example\\n     *\\n     * ```solidity\\n     * bytes32 key = ... ;\\n     * bytes32 nonce = ... ;\\n     * bytes memory text = \\\"plain text\\\";\\n     * bytes memory ad = \\\"additional data\\\";\\n     * bytes memory encrypted = Sapphire.encrypt(key, nonce, text, ad);\\n     * bytes memory decrypted = Sapphire.decrypt(key, nonce, encrypted, ad);\\n     * ```\\n     *\\n     * @param key The key to use for decryption.\\n     * @param nonce The nonce. Note that only the first 15 bytes of this\\n     * parameter are used.\\n     * @param ciphertext The ciphertext with tag to decrypt and authenticate.\\n     * @param additionalData The additional data to authenticate against the\\n     * ciphertext.\\n     * @return The original plaintext.\\n     */\\n    function decrypt(\\n        bytes32 key,\\n        bytes32 nonce,\\n        bytes memory ciphertext,\\n        bytes memory additionalData\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory plaintext) = DECRYPT.staticcall(\\n            abi.encode(key, nonce, ciphertext, additionalData)\\n        );\\n        require(success, \\\"decrypt: failed\\\");\\n        return plaintext;\\n    }\\n\\n    /**\\n     * @notice Generate a public/private key pair using the specified method and\\n     * seed. The available methods are items in the\\n     * [`Sapphire.SigningAlg`](#signingalg) enum. Note, however, that the\\n     * generation method ignores subvariants, so all three Ed25519-based are\\n     * equivalent, and all Secp256k1 & Secp256r1 based methods are equivalent.\\n     * Sr25519 is not available and will return an error.\\n     *\\n     * #### Precompile address\\n     * `0x0100000000000000000000000000000000000005`\\n     *\\n     * #### Gas Cost\\n     *\\n     * ##### Ed25519: 1,000 gas\\n     *\\n     * - `0` (`Ed25519Oasis`)\\n     * - `1` (`Ed25519Pure`)\\n     * - `2` (`Ed25519PrehashedSha512`)\\n     *\\n     * ##### Secp256k1: 1,500 gas.\\n     * - `3` (`Secp256k1Oasis`)\\n     * - `4` (`Secp256k1PrehashedKeccak256`)\\n     * - `5` (`Secp256k1PrehashedSha256`)\\n     *\\n     * ##### Secp256r1: 4,000 gas\\n     * - `7` (`Secp256r1PrehashedSha256`)\\n     *\\n     * #### Public Key Format\\n     *\\n     * ##### Ed25519\\n     *\\n     * 32 bytes\\n     *\\n     * ##### Secp256k1 & Secp256r1\\n     *\\n     * 33 bytes, compressed format (`0x02` or `0x03` prefix, then 32 byte X\\n     * coordinate).\\n     *\\n     * #### Example\\n     *\\n     * ```solidity\\n     * bytes memory seed = hex\\\"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\\\";\\n     * bytes memory publicKey;\\n     * bytes memory privateKey;\\n     * (publicKey, privateKey) = Sapphire.generateSigningKeyPair(Sapphire.SigningAlg.Ed25519Pure, seed);\\n     * ```\\n     *\\n     * @param alg The signing alg for which to generate a keypair.\\n     * @param seed The seed to use for generating the key pair. You can use the\\n     * `randomBytes` method if you don't already have a seed.\\n     * @return publicKey The public half of the keypair.\\n     * @return secretKey The secret half of the keypair.\\n     */\\n    function generateSigningKeyPair(SigningAlg alg, bytes memory seed)\\n        internal\\n        view\\n        returns (bytes memory publicKey, bytes memory secretKey)\\n    {\\n        (bool success, bytes memory keypair) = GENERATE_SIGNING_KEYPAIR\\n            .staticcall(abi.encode(alg, seed));\\n        require(success, \\\"gen signing keypair: failed\\\");\\n        return abi.decode(keypair, (bytes, bytes));\\n    }\\n\\n    /**\\n     * @notice Sign a message within the provided context using the specified\\n     * algorithm, and return the signature. The `context_or_digest` and\\n     * `messages` parameters change in meaning slightly depending on the method\\n     * requested. For methods that take a context in addition to the message you\\n     * must pass the context in the `context_or_digest` parameter and use\\n     * `message` as expected. For methods that take a pre-existing hash of the\\n     * message, pass that in `context_or_digest` and leave `message` empty.\\n     * Specifically the `Ed25519Oasis` and `Secp256k1Oasis` variants take both a\\n     * context and a message (each are variable length `bytes`), the context\\n     * serves as a domain separator.\\n     *\\n     * #### Precompile address\\n     *\\n     * `0x0100000000000000000000000000000000000006`\\n     *\\n     * #### Gas cost\\n     *\\n     * See below for the method-dependent base cost, plus 8 gas per 32 bytes of\\n     * context and message except digest.\\n     *\\n     * #### Signing algorithms\\n     *\\n     * - `0` (`Ed25519Oasis`): 1,500 gas, variable length context and message.\\n     * - `1` (`Ed25519Pure`): 1,500 gas, empty context, variable length message.\\n     * - `2` (`Ed25519PrehashedSha512`): 1,500 gas, pre-existing SHA-512 hash\\n     *   (64 bytes) as context, empty message.\\n     * - `3` (`Secp256k1Oasis`): 3,000 gas, variable length context and message\\n     * - `4` (`Secp256k1PrehashedKeccak256`): 3,000 gas, pre-existing hash\\n     *   (32 bytes) as context, empty message.\\n     * - `5` (`Secp256k1PrehashedSha256`): 3,000 gas, pre-existing hash (32\\n     *   bytes) as context, empty message.\\n     * - `7` (`Secp256r1PrehashedSha256`): 9,000 gas, pre-existing hash (32\\n     *   bytes) as context, empty message.\\n     *\\n     * #### Example\\n     *\\n     * ```solidity\\n     * Sapphire.SigningAlg alg = Sapphire.SigningAlg.Ed25519Pure;\\n     * bytes memory pk;\\n     * bytes memory sk;\\n     * (pk, sk) = Sapphire.generateSigningKeyPair(alg, Sapphire.randomBytes(32, \\\"\\\"));\\n     * bytes memory signature = Sapphire.sign(alg, sk, \\\"\\\", \\\"signed message\\\");\\n     * ```\\n     *\\n     * @param alg The signing algorithm to use.\\n     * @param secretKey The secret key to use for signing. The key must be valid\\n     * for use with the requested algorithm.\\n     * @param contextOrHash Domain-Separator Context, or precomputed hash bytes.\\n     * @param message Message to sign, should be zero-length if precomputed hash\\n     * given.\\n     * @return signature The resulting signature.\\n     * @custom:see @oasisprotocol/oasis-sdk :: precompile/confidential.rs :: call_sign\\n     */\\n    function sign(\\n        SigningAlg alg,\\n        bytes memory secretKey,\\n        bytes memory contextOrHash,\\n        bytes memory message\\n    ) internal view returns (bytes memory signature) {\\n        (bool success, bytes memory sig) = SIGN_DIGEST.staticcall(\\n            abi.encode(alg, secretKey, contextOrHash, message)\\n        );\\n        require(success, \\\"sign: failed\\\");\\n        return sig;\\n    }\\n\\n    /**\\n     * @notice Verifies that the provided digest was signed with using the\\n     * secret key corresponding to the provided private key and the specified\\n     * signing algorithm.\\n     *\\n     * The `method`, `context_or_digest` and `message` parameters have the same\\n     * meaning as described above in the [sign()](#sign) function.\\n     *\\n     * #### Precompile address\\n     *\\n     * `0x0100000000000000000000000000000000000007`\\n     *\\n     * #### Gas cost\\n     *\\n     * The algorithm-specific base cost below, with an additional **8 gas per\\n     * 32 bytes** of `context` and `message` for the `Ed25519Oasis`,\\n     * `Ed25519Pure` and `Secp256k1Oasis` algorithms.\\n     *\\n     * - `0` (`Ed25519Oasis`): 2,000 gas\\n     * - `1` (`Ed25519Pure`): 2,000 gas\\n     * - `2` (`Ed25519PrehashedSha512`): 2,000 gas\\n     * - `3` (`Secp256k1Oasis`): 3,000 gas\\n     * - `4` (`Secp256k1PrehashedKeccak256`): 3,000 gas\\n     * - `5` (`Secp256k1PrehashedSha256`): 3,000 gas\\n     * - `7` (`Secp256r1PrehashedSha256`): 7,900 gas\\n     *\\n     * #### Example\\n     *\\n     * ```solidity\\n     * Sapphire.SigningAlg alg = Sapphire.SigningAlg.Secp256k1PrehashedKeccak256;\\n     * bytes memory pk;\\n     * bytes memory sk;\\n     * bytes memory digest = abi.encodePacked(keccak256(\\\"signed message\\\"));\\n     * (pk, sk) = Sapphire.generateSigningKeyPair(alg, Sapphire.randomBytes(32, \\\"\\\"));\\n     * bytes memory signature = Sapphire.sign(alg, sk, digest, \\\"\\\");\\n     * require( Sapphire.verify(alg, pk, digest, \\\"\\\", signature) );\\n     * ```\\n     *\\n     * @param alg The signing algorithm by which the signature was generated.\\n     * @param publicKey The public key against which to check the signature.\\n     * @param contextOrHash Domain-Separator Context, or precomputed hash bytes\\n     * @param message The hash of the message that was signed, should be\\n     * zero-length if precomputed hash was given.\\n     * @param signature The signature to check.\\n     * @return verified Whether the signature is valid for the given parameters.\\n     * @custom:see @oasisprotocol/oasis-sdk :: precompile/confidential.rs :: call_verify\\n     */\\n    function verify(\\n        SigningAlg alg,\\n        bytes memory publicKey,\\n        bytes memory contextOrHash,\\n        bytes memory message,\\n        bytes memory signature\\n    ) internal view returns (bool verified) {\\n        (bool success, bytes memory v) = VERIFY_DIGEST.staticcall(\\n            abi.encode(alg, publicKey, contextOrHash, message, signature)\\n        );\\n        require(success, \\\"verify: failed\\\");\\n        return abi.decode(v, (bool));\\n    }\\n\\n    /**\\n     * @notice Set the current transactions gas usage to a specific amount\\n     * @dev Will cause a reversion if the current usage is more than the amount.\\n     * @param toAmount Gas usage will be set to this amount\\n     * @custom:see @oasisprotocol/oasis-sdk :: precompile/gas.rs :: call_pad_gas\\n     *\\n     */\\n    function padGas(uint128 toAmount) internal view {\\n        (bool success, ) = PAD_GAS.staticcall(abi.encode(toAmount));\\n        require(success, \\\"verify: failed\\\");\\n    }\\n\\n    /**\\n     * @notice Returns the amount of gas currently used by the transaction\\n     * @custom:see @oasisprotocol/oasis-sdk :: precompile/gas.rs :: call_gas_used\\n     */\\n    function gasUsed() internal view returns (uint64) {\\n        (bool success, bytes memory v) = GAS_USED.staticcall(\\\"\\\");\\n        require(success, \\\"gasused: failed\\\");\\n        return abi.decode(v, (uint64));\\n    }\\n}\\n\\n/**\\n * @notice Hash the input data with SHA-512/256, according to\\n * [NIST.FIPS.180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\\n *\\n * #### Precompile address\\n *\\n * `0x0100000000000000000000000000000000000102`\\n *\\n * #### Gas cost\\n *\\n * 115 gas, then 13 gas per word\\n *\\n * #### Example\\n *\\n * ```solidity\\n * bytes32 result = sha512_256(abi.encodePacked(\\\"input data\\\"));\\n * ```\\n *\\n * #### Warning: SHA-512 vs SHA-512/256 Length-Extension Attacks\\n *\\n * [SHA-512](function.sha512.md#sha512) is vulnerable to [length-extension\\n * attacks](https://en.wikipedia.org/wiki/Length_extension_attack), which are\\n * relevant if you are computing the hash of a secret message. The\\n * [SHA-512/256](function.sha512_256.md#sha512_256) variant is **not**\\n * vulnerable to length-extension attacks.\\n *\\n * @param input Bytes to hash.\\n * @return result 32 byte digest.\\n * @custom:standard https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\\n * @custom:see @oasisprotocol/oasis-sdk :: precompile/sha2.rs :: call_sha512_256\\n */\\nfunction sha512_256(bytes memory input) view returns (bytes32 result) {\\n    (bool success, bytes memory output) = Sapphire.SHA512_256.staticcall(input);\\n\\n    require(success, \\\"sha512_256\\\");\\n\\n    return bytes32(output);\\n}\\n\\n/**\\n * @notice Hash the input data with SHA-512, according to\\n * [NIST.FIPS.180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf)\\n *\\n * #### Precompile address\\n *\\n * `0x0100000000000000000000000000000000000101`\\n *\\n * #### Warning: SHA-512 vs SHA-512/256 Length-Extension Attacks\\n *\\n * [SHA-512](function.sha512.md#sha512) is vulnerable to [length-extension\\n * attacks](https://en.wikipedia.org/wiki/Length_extension_attack), which are\\n * relevant if you are computing the hash of a secret message. The\\n * [SHA-512/256](function.sha512_256.md#sha512_256) variant is **not**\\n * vulnerable to length-extension attacks.\\n *\\n * #### Gas Cost\\n *\\n * 115 gas, then 13 gas per word\\n *\\n * #### Example\\n *\\n * ```solidity\\n * bytes memory result = sha512(abi.encodePacked(\\\"input data\\\"));\\n * ```\\n *\\n * @param input Bytes to hash.\\n * @return output 64 byte digest.\\n * @custom:standard https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\\n * @custom:see @oasisprotocol/oasis-sdk :: precompile/sha2.rs :: call_sha512\\n */\\nfunction sha512(bytes memory input) view returns (bytes memory output) {\\n    bool success;\\n\\n    (success, output) = Sapphire.SHA512.staticcall(input);\\n\\n    require(success, \\\"sha512\\\");\\n}\\n\\n/**\\n * @notice Hash the input data with SHA-384.\\n * @param input Bytes to hash.\\n * @return output 48 byte digest.\\n * @custom:standard https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\\n * @custom:see @oasisprotocol/oasis-sdk :: precompile/sha2.rs :: call_sha384\\n */\\nfunction sha384(bytes memory input) view returns (bytes memory output) {\\n    bool success;\\n\\n    (success, output) = Sapphire.SHA384.staticcall(input);\\n\\n    require(success, \\\"sha384\\\");\\n}\\n\",\"keccak256\":\"0x81a0aa5766f7c48ea799114f44e902b2eb11f21808db23d56b6ca9edd48b8f59\",\"license\":\"Apache-2.0\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs &\\n            bytes32(\\n                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n            );\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (\\n            uint256(s) >\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\n        ) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(\\n        bytes32 hash\\n    ) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(\\n        bytes memory s\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n\\\",\\n                    Strings.toString(s.length),\\n                    s\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(\\n        bytes32 domainSeparator,\\n        bytes32 structHash\\n    ) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(\\n        address validator,\\n        bytes memory data\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\",\"keccak256\":\"0x05ba6cf7b4a58692b2b0f4010040735f57b7470949945e09f54f4bee7445d91a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"contracts/interfaces/IAuthorizationModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\nimport {UserOperation} from \\\"@account-abstraction/contracts/interfaces/UserOperation.sol\\\";\\n\\n// interface for modules to verify singatures signed over userOpHash\\ninterface IAuthorizationModule {\\n    function validateUserOp(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash\\n    ) external returns (uint256 validationData);\\n}\\n\",\"keccak256\":\"0xc77814fdf4e7e85ff6e47698dca7c7510ec4a12aa80a3f3f7f2eb7a93fd47cad\",\"license\":\"MIT\"},\"contracts/interfaces/ISignatureValidator.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.17;\\n\\ncontract ISignatureValidatorConstants {\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\\n}\\n\\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param _dataHash Arbitrary length data signed on behalf of address(this)\\n     * @param _signature Signature byte array associated with _data\\n     *\\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\\n     * MUST allow external calls\\n     */\\n    function isValidSignature(\\n        bytes32 _dataHash,\\n        bytes memory _signature\\n    ) public view virtual returns (bytes4);\\n}\\n\",\"keccak256\":\"0x151800cba225c382897e788e018280e3ccaa58ee7bb53f11e4010651dea310d1\",\"license\":\"LGPL-3.0-only\"},\"contracts/modules/BaseAuthorizationModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/* solhint-disable no-empty-blocks */\\n\\nimport {IAuthorizationModule} from \\\"../interfaces/IAuthorizationModule.sol\\\";\\nimport {ISignatureValidator} from \\\"../interfaces/ISignatureValidator.sol\\\";\\n\\ncontract AuthorizationModulesConstants {\\n    uint256 internal constant VALIDATION_SUCCESS = 0;\\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\\n}\\n\\nabstract contract BaseAuthorizationModule is\\n    IAuthorizationModule,\\n    ISignatureValidator,\\n    AuthorizationModulesConstants\\n{}\\n\",\"keccak256\":\"0x760e0f1641461ae280ec8dda7002c756ab7ae015703a5cdd31c81e1f696db4ea\",\"license\":\"MIT\"},\"contracts/modules/KeyManagementContractRegistryModule/KeyManagement.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.17;\\n\\nimport \\\"./interfaces/IKeyManagementAuthorizationModule.sol\\\";\\n\\nimport {SignatureRSV, EthereumUtils} from \\\"@oasisprotocol/sapphire-contracts/contracts/EthereumUtils.sol\\\";\\nimport {UserOperation} from \\\"@account-abstraction/contracts/interfaces/UserOperation.sol\\\";\\nimport {Sapphire} from \\\"@oasisprotocol/sapphire-contracts/contracts/Sapphire.sol\\\";\\nimport {BaseAuthorizationModule} from \\\"../BaseAuthorizationModule.sol\\\";\\nimport {ECDSA} from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\ncontract KeyManagement is BaseAuthorizationModule {\\n    using ECDSA for bytes32;\\n\\n    address internal constant SENTINEL_MODULES = address(0x1);\\n\\n    mapping(address => address) internal _modules;\\n    mapping(address => address) internal publicAddress;\\n    mapping(address => bytes32) private privateSecret;\\n\\n    bool private _initialized;\\n\\n    error WrongValidationModule(address validationModule);\\n\\n    constructor() {}\\n\\n    function initForSmartAccount(address _owner) external returns (address) {\\n        require(!_initialized, \\\"AlreadyInitialized\\\");\\n        address keypairAddress;\\n        bytes32 keypairSecret;\\n        (keypairAddress, keypairSecret) = EthereumUtils.generateKeypair();\\n        publicAddress[_owner] = keypairAddress;\\n        privateSecret[_owner] = keypairSecret;\\n        return address(this);\\n    }\\n\\n    modifier onlyOwner(bytes calldata data) {\\n        (, address validationModule) = abi.decode(data, (bytes, address));\\n        if (_modules[validationModule] != address(0)) {\\n            require(\\n                IKeyManagementAuthorizationModule(validationModule).validate(\\n                    data\\n                ) == true,\\n                \\\"Validate wrong\\\"\\n            );\\n        } else {\\n            revert WrongValidationModule(validationModule);\\n        }\\n        _;\\n    }\\n\\n    function sign(\\n        bytes calldata authenticationData,\\n        address smartAccount,\\n        bytes32 digest\\n    )\\n        public\\n        view\\n        returns (\\n            // onlyOwner(authenticationData, smartAccount)\\n            SignatureRSV memory\\n        )\\n    {\\n        return\\n            EthereumUtils.sign(\\n                publicAddress[smartAccount],\\n                privateSecret[smartAccount],\\n                digest\\n            );\\n    }\\n\\n    function validateUserOp(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash\\n    ) external view virtual returns (uint256) {\\n        (bytes memory cleanEcdsaSignature, ) = abi.decode(\\n            userOp.signature,\\n            (bytes, address)\\n        );\\n        if (_verifySignature(userOpHash, cleanEcdsaSignature, userOp.sender)) {\\n            return VALIDATION_SUCCESS;\\n        }\\n        return SIG_VALIDATION_FAILED;\\n    }\\n\\n    function isValidSignature(\\n        bytes32 dataHash,\\n        bytes memory moduleSignature\\n    ) public view override returns (bytes4) {\\n        return\\n            isValidSignatureForAddress(dataHash, moduleSignature, msg.sender);\\n    }\\n\\n    function isValidSignatureForAddress(\\n        bytes32 dataHash,\\n        bytes memory moduleSignature,\\n        address smartAccount\\n    ) public view virtual returns (bytes4) {\\n        if (_verifySignature(dataHash, moduleSignature, smartAccount)) {\\n            return EIP1271_MAGIC_VALUE;\\n        }\\n        return bytes4(0xffffffff);\\n    }\\n\\n    function _verifySignature(\\n        bytes32 dataHash,\\n        bytes memory signature,\\n        address smartAccount\\n    ) internal view returns (bool) {\\n        address keypairAddress = publicAddress[smartAccount];\\n        address recovered = (dataHash.toEthSignedMessageHash()).recover(\\n            signature\\n        );\\n        if (keypairAddress == recovered) {\\n            return true;\\n        }\\n        recovered = dataHash.recover(signature);\\n        if (keypairAddress == recovered) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n// bool verify = Sapphire.verify(\\n//     Sapphire.SigningAlg.Secp256k1PrehashedKeccak256,\\n//     bytes(keypairAddress),\\n//     dataHash,\\n//     \\\"\\\",\\n//     signature\\n// );\\n// return verify;\\n\",\"keccak256\":\"0x9e9829c05cd6b3b3a58ebdab00b62cd11401d477366f53828bcad5c136c82051\",\"license\":\"MIT\"},\"contracts/modules/KeyManagementContractRegistryModule/interfaces/IKeyManagementAuthorizationModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// interface for modules to verify singatures signed over userOpHash\\ninterface IKeyManagementAuthorizationModule {\\n    function validate(bytes calldata data) external view returns (bool result);\\n}\\n\",\"keccak256\":\"0xb635f5c596c8f353fd7b2887543ec6bf49ee018de3087e830c65c6443d916445\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608080604052346100165761118c908161001c8239f35b600080fdfe60806040526004361015610013575b600080fd5b6000803560e01c9081631626ba7e1461007a575080632ede3bc0146100715780635bef82e114610068578063f44c339d1461005f5763fff35b721461005757600080fd5b61000e61048c565b5061000e610440565b5061000e6103ba565b5061000e610205565b346100e55760403660031901126100e5576024359067ffffffffffffffff82116100e55760206100ba6100b036600486016101ad565b3390600435610e83565b6040517fffffffff000000000000000000000000000000000000000000000000000000009091168152f35b80fd5b50634e487b7160e01b600052604160045260246000fd5b6020810190811067ffffffffffffffff82111761011b57604052565b6101236100e8565b604052565b60e0810190811067ffffffffffffffff82111761011b57604052565b6040810190811067ffffffffffffffff82111761011b57604052565b90601f8019910116810190811067ffffffffffffffff82111761011b57604052565b60209067ffffffffffffffff81116101a0575b601f01601f19160190565b6101a86100e8565b610195565b81601f8201121561000e578035906101c482610182565b926101d26040519485610160565b8284526020838301011161000e57816000926020809301838601378301015290565b6001600160a01b0381160361000e57565b503461000e57602036600319011261000e57600435610223816101f4565b60ff6003541661037557604090600080835161023e816100ff565b818152845161027081610262602082019460208652898084015260608301906107cd565b03601f198101835282610160565b51907301000000000000000000000000000000000000015afa9061029261072e565b9115610331576103239061030a6102ba6102b46102ae866104d9565b95610834565b506104fc565b6102d7836001600160a01b03166000526001602052604060002090565b906001600160a01b03167fffffffffffffffffffffffff0000000000000000000000000000000000000000825416179055565b6001600160a01b03166000526002602052604060002090565b5551308152602090f35b0390f35b825162461bcd60e51b815260206004820152601360248201527f72616e646f6d42797465733a206661696c6564000000000000000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601260248201527f416c7265616479496e697469616c697a656400000000000000000000000000006044820152606490fd5b503461000e57606036600319011261000e5760043567ffffffffffffffff80821161000e573660238301121561000e57816004013590811161000e573691016024011161000e5761032d61041c602435610413816101f4565b60443590610964565b60408051825181526020808401519082015291810151908201529081906060820190565b503461000e57606036600319011261000e5760243567ffffffffffffffff811161000e576100ba61047760209236906004016101ad565b60443590610484826101f4565b600435610e83565b503461000e5760031960403682011261000e576004359067ffffffffffffffff821161000e5761016090823603011261000e576104d160209160243590600401610df7565b604051908152f35b6020815191015190602081106104ed575090565b6000199060200360031b1b1690565b602181510361061157610513602182015191610623565b5160f81c6000600282141580610606575b6105f4578060405160208101906020825260206040820152602060608201526401000003d01980600781808a80098a090860808301527f3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff0c60a083015260c082015260c0815261059281610128565b519060055afa916105a161072e565b92156105e2576105c66105c06105b96105cf956104d9565b93846106f0565b60011690565b6105d25761075e565b90565b906105dc906106fd565b9061075e565b60405163102875ed60e01b8152600490fd5b60405163ab4be04160e01b8152600490fd5b506003821415610524565b604051636446a2c560e11b8152600490fd5b8051156106305760200190565b634e487b7160e01b600052603260045260246000fd5b8051600210156106305760220190565b8051600110156106305760210190565b8051600310156106305760230190565b8051600410156106305760240190565b908151811015610630570160200190565b50634e487b7160e01b600052601160045260246000fd5b60040190816004116106bc57565b6106c4610697565b565b90600182018092116106bc57565b90600482018092116106bc57565b90600282018092116106bc57565b919082018092116106bc57565b6401000003d019908103919082116106bc57565b6000198101919082116106bc57565b60200390602082116106bc57565b3d15610759573d9061073f82610182565b9161074d6040519384610160565b82523d6000602084013e565b606090565b6001600160a01b039160405190602082019283526040820152604081526060810181811067ffffffffffffffff82111761079d575b6040525190201690565b6107a56100e8565b610793565b60005b8381106107bd5750506000910152565b81810151838201526020016107ad565b906020916107e6815180928185528580860191016107aa565b601f01601f1916010190565b81601f8201121561000e57805161080881610182565b926108166040519485610160565b8184526020828401011161000e576105cf91602080850191016107aa565b90604090815160209061085b816102628482019760048952878084015260608301906107cd565b60008095819251907301000000000000000000000000000000000000055afa9061088361072e565b91156108e357815182019184818385019403126108df57818101519067ffffffffffffffff918281116108db5784846108be928401016107f2565b958101519182116108d7576105cf9495965001016107f2565b8680fd5b8780fd5b8580fd5b60649084519062461bcd60e51b82526004820152601b60248201527f67656e207369676e696e67206b6579706169723a206661696c656400000000006044820152fd5b604051906060820182811067ffffffffffffffff821117610957575b60405260006040838281528260208201520152565b61095f6100e8565b610942565b61096c610926565b506001600160a01b0380600092168252602060018152604091828420541692600282528083610a01610a30828420546109a3610926565b50835190878201528681526109b781610144565b8351908a888301528782526109cb82610144565b610a2485516109d9816100ff565b878152610a14875196879460808d87019a6109f48c60049052565b87015260a08601906107cd565b601f1995868683030160608701526107cd565b90848483030160808501526107cd565b03908101835282610160565b51907301000000000000000000000000000000000000065afa91610a5261072e565b9215610a6f57505090610a676105cf92610ae2565b928391610cf1565b60649250519062461bcd60e51b82526004820152600c60248201527f7369676e3a206661696c656400000000000000000000000000000000000000006044820152fd5b908160031b917f1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8116036106bc57565b90610aeb610926565b916008815110610c9d576001600160f81b0319600360fc1b81610b1e610b1085610623565b516001600160f81b03191690565b1603610c9d57600160f91b8082610b37610b1086610646565b1603610c9d57610b5b610b55610b4f610b1086610656565b60f81c90565b60ff1690565b91610b6e610b55610b4f610b1087610666565b9260218411610c9d57610b80846106ae565b90610b9c610b55610b4f610b10610b96866106c6565b8a610686565b9360218511610c9d57610bc2610bb5610b10858a610686565b6001600160f81b03191690565b03610c9d5780610bda610bd586886106f0565b6106d4565b03610c9d57610bea8651916106e2565b03610c9d57610bf8906106e2565b9060049060218514610caf575b60218414610c6a575b50906020809286010151940101519160208110610c53575b5060208110610c3b575b509083526020830152565b610c47610c4c91610720565b610ab2565b1c38610c30565b610c47610c6291949294610720565b1c9138610c26565b610c7a610b108488969496610686565b16610c9d576020610c94610c8e82946106c6565b92610711565b93919250610c0e565b6040516386cd05c560e01b8152600490fd5b939084610cbe610b1088610676565b16610cd55750610ccf600591610711565b93610c05565b6040516386cd05c560e01b8152fd5b506040513d6000823e3d90fd5b9160408101601b8152815191602081016020610d2b825160405196888860609194939260808201958252601b602083015260408201520152565b856000968792838052039060015afa15610de0575b83516001600160a01b038097169687911603610d5f575b505050505050565b610db194610d958593601c602096525192516040519384938460609194939260808201958252601c602083015260408201520152565b838052039060015afa15610dd3575b516001600160a01b031690565b03610dc157388080808080610d57565b604051634532600d60e01b8152600490fd5b610ddb610ce4565b610da4565b610de8610ce4565b610d40565b356105cf816101f4565b90610140820135601e198336030181121561000e57820180359267ffffffffffffffff9081851161000e576020830194803603861361000e5783019460408487031261000e573591821161000e57610e6a6040610e62610e6f94602080610e759a01918801016101ad565b9401356101f4565b610ded565b91610ec1565b610e7e57600190565b600090565b90610e8e9291610ec1565b610eb6577fffffffff0000000000000000000000000000000000000000000000000000000090565b630b135d3f60e11b90565b91906001600160a01b0380921660005260016020528160406000205416927f19457468657265756d205369676e6564204d6573736167653a0a33320000000060005280601c5282610f21610f1984603c60002061108e565b919091610f6e565b168414610f4557610f3591610f199161108e565b1614610f4057600090565b600190565b50505050600190565b60051115610f5857565b634e487b7160e01b600052602160045260246000fd5b610f7781610f4e565b80610f7f5750565b610f8881610f4e565b60018103610fd55760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e617475726500000000000000006044820152606490fd5b610fde81610f4e565b6002810361102b5760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e677468006044820152606490fd5b80611037600392610f4e565b1461103e57565b60405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b6064820152608490fd5b9060418151146000146110bc576110b8916020820151906060604084015193015160001a906110c6565b9091565b5050600090600290565b9291907f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0831161114a5791608094939160ff602094604051948552168484015260408301526060820152600093849182805260015afa1561113d575b81516001600160a01b03811615611137579190565b50600190565b611145610ce4565b611122565b5050505060009060039056fea2646970667358221220d8292a7f5015f3e5eaf54576d58db9388426c53e65e05257c8fbd5224cef092a64736f6c63430008110033",
  "deployedBytecode": "0x60806040526004361015610013575b600080fd5b6000803560e01c9081631626ba7e1461007a575080632ede3bc0146100715780635bef82e114610068578063f44c339d1461005f5763fff35b721461005757600080fd5b61000e61048c565b5061000e610440565b5061000e6103ba565b5061000e610205565b346100e55760403660031901126100e5576024359067ffffffffffffffff82116100e55760206100ba6100b036600486016101ad565b3390600435610e83565b6040517fffffffff000000000000000000000000000000000000000000000000000000009091168152f35b80fd5b50634e487b7160e01b600052604160045260246000fd5b6020810190811067ffffffffffffffff82111761011b57604052565b6101236100e8565b604052565b60e0810190811067ffffffffffffffff82111761011b57604052565b6040810190811067ffffffffffffffff82111761011b57604052565b90601f8019910116810190811067ffffffffffffffff82111761011b57604052565b60209067ffffffffffffffff81116101a0575b601f01601f19160190565b6101a86100e8565b610195565b81601f8201121561000e578035906101c482610182565b926101d26040519485610160565b8284526020838301011161000e57816000926020809301838601378301015290565b6001600160a01b0381160361000e57565b503461000e57602036600319011261000e57600435610223816101f4565b60ff6003541661037557604090600080835161023e816100ff565b818152845161027081610262602082019460208652898084015260608301906107cd565b03601f198101835282610160565b51907301000000000000000000000000000000000000015afa9061029261072e565b9115610331576103239061030a6102ba6102b46102ae866104d9565b95610834565b506104fc565b6102d7836001600160a01b03166000526001602052604060002090565b906001600160a01b03167fffffffffffffffffffffffff0000000000000000000000000000000000000000825416179055565b6001600160a01b03166000526002602052604060002090565b5551308152602090f35b0390f35b825162461bcd60e51b815260206004820152601360248201527f72616e646f6d42797465733a206661696c6564000000000000000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601260248201527f416c7265616479496e697469616c697a656400000000000000000000000000006044820152606490fd5b503461000e57606036600319011261000e5760043567ffffffffffffffff80821161000e573660238301121561000e57816004013590811161000e573691016024011161000e5761032d61041c602435610413816101f4565b60443590610964565b60408051825181526020808401519082015291810151908201529081906060820190565b503461000e57606036600319011261000e5760243567ffffffffffffffff811161000e576100ba61047760209236906004016101ad565b60443590610484826101f4565b600435610e83565b503461000e5760031960403682011261000e576004359067ffffffffffffffff821161000e5761016090823603011261000e576104d160209160243590600401610df7565b604051908152f35b6020815191015190602081106104ed575090565b6000199060200360031b1b1690565b602181510361061157610513602182015191610623565b5160f81c6000600282141580610606575b6105f4578060405160208101906020825260206040820152602060608201526401000003d01980600781808a80098a090860808301527f3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff0c60a083015260c082015260c0815261059281610128565b519060055afa916105a161072e565b92156105e2576105c66105c06105b96105cf956104d9565b93846106f0565b60011690565b6105d25761075e565b90565b906105dc906106fd565b9061075e565b60405163102875ed60e01b8152600490fd5b60405163ab4be04160e01b8152600490fd5b506003821415610524565b604051636446a2c560e11b8152600490fd5b8051156106305760200190565b634e487b7160e01b600052603260045260246000fd5b8051600210156106305760220190565b8051600110156106305760210190565b8051600310156106305760230190565b8051600410156106305760240190565b908151811015610630570160200190565b50634e487b7160e01b600052601160045260246000fd5b60040190816004116106bc57565b6106c4610697565b565b90600182018092116106bc57565b90600482018092116106bc57565b90600282018092116106bc57565b919082018092116106bc57565b6401000003d019908103919082116106bc57565b6000198101919082116106bc57565b60200390602082116106bc57565b3d15610759573d9061073f82610182565b9161074d6040519384610160565b82523d6000602084013e565b606090565b6001600160a01b039160405190602082019283526040820152604081526060810181811067ffffffffffffffff82111761079d575b6040525190201690565b6107a56100e8565b610793565b60005b8381106107bd5750506000910152565b81810151838201526020016107ad565b906020916107e6815180928185528580860191016107aa565b601f01601f1916010190565b81601f8201121561000e57805161080881610182565b926108166040519485610160565b8184526020828401011161000e576105cf91602080850191016107aa565b90604090815160209061085b816102628482019760048952878084015260608301906107cd565b60008095819251907301000000000000000000000000000000000000055afa9061088361072e565b91156108e357815182019184818385019403126108df57818101519067ffffffffffffffff918281116108db5784846108be928401016107f2565b958101519182116108d7576105cf9495965001016107f2565b8680fd5b8780fd5b8580fd5b60649084519062461bcd60e51b82526004820152601b60248201527f67656e207369676e696e67206b6579706169723a206661696c656400000000006044820152fd5b604051906060820182811067ffffffffffffffff821117610957575b60405260006040838281528260208201520152565b61095f6100e8565b610942565b61096c610926565b506001600160a01b0380600092168252602060018152604091828420541692600282528083610a01610a30828420546109a3610926565b50835190878201528681526109b781610144565b8351908a888301528782526109cb82610144565b610a2485516109d9816100ff565b878152610a14875196879460808d87019a6109f48c60049052565b87015260a08601906107cd565b601f1995868683030160608701526107cd565b90848483030160808501526107cd565b03908101835282610160565b51907301000000000000000000000000000000000000065afa91610a5261072e565b9215610a6f57505090610a676105cf92610ae2565b928391610cf1565b60649250519062461bcd60e51b82526004820152600c60248201527f7369676e3a206661696c656400000000000000000000000000000000000000006044820152fd5b908160031b917f1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8116036106bc57565b90610aeb610926565b916008815110610c9d576001600160f81b0319600360fc1b81610b1e610b1085610623565b516001600160f81b03191690565b1603610c9d57600160f91b8082610b37610b1086610646565b1603610c9d57610b5b610b55610b4f610b1086610656565b60f81c90565b60ff1690565b91610b6e610b55610b4f610b1087610666565b9260218411610c9d57610b80846106ae565b90610b9c610b55610b4f610b10610b96866106c6565b8a610686565b9360218511610c9d57610bc2610bb5610b10858a610686565b6001600160f81b03191690565b03610c9d5780610bda610bd586886106f0565b6106d4565b03610c9d57610bea8651916106e2565b03610c9d57610bf8906106e2565b9060049060218514610caf575b60218414610c6a575b50906020809286010151940101519160208110610c53575b5060208110610c3b575b509083526020830152565b610c47610c4c91610720565b610ab2565b1c38610c30565b610c47610c6291949294610720565b1c9138610c26565b610c7a610b108488969496610686565b16610c9d576020610c94610c8e82946106c6565b92610711565b93919250610c0e565b6040516386cd05c560e01b8152600490fd5b939084610cbe610b1088610676565b16610cd55750610ccf600591610711565b93610c05565b6040516386cd05c560e01b8152fd5b506040513d6000823e3d90fd5b9160408101601b8152815191602081016020610d2b825160405196888860609194939260808201958252601b602083015260408201520152565b856000968792838052039060015afa15610de0575b83516001600160a01b038097169687911603610d5f575b505050505050565b610db194610d958593601c602096525192516040519384938460609194939260808201958252601c602083015260408201520152565b838052039060015afa15610dd3575b516001600160a01b031690565b03610dc157388080808080610d57565b604051634532600d60e01b8152600490fd5b610ddb610ce4565b610da4565b610de8610ce4565b610d40565b356105cf816101f4565b90610140820135601e198336030181121561000e57820180359267ffffffffffffffff9081851161000e576020830194803603861361000e5783019460408487031261000e573591821161000e57610e6a6040610e62610e6f94602080610e759a01918801016101ad565b9401356101f4565b610ded565b91610ec1565b610e7e57600190565b600090565b90610e8e9291610ec1565b610eb6577fffffffff0000000000000000000000000000000000000000000000000000000090565b630b135d3f60e11b90565b91906001600160a01b0380921660005260016020528160406000205416927f19457468657265756d205369676e6564204d6573736167653a0a33320000000060005280601c5282610f21610f1984603c60002061108e565b919091610f6e565b168414610f4557610f3591610f199161108e565b1614610f4057600090565b600190565b50505050600190565b60051115610f5857565b634e487b7160e01b600052602160045260246000fd5b610f7781610f4e565b80610f7f5750565b610f8881610f4e565b60018103610fd55760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e617475726500000000000000006044820152606490fd5b610fde81610f4e565b6002810361102b5760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e677468006044820152606490fd5b80611037600392610f4e565b1461103e57565b60405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b6064820152608490fd5b9060418151146000146110bc576110b8916020820151906060604084015193015160001a906110c6565b9091565b5050600090600290565b9291907f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0831161114a5791608094939160ff602094604051948552168484015260408301526060820152600093849182805260015afa1561113d575b81516001600160a01b03811615611137579190565b50600190565b611145610ce4565b611122565b5050505060009060039056fea2646970667358221220d8292a7f5015f3e5eaf54576d58db9388426c53e65e05257c8fbd5224cef092a64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3239,
        "contract": "contracts/modules/KeyManagementContractRegistryModule/KeyManagement.sol:KeyManagement",
        "label": "_modules",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_address)"
      },
      {
        "astId": 3243,
        "contract": "contracts/modules/KeyManagementContractRegistryModule/KeyManagement.sol:KeyManagement",
        "label": "publicAddress",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_address)"
      },
      {
        "astId": 3247,
        "contract": "contracts/modules/KeyManagementContractRegistryModule/KeyManagement.sol:KeyManagement",
        "label": "privateSecret",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_bytes32)"
      },
      {
        "astId": 3249,
        "contract": "contracts/modules/KeyManagementContractRegistryModule/KeyManagement.sol:KeyManagement",
        "label": "_initialized",
        "offset": 0,
        "slot": "3",
        "type": "t_bool"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_address,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      }
    }
  }
}