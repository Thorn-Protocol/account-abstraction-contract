{
  "address": "0xe353c618Ad35031Ca82689Fe3DBe400b84C7F71B",
  "abi": [
    {
      "inputs": [],
      "name": "DER_Split_Error",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "validationModule",
          "type": "address"
        }
      ],
      "name": "WrongValidationModule",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "expmod_Error",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "k256Decompress_Invalid_Length_Error",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "k256DeriveY_Invalid_Prefix_Error",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "recoverV_Error",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "_modules",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "initForSmartAccount",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "dataHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "moduleSignature",
          "type": "bytes"
        }
      ],
      "name": "isValidSignature",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "dataHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "moduleSignature",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        }
      ],
      "name": "isValidSignatureForAddress",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "setupContract",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "setupData",
          "type": "bytes"
        }
      ],
      "name": "setupAndEnableModule",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "authenticationData",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "digest",
          "type": "bytes32"
        }
      ],
      "name": "sign",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "v",
              "type": "uint256"
            }
          ],
          "internalType": "struct SignatureRSV",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "initCode",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            },
            {
              "internalType": "uint256",
              "name": "callGasLimit",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "verificationGasLimit",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxFeePerGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxPriorityFeePerGas",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "paymasterAndData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct UserOperation",
          "name": "userOp",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "userOpHash",
          "type": "bytes32"
        }
      ],
      "name": "validateUserOp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x443ccb03a4bef5133e2e3d223c812219cb1da4b4ab257e53923fdc6ede02ba2a",
  "receipt": {
    "to": "0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7",
    "from": "0x3Ec7289Ee996f8320451EcE2CB16eb5F0828F210",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "1183437",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd95f4e39b58bd6afe8e4dece6f6ca63a445aeeac07a8599965e4036a33746981",
    "transactionHash": "0x443ccb03a4bef5133e2e3d223c812219cb1da4b4ab257e53923fdc6ede02ba2a",
    "logs": [],
    "blockNumber": 6179788,
    "cumulativeGasUsed": "1183437",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "6a8fe44882ab5801e59e7cdd8bdedade",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"DER_Split_Error\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"validationModule\",\"type\":\"address\"}],\"name\":\"WrongValidationModule\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"expmod_Error\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"k256Decompress_Invalid_Length_Error\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"k256DeriveY_Invalid_Prefix_Error\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"recoverV_Error\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_modules\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initForSmartAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"moduleSignature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"moduleSignature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"}],\"name\":\"isValidSignatureForAddress\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"setupContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"setupData\",\"type\":\"bytes\"}],\"name\":\"setupAndEnableModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"authenticationData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"}],\"name\":\"sign\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"internalType\":\"struct SignatureRSV\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"}],\"name\":\"validateUserOp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/modules/KeyManagementContractRegistryModule/KeyManagement.sol\":\"KeyManagement\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@account-abstraction/contracts/core/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n/**\\n * returned data from validateUserOp.\\n * validateUserOp returns a uint256, with is created by `_packedValidationData` and parsed by `_parseValidationData`\\n * @param aggregator - address(0) - the account validated the signature by itself.\\n *              address(1) - the account failed to validate the signature.\\n *              otherwise - this is an address of a signature aggregator that must be used to validate the signature.\\n * @param validAfter - this UserOp is valid only after this timestamp.\\n * @param validaUntil - this UserOp is valid only up to this timestamp.\\n */\\n    struct ValidationData {\\n        address aggregator;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n    }\\n\\n//extract sigFailed, validAfter, validUntil.\\n// also convert zero validUntil to type(uint48).max\\n    function _parseValidationData(uint validationData) pure returns (ValidationData memory data) {\\n        address aggregator = address(uint160(validationData));\\n        uint48 validUntil = uint48(validationData >> 160);\\n        if (validUntil == 0) {\\n            validUntil = type(uint48).max;\\n        }\\n        uint48 validAfter = uint48(validationData >> (48 + 160));\\n        return ValidationData(aggregator, validAfter, validUntil);\\n    }\\n\\n// intersect account and paymaster ranges.\\n    function _intersectTimeRange(uint256 validationData, uint256 paymasterValidationData) pure returns (ValidationData memory) {\\n        ValidationData memory accountValidationData = _parseValidationData(validationData);\\n        ValidationData memory pmValidationData = _parseValidationData(paymasterValidationData);\\n        address aggregator = accountValidationData.aggregator;\\n        if (aggregator == address(0)) {\\n            aggregator = pmValidationData.aggregator;\\n        }\\n        uint48 validAfter = accountValidationData.validAfter;\\n        uint48 validUntil = accountValidationData.validUntil;\\n        uint48 pmValidAfter = pmValidationData.validAfter;\\n        uint48 pmValidUntil = pmValidationData.validUntil;\\n\\n        if (validAfter < pmValidAfter) validAfter = pmValidAfter;\\n        if (validUntil > pmValidUntil) validUntil = pmValidUntil;\\n        return ValidationData(aggregator, validAfter, validUntil);\\n    }\\n\\n/**\\n * helper to pack the return value for validateUserOp\\n * @param data - the ValidationData to pack\\n */\\n    function _packValidationData(ValidationData memory data) pure returns (uint256) {\\n        return uint160(data.aggregator) | (uint256(data.validUntil) << 160) | (uint256(data.validAfter) << (160 + 48));\\n    }\\n\\n/**\\n * helper to pack the return value for validateUserOp, when not using an aggregator\\n * @param sigFailed - true for signature failure, false for success\\n * @param validUntil last timestamp this UserOperation is valid (or zero for infinite)\\n * @param validAfter first timestamp this UserOperation is valid\\n */\\n    function _packValidationData(bool sigFailed, uint48 validUntil, uint48 validAfter) pure returns (uint256) {\\n        return (sigFailed ? 1 : 0) | (uint256(validUntil) << 160) | (uint256(validAfter) << (160 + 48));\\n    }\\n\\n/**\\n * keccak function over calldata.\\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\\n */\\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\\n        assembly {\\n            let mem := mload(0x40)\\n            let len := data.length\\n            calldatacopy(mem, data.offset, len)\\n            ret := keccak256(mem, len)\\n        }\\n    }\\n\\n\",\"keccak256\":\"0x591c87519f7155d1909210276b77925ab2722a99b7b5d5649aecc36ebbdb045a\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/interfaces/UserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\nimport {calldataKeccak} from \\\"../core/Helpers.sol\\\";\\n\\n/**\\n * User Operation struct\\n * @param sender the sender account of this request.\\n     * @param nonce unique value the sender uses to verify it is not a replay.\\n     * @param initCode if set, the account contract will be created by this constructor/\\n     * @param callData the method call to execute on this account.\\n     * @param callGasLimit the gas limit passed to the callData method call.\\n     * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\\n     * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\\n     * @param maxFeePerGas same as EIP-1559 gas parameter.\\n     * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\\n     * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\\n     * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n     */\\n    struct UserOperation {\\n\\n        address sender;\\n        uint256 nonce;\\n        bytes initCode;\\n        bytes callData;\\n        uint256 callGasLimit;\\n        uint256 verificationGasLimit;\\n        uint256 preVerificationGas;\\n        uint256 maxFeePerGas;\\n        uint256 maxPriorityFeePerGas;\\n        bytes paymasterAndData;\\n        bytes signature;\\n    }\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n\\n    function getSender(UserOperation calldata userOp) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {data := calldataload(userOp)}\\n        return address(uint160(data));\\n    }\\n\\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\\n    // pay above what he signed for.\\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint256) {\\n    unchecked {\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        if (maxFeePerGas == maxPriorityFeePerGas) {\\n            //legacy mode (for networks that don't support basefee opcode)\\n            return maxFeePerGas;\\n        }\\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n    }\\n    }\\n\\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\\n        address sender = getSender(userOp);\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        uint256 callGasLimit = userOp.callGasLimit;\\n        uint256 verificationGasLimit = userOp.verificationGasLimit;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return abi.encode(\\n            sender, nonce,\\n            hashInitCode, hashCallData,\\n            callGasLimit, verificationGasLimit, preVerificationGas,\\n            maxFeePerGas, maxPriorityFeePerGas,\\n            hashPaymasterAndData\\n        );\\n    }\\n\\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\\n        return keccak256(pack(userOp));\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\",\"keccak256\":\"0x61374003361059087fdcf17967a7bba052badeaf5c7f0ae689166f8aafd3a45c\",\"license\":\"GPL-3.0\"},\"@oasisprotocol/sapphire-contracts/contracts/EthereumUtils.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport {Sapphire} from \\\"./Sapphire.sol\\\";\\n\\nstruct SignatureRSV {\\n    bytes32 r;\\n    bytes32 s;\\n    uint256 v;\\n}\\n\\nlibrary EthereumUtils {\\n    uint256 internal constant K256_P =\\n        0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f;\\n\\n    // (p+1)//4\\n    uint256 internal constant K256_P_PLUS_1_OVER_4 =\\n        0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff0c;\\n\\n    address internal constant PRECOMPILE_BIGMODEXP = address(0x5);\\n\\n    error expmod_Error();\\n\\n    function expmod(\\n        uint256 base,\\n        uint256 exponent,\\n        uint256 modulus\\n    ) internal view returns (uint256 out) {\\n        (bool success, bytes memory result) = PRECOMPILE_BIGMODEXP.staticcall(\\n            abi.encodePacked(\\n                uint256(0x20), // length of base\\n                uint256(0x20), // length of exponent\\n                uint256(0x20), // length of modulus\\n                base,\\n                exponent,\\n                modulus\\n            )\\n        );\\n\\n        if (!success) revert expmod_Error();\\n\\n        out = uint256(bytes32(result));\\n    }\\n\\n    error k256DeriveY_Invalid_Prefix_Error();\\n\\n    /**\\n     * @notice Recover Y coordinate from X coordinate and sign bit.\\n     * @param prefix 0x02 or 0x03 indicates sign bit of compressed point.\\n     * @param x X coordinate.\\n     */\\n    function k256DeriveY(uint8 prefix, uint256 x)\\n        internal\\n        view\\n        returns (uint256 y)\\n    {\\n        if (prefix != 0x02 && prefix != 0x03)\\n            revert k256DeriveY_Invalid_Prefix_Error();\\n\\n        // x^3 + ax + b, where a=0, b=7\\n        y = addmod(mulmod(x, mulmod(x, x, K256_P), K256_P), 7, K256_P);\\n\\n        // find square root of quadratic residue\\n        y = expmod(y, K256_P_PLUS_1_OVER_4, K256_P);\\n\\n        // negate y if indicated by sign bit\\n        if ((y + prefix) % 2 != 0) {\\n            y = K256_P - y;\\n        }\\n    }\\n\\n    error k256Decompress_Invalid_Length_Error();\\n\\n    /**\\n     * @notice Decompress SEC P256 k1 point.\\n     * @param pk 33 byte compressed public key.\\n     * @return x X coordinate.\\n     * @return y Y coordinate.\\n     */\\n    function k256Decompress(bytes memory pk)\\n        internal\\n        view\\n        returns (uint256 x, uint256 y)\\n    {\\n        if (pk.length != 33) revert k256Decompress_Invalid_Length_Error();\\n        assembly {\\n            // skip 32 byte length prefix, plus one byte sign prefix\\n            x := mload(add(pk, 33))\\n        }\\n        y = k256DeriveY(uint8(pk[0]), x);\\n    }\\n\\n    function k256PubkeyToEthereumAddress(bytes memory pubkey)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        (uint256 x, uint256 y) = k256Decompress(pubkey);\\n        return toEthereumAddress(x, y);\\n    }\\n\\n    /**\\n     * @notice Convert SEC P256 k1 curve point to Ethereum address.\\n     * @param x X coordinate.\\n     * @param y Y coordinate.\\n     * @custom:see https://gavwood.com/paper.pdf (pp. 212)\\n     */\\n    function toEthereumAddress(uint256 x, uint256 y)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        bytes32 digest = keccak256(abi.encodePacked(x, y));\\n\\n        return address(uint160((uint256(digest) << 96) >> 96));\\n    }\\n\\n    error DER_Split_Error();\\n\\n    /**\\n     * @notice Extracts the `r` and `s` parameters from a DER encoded ECDSA\\n     * signature.\\n     *\\n     * The signature is an ASN1 encoded SEQUENCE of the variable length `r` and\\n     * `s` INTEGERs.\\n     *\\n     * ```\\n     * | 0x30 | len(z) | 0x02 | len(r) |  r   | 0x02 | len(s) |  s   | = hex value\\n     * |  1   |   1    |   1  |   1    | 1-33 |  1   |   1    | 1-33 | = byte length\\n     * ```\\n     *\\n     * If the highest bit of either `r` or `s` is set, it will be prefix padded\\n     * with a zero byte. There is exponentially decreasing probability that\\n     * either `r` or `s` will be below 32 bytes. There is a very high\\n     * probability that either `r` or `s` will be 33 bytes. This function only\\n     * works if either `r` or `s` are 256bits or lower.\\n     *\\n     * @param der DER encoded ECDSA signature\\n     * @return rsv ECDSA R point X coordinate, and S scalar\\n     * @custom:see https://bitcoin.stackexchange.com/questions/58853/how-do-you-figure-out-the-r-and-s-out-of-a-signature-using-python\\n     */\\n    function splitDERSignature(bytes memory der)\\n        internal\\n        pure\\n        returns (SignatureRSV memory rsv)\\n    {\\n        if (der.length < 8) revert DER_Split_Error();\\n        if (der[0] != 0x30) revert DER_Split_Error();\\n        if (der[2] != 0x02) revert DER_Split_Error();\\n\\n        uint256 zLen = uint8(der[1]);\\n        uint256 rLen = uint8(der[3]);\\n        if (rLen > 33) revert DER_Split_Error();\\n\\n        uint256 sOffset = 4 + rLen;\\n        uint256 sLen = uint8(der[sOffset + 1]);\\n        if (sLen > 33) revert DER_Split_Error();\\n        if (der[sOffset] != 0x02) revert DER_Split_Error();\\n\\n        if (rLen + sLen + 4 != zLen) revert DER_Split_Error();\\n        if (der.length != zLen + 2) revert DER_Split_Error();\\n\\n        sOffset += 2;\\n        uint256 rOffset = 4;\\n\\n        if (rLen == 33) {\\n            if (der[4] != 0x00) revert DER_Split_Error();\\n            rOffset += 1;\\n            rLen -= 1;\\n        }\\n\\n        if (sLen == 33) {\\n            if (der[sOffset] != 0x00) revert DER_Split_Error();\\n            sOffset += 1;\\n            sLen -= 1;\\n        }\\n\\n        bytes32 r;\\n        bytes32 s;\\n\\n        assembly {\\n            r := mload(add(der, add(32, rOffset)))\\n            s := mload(add(der, add(32, sOffset)))\\n        }\\n\\n        // When length of either `r` or `s` is below 32 bytes\\n        // the 32 byte `mload` will suffix it with unknown stuff\\n        // shift right to remove the unknown stuff, prefixing with zeros instead\\n\\n        if (rLen < 32) {\\n            r >>= 8 * (32 - rLen);\\n        }\\n\\n        if (sLen < 32) {\\n            s >>= 8 * (32 - sLen);\\n        }\\n\\n        rsv.r = r;\\n        rsv.s = s;\\n    }\\n\\n    error recoverV_Error();\\n\\n    function recoverV(\\n        address pubkeyAddr,\\n        bytes32 digest,\\n        SignatureRSV memory rsv\\n    ) internal pure {\\n        rsv.v = 27;\\n\\n        if (ecrecover(digest, uint8(rsv.v), rsv.r, rsv.s) != pubkeyAddr) {\\n            rsv.v = 28;\\n\\n            if (ecrecover(digest, uint8(rsv.v), rsv.r, rsv.s) != pubkeyAddr) {\\n                revert recoverV_Error();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Convert a Secp256k1PrehashedKeccak256 signature to one accepted\\n     * by ecrecover.\\n     * @param pubkey 33 byte compressed public key.\\n     * @param digest 32 byte pre-hashed message digest.\\n     * @param signature ASN.1 DER encoded signature, as returned from\\n     * [`Sapphire.sign`](../Sapphire.sol/library.Sapphire.md#sign).\\n     * @return pubkeyAddr 20 byte Ethereum address.\\n     * @return rsv Ethereum EcDSA RSV signature values.\\n     * @custom:see https://gavwood.com/paper.pdf (pp. 206)\\n     */\\n    function toEthereumSignature(\\n        bytes memory pubkey,\\n        bytes32 digest,\\n        bytes memory signature\\n    ) internal view returns (address pubkeyAddr, SignatureRSV memory rsv) {\\n        pubkeyAddr = k256PubkeyToEthereumAddress(pubkey);\\n\\n        rsv = splitDERSignature(signature);\\n\\n        recoverV(pubkeyAddr, digest, rsv);\\n    }\\n\\n    function sign(\\n        address pubkeyAddr,\\n        bytes32 secretKey,\\n        bytes32 digest\\n    ) internal view returns (SignatureRSV memory rsv) {\\n        bytes memory signature = Sapphire.sign(\\n            Sapphire.SigningAlg.Secp256k1PrehashedKeccak256,\\n            abi.encodePacked(secretKey),\\n            abi.encodePacked(digest),\\n            \\\"\\\"\\n        );\\n\\n        rsv = splitDERSignature(signature);\\n\\n        recoverV(pubkeyAddr, digest, rsv);\\n    }\\n\\n    /**\\n     * @notice Generate an Ethereum compatible SEC P256 k1 keypair and\\n     * corresponding public address.\\n     * @return pubkeyAddr Ethereum address.\\n     * @return secretKey Secret key used for signing.\\n     */\\n    function generateKeypair()\\n        internal\\n        view\\n        returns (address pubkeyAddr, bytes32 secretKey)\\n    {\\n        bytes memory randSeed = Sapphire.randomBytes(32, \\\"\\\");\\n\\n        secretKey = bytes32(randSeed);\\n\\n        (bytes memory pk, ) = Sapphire.generateSigningKeyPair(\\n            Sapphire.SigningAlg.Secp256k1PrehashedKeccak256,\\n            randSeed\\n        );\\n\\n        pubkeyAddr = k256PubkeyToEthereumAddress(pk);\\n    }\\n}\\n\",\"keccak256\":\"0x79e34844793f4a8970d31eb4cbdd91e060fb93da4cbd28b7b8aad5c22e1f6666\",\"license\":\"Apache-2.0\"},\"@oasisprotocol/sapphire-contracts/contracts/Sapphire.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Sapphire\\n * @notice This library provides a number of convenient wrappers for\\n * cryptographic operations such as the x25519 key derivation, Deoxys-II-based\\n * encryption and decryption, signing key generation, message digest signing and\\n * verification, gas padding and hashing.\\n *\\n * Most of the mentioned functions are implemented as Sapphire's precompiles and\\n * are cheap to call.\\n *\\n * #### Calling Precompiles Manually\\n *\\n * You can override the wrappers and call Sapphire precompiles by dispatching\\n * calls to specific well-known contract addresses, as described below. The\\n * __Precompile address__ section of each function will show you the address\\n * of the corresponding precompile.\\n *\\n * Input parameters should be packed into a contiguous memory region with each\\n * chunk of data padded to 32 bytes as usual. The recommended way to construct\\n * parameter byte sequences in Solidity is with `abi.encode` and `abi.decode`,\\n * which will transparently handle things like putting `bytes` lengths in the\\n * correct position.\\n */\\nlibrary Sapphire {\\n    // Oasis-specific, confidential precompiles\\n    address internal constant RANDOM_BYTES =\\n        0x0100000000000000000000000000000000000001;\\n    address internal constant DERIVE_KEY =\\n        0x0100000000000000000000000000000000000002;\\n    address internal constant ENCRYPT =\\n        0x0100000000000000000000000000000000000003;\\n    address internal constant DECRYPT =\\n        0x0100000000000000000000000000000000000004;\\n    address internal constant GENERATE_SIGNING_KEYPAIR =\\n        0x0100000000000000000000000000000000000005;\\n    address internal constant SIGN_DIGEST =\\n        0x0100000000000000000000000000000000000006;\\n    address internal constant VERIFY_DIGEST =\\n        0x0100000000000000000000000000000000000007;\\n    address internal constant CURVE25519_PUBLIC_KEY =\\n        0x0100000000000000000000000000000000000008;\\n    address internal constant GAS_USED =\\n        0x0100000000000000000000000000000000000009;\\n    address internal constant PAD_GAS =\\n        0x010000000000000000000000000000000000000a;\\n\\n    // Oasis-specific, general precompiles\\n    address internal constant SHA512_256 =\\n        0x0100000000000000000000000000000000000101;\\n    address internal constant SHA512 =\\n        0x0100000000000000000000000000000000000102;\\n    address internal constant SHA384 =\\n        0x0100000000000000000000000000000000000104;\\n\\n    type Curve25519PublicKey is bytes32;\\n    type Curve25519SecretKey is bytes32;\\n\\n    enum SigningAlg {\\n        /// Ed25519 signature over the provided message using SHA-512/265 with a domain separator.\\n        /// Can be used to sign transactions for the Oasis consensus layer and SDK paratimes.\\n        Ed25519Oasis,\\n        /// Ed25519 signature over the provided message.\\n        Ed25519Pure,\\n        /// Ed25519 signature over the provided prehashed SHA-512 digest.\\n        Ed25519PrehashedSha512,\\n        /// Secp256k1 signature over the provided message using SHA-512/256 with a domain separator.\\n        /// Can be used to sign transactions for the Oasis consensus layer and SDK paratimes.\\n        Secp256k1Oasis,\\n        /// Secp256k1 over the provided Keccak256 digest.\\n        /// Can be used to sign transactions for Ethereum-compatible networks.\\n        Secp256k1PrehashedKeccak256,\\n        /// Secp256k1 signature over the provided SHA-256 digest.\\n        Secp256k1PrehashedSha256,\\n        /// Sr25519 signature over the provided message.\\n        Sr25519,\\n        /// Secp256r1 signature over the provided SHA-256 digest.\\n        Secp256r1PrehashedSha256,\\n        /// Secp384r1 signature over the provided SHA-384 digest.\\n        Secp384r1PrehashedSha384\\n    }\\n\\n    /**\\n     * @notice Generate `num_bytes` pseudo-random bytes, with an optional\\n     * personalization string (`pers`) added into the hashing algorithm to\\n     * increase domain separation when needed.\\n     *\\n     * #### Precompile address\\n     *\\n     * `0x0100000000000000000000000000000000000001`\\n     *\\n     * #### Gas cost\\n     *\\n     * 10,000 minimum plus 240 per output word plus 60 per word of the\\n     * personalization string.\\n     *\\n     * #### Implementation details\\n     *\\n     * The mode (e.g. simulation or \\\"view call\\\" vs transaction execution) is fed\\n     * to TupleHash (among other block-dependent components) to derive the \\\"key\\n     * id\\\", which is then used to derive a per-block VRF key from\\n     * epoch-ephemeral entropy (using KMAC256 and cSHAKE) so a different key\\n     * id will result in a unique per-block VRF key. This per-block VRF key is\\n     * then used to create the per-block root RNG which is then used to derive\\n     * domain-separated (using Merlin transcripts) per-transaction random RNGs\\n     * which are then exposed via this precompile. The KMAC, cSHAKE and\\n     * TupleHash algorithms are SHA-3 derived functions defined in [NIST\\n     * Special Publication 800-185](https://nvlpubs.nist.gov/nistpubs/specialpublications/nist.sp.800-185.pdf).\\n     *\\n     * #### DANGER: Prior to Sapphire ParaTime 0.6.0\\n     *\\n     * All view queries and simulated transactions (via `eth_call`) would\\n     * receive the same entropy in-between blocks if they use the same\\n     * `num_bytes` and `pers` parameters. If your contract requires\\n     * confidentiality you should generate a secret in the constructor to be\\n     * used with view calls:\\n     *\\n     * ```solidity\\n     * Sapphire.randomBytes(64, abi.encodePacked(msg.sender, this.perContactSecret));\\n     * ```\\n     *\\n     * #### Example\\n     *\\n     * ```solidity\\n     * bytes memory randomPad = Sapphire.randomBytes(64, \\\"\\\");\\n     * ```\\n     *\\n     * @param numBytes The number of bytes to return.\\n     * @param pers An optional personalization string to increase domain\\n     *        separation.\\n     * @return The random bytes. If the number of bytes requested is too large\\n     *         (over 1024), a smaller amount (1024) will be returned.\\n     */\\n    function randomBytes(uint256 numBytes, bytes memory pers)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        (bool success, bytes memory entropy) = RANDOM_BYTES.staticcall(\\n            abi.encode(numBytes, pers)\\n        );\\n        require(success, \\\"randomBytes: failed\\\");\\n        return entropy;\\n    }\\n\\n    /**\\n     * @notice Generates a Curve25519 keypair.\\n     * @param pers An optional personalization string used to add domain\\n     * separation.\\n     * @return pk The Curve25519 public key. Useful for key exchange.\\n     * @return sk The Curve25519 secret key. Pairs well with\\n     * [deriveSymmetricKey](#derivesymmetrickey).\\n     */\\n    function generateCurve25519KeyPair(bytes memory pers)\\n        internal\\n        view\\n        returns (Curve25519PublicKey pk, Curve25519SecretKey sk)\\n    {\\n        bytes memory scalar = randomBytes(32, pers);\\n        // Twiddle some bits, as per RFC 7748 \\u00a75.\\n        scalar[0] &= 0xf8; // Make it a multiple of 8 to avoid small subgroup attacks.\\n        scalar[31] &= 0x7f; // Clamp to < 2^255 - 19\\n        scalar[31] |= 0x40; // Clamp to >= 2^254\\n        (bool success, bytes memory pkBytes) = CURVE25519_PUBLIC_KEY.staticcall(\\n            scalar\\n        );\\n        require(success, \\\"gen curve25519 pk: failed\\\");\\n        return (\\n            Curve25519PublicKey.wrap(bytes32(pkBytes)),\\n            Curve25519SecretKey.wrap(bytes32(scalar))\\n        );\\n    }\\n\\n    /**\\n     * @notice Derive a symmetric key from a pair of keys using x25519.\\n     *\\n     * #### Precompile address\\n     *\\n     * `0x0100000000000000000000000000000000000002`\\n     *\\n     * #### Gas cost\\n     *\\n     * 100,000\\n     *\\n     * #### Example\\n     *\\n     * ```solidity\\n     * bytes32 publicKey = ... ;\\n     * bytes32 privateKey = ... ;\\n     * bytes32 symmetric = Sapphire.deriveSymmetricKey(publicKey, privateKey);\\n     * ```\\n     *\\n     * @param peerPublicKey The peer's public key.\\n     * @param secretKey Your secret key.\\n     * @return A derived symmetric key.\\n     */\\n    function deriveSymmetricKey(\\n        Curve25519PublicKey peerPublicKey,\\n        Curve25519SecretKey secretKey\\n    ) internal view returns (bytes32) {\\n        (bool success, bytes memory symmetric) = DERIVE_KEY.staticcall(\\n            abi.encode(peerPublicKey, secretKey)\\n        );\\n        require(success, \\\"deriveSymmetricKey: failed\\\");\\n        return bytes32(symmetric);\\n    }\\n\\n    /**\\n     * @notice Encrypt and authenticate the plaintext and additional data using\\n     * DeoxysII.\\n     *\\n     * #### Precompile address\\n     *\\n     * `0x0100000000000000000000000000000000000003`\\n     *\\n     * #### Gas cost\\n     *\\n     * 50,000 minimum plus 100 per word of input\\n     *\\n     * #### Example\\n     *\\n     * ```solidity\\n     * bytes32 key = ... ;\\n     * bytes32 nonce = ... ;\\n     * bytes memory text = \\\"plain text\\\";\\n     * bytes memory ad = \\\"additional data\\\";\\n     * bytes memory encrypted = Sapphire.encrypt(key, nonce, text, ad);\\n     * bytes memory decrypted = Sapphire.decrypt(key, nonce, encrypted, ad);\\n     * ```\\n     *\\n     * @param key The key to use for encryption.\\n     * @param nonce The nonce. Note that only the first 15 bytes of this\\n     * parameter are used.\\n     * @param plaintext The plaintext to encrypt and authenticate.\\n     * @param additionalData The additional data to authenticate.\\n     * @return The ciphertext with appended auth tag.\\n     */\\n    function encrypt(\\n        bytes32 key,\\n        bytes32 nonce,\\n        bytes memory plaintext,\\n        bytes memory additionalData\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory ciphertext) = ENCRYPT.staticcall(\\n            abi.encode(key, nonce, plaintext, additionalData)\\n        );\\n        require(success, \\\"encrypt: failed\\\");\\n        return ciphertext;\\n    }\\n\\n    /**\\n     * @notice Decrypt and authenticate the ciphertext and additional data using\\n     * DeoxysII. Reverts if the auth tag is incorrect.\\n     *\\n     * #### Precompile address\\n     *\\n     * `0x0100000000000000000000000000000000000004`\\n     *\\n     * #### Gas cost\\n     *\\n     * 50,000 minimum plus 100 per word of input\\n     *\\n     * #### Example\\n     *\\n     * ```solidity\\n     * bytes32 key = ... ;\\n     * bytes32 nonce = ... ;\\n     * bytes memory text = \\\"plain text\\\";\\n     * bytes memory ad = \\\"additional data\\\";\\n     * bytes memory encrypted = Sapphire.encrypt(key, nonce, text, ad);\\n     * bytes memory decrypted = Sapphire.decrypt(key, nonce, encrypted, ad);\\n     * ```\\n     *\\n     * @param key The key to use for decryption.\\n     * @param nonce The nonce. Note that only the first 15 bytes of this\\n     * parameter are used.\\n     * @param ciphertext The ciphertext with tag to decrypt and authenticate.\\n     * @param additionalData The additional data to authenticate against the\\n     * ciphertext.\\n     * @return The original plaintext.\\n     */\\n    function decrypt(\\n        bytes32 key,\\n        bytes32 nonce,\\n        bytes memory ciphertext,\\n        bytes memory additionalData\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory plaintext) = DECRYPT.staticcall(\\n            abi.encode(key, nonce, ciphertext, additionalData)\\n        );\\n        require(success, \\\"decrypt: failed\\\");\\n        return plaintext;\\n    }\\n\\n    /**\\n     * @notice Generate a public/private key pair using the specified method and\\n     * seed. The available methods are items in the\\n     * [`Sapphire.SigningAlg`](#signingalg) enum. Note, however, that the\\n     * generation method ignores subvariants, so all three Ed25519-based are\\n     * equivalent, and all Secp256k1 & Secp256r1 based methods are equivalent.\\n     * Sr25519 is not available and will return an error.\\n     *\\n     * #### Precompile address\\n     * `0x0100000000000000000000000000000000000005`\\n     *\\n     * #### Gas Cost\\n     *\\n     * ##### Ed25519: 1,000 gas\\n     *\\n     * - `0` (`Ed25519Oasis`)\\n     * - `1` (`Ed25519Pure`)\\n     * - `2` (`Ed25519PrehashedSha512`)\\n     *\\n     * ##### Secp256k1: 1,500 gas.\\n     * - `3` (`Secp256k1Oasis`)\\n     * - `4` (`Secp256k1PrehashedKeccak256`)\\n     * - `5` (`Secp256k1PrehashedSha256`)\\n     *\\n     * ##### Secp256r1: 4,000 gas\\n     * - `7` (`Secp256r1PrehashedSha256`)\\n     *\\n     * #### Public Key Format\\n     *\\n     * ##### Ed25519\\n     *\\n     * 32 bytes\\n     *\\n     * ##### Secp256k1 & Secp256r1\\n     *\\n     * 33 bytes, compressed format (`0x02` or `0x03` prefix, then 32 byte X\\n     * coordinate).\\n     *\\n     * #### Example\\n     *\\n     * ```solidity\\n     * bytes memory seed = hex\\\"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\\\";\\n     * bytes memory publicKey;\\n     * bytes memory privateKey;\\n     * (publicKey, privateKey) = Sapphire.generateSigningKeyPair(Sapphire.SigningAlg.Ed25519Pure, seed);\\n     * ```\\n     *\\n     * @param alg The signing alg for which to generate a keypair.\\n     * @param seed The seed to use for generating the key pair. You can use the\\n     * `randomBytes` method if you don't already have a seed.\\n     * @return publicKey The public half of the keypair.\\n     * @return secretKey The secret half of the keypair.\\n     */\\n    function generateSigningKeyPair(SigningAlg alg, bytes memory seed)\\n        internal\\n        view\\n        returns (bytes memory publicKey, bytes memory secretKey)\\n    {\\n        (bool success, bytes memory keypair) = GENERATE_SIGNING_KEYPAIR\\n            .staticcall(abi.encode(alg, seed));\\n        require(success, \\\"gen signing keypair: failed\\\");\\n        return abi.decode(keypair, (bytes, bytes));\\n    }\\n\\n    /**\\n     * @notice Sign a message within the provided context using the specified\\n     * algorithm, and return the signature. The `context_or_digest` and\\n     * `messages` parameters change in meaning slightly depending on the method\\n     * requested. For methods that take a context in addition to the message you\\n     * must pass the context in the `context_or_digest` parameter and use\\n     * `message` as expected. For methods that take a pre-existing hash of the\\n     * message, pass that in `context_or_digest` and leave `message` empty.\\n     * Specifically the `Ed25519Oasis` and `Secp256k1Oasis` variants take both a\\n     * context and a message (each are variable length `bytes`), the context\\n     * serves as a domain separator.\\n     *\\n     * #### Precompile address\\n     *\\n     * `0x0100000000000000000000000000000000000006`\\n     *\\n     * #### Gas cost\\n     *\\n     * See below for the method-dependent base cost, plus 8 gas per 32 bytes of\\n     * context and message except digest.\\n     *\\n     * #### Signing algorithms\\n     *\\n     * - `0` (`Ed25519Oasis`): 1,500 gas, variable length context and message.\\n     * - `1` (`Ed25519Pure`): 1,500 gas, empty context, variable length message.\\n     * - `2` (`Ed25519PrehashedSha512`): 1,500 gas, pre-existing SHA-512 hash\\n     *   (64 bytes) as context, empty message.\\n     * - `3` (`Secp256k1Oasis`): 3,000 gas, variable length context and message\\n     * - `4` (`Secp256k1PrehashedKeccak256`): 3,000 gas, pre-existing hash\\n     *   (32 bytes) as context, empty message.\\n     * - `5` (`Secp256k1PrehashedSha256`): 3,000 gas, pre-existing hash (32\\n     *   bytes) as context, empty message.\\n     * - `7` (`Secp256r1PrehashedSha256`): 9,000 gas, pre-existing hash (32\\n     *   bytes) as context, empty message.\\n     *\\n     * #### Example\\n     *\\n     * ```solidity\\n     * Sapphire.SigningAlg alg = Sapphire.SigningAlg.Ed25519Pure;\\n     * bytes memory pk;\\n     * bytes memory sk;\\n     * (pk, sk) = Sapphire.generateSigningKeyPair(alg, Sapphire.randomBytes(32, \\\"\\\"));\\n     * bytes memory signature = Sapphire.sign(alg, sk, \\\"\\\", \\\"signed message\\\");\\n     * ```\\n     *\\n     * @param alg The signing algorithm to use.\\n     * @param secretKey The secret key to use for signing. The key must be valid\\n     * for use with the requested algorithm.\\n     * @param contextOrHash Domain-Separator Context, or precomputed hash bytes.\\n     * @param message Message to sign, should be zero-length if precomputed hash\\n     * given.\\n     * @return signature The resulting signature.\\n     * @custom:see @oasisprotocol/oasis-sdk :: precompile/confidential.rs :: call_sign\\n     */\\n    function sign(\\n        SigningAlg alg,\\n        bytes memory secretKey,\\n        bytes memory contextOrHash,\\n        bytes memory message\\n    ) internal view returns (bytes memory signature) {\\n        (bool success, bytes memory sig) = SIGN_DIGEST.staticcall(\\n            abi.encode(alg, secretKey, contextOrHash, message)\\n        );\\n        require(success, \\\"sign: failed\\\");\\n        return sig;\\n    }\\n\\n    /**\\n     * @notice Verifies that the provided digest was signed with using the\\n     * secret key corresponding to the provided private key and the specified\\n     * signing algorithm.\\n     *\\n     * The `method`, `context_or_digest` and `message` parameters have the same\\n     * meaning as described above in the [sign()](#sign) function.\\n     *\\n     * #### Precompile address\\n     *\\n     * `0x0100000000000000000000000000000000000007`\\n     *\\n     * #### Gas cost\\n     *\\n     * The algorithm-specific base cost below, with an additional **8 gas per\\n     * 32 bytes** of `context` and `message` for the `Ed25519Oasis`,\\n     * `Ed25519Pure` and `Secp256k1Oasis` algorithms.\\n     *\\n     * - `0` (`Ed25519Oasis`): 2,000 gas\\n     * - `1` (`Ed25519Pure`): 2,000 gas\\n     * - `2` (`Ed25519PrehashedSha512`): 2,000 gas\\n     * - `3` (`Secp256k1Oasis`): 3,000 gas\\n     * - `4` (`Secp256k1PrehashedKeccak256`): 3,000 gas\\n     * - `5` (`Secp256k1PrehashedSha256`): 3,000 gas\\n     * - `7` (`Secp256r1PrehashedSha256`): 7,900 gas\\n     *\\n     * #### Example\\n     *\\n     * ```solidity\\n     * Sapphire.SigningAlg alg = Sapphire.SigningAlg.Secp256k1PrehashedKeccak256;\\n     * bytes memory pk;\\n     * bytes memory sk;\\n     * bytes memory digest = abi.encodePacked(keccak256(\\\"signed message\\\"));\\n     * (pk, sk) = Sapphire.generateSigningKeyPair(alg, Sapphire.randomBytes(32, \\\"\\\"));\\n     * bytes memory signature = Sapphire.sign(alg, sk, digest, \\\"\\\");\\n     * require( Sapphire.verify(alg, pk, digest, \\\"\\\", signature) );\\n     * ```\\n     *\\n     * @param alg The signing algorithm by which the signature was generated.\\n     * @param publicKey The public key against which to check the signature.\\n     * @param contextOrHash Domain-Separator Context, or precomputed hash bytes\\n     * @param message The hash of the message that was signed, should be\\n     * zero-length if precomputed hash was given.\\n     * @param signature The signature to check.\\n     * @return verified Whether the signature is valid for the given parameters.\\n     * @custom:see @oasisprotocol/oasis-sdk :: precompile/confidential.rs :: call_verify\\n     */\\n    function verify(\\n        SigningAlg alg,\\n        bytes memory publicKey,\\n        bytes memory contextOrHash,\\n        bytes memory message,\\n        bytes memory signature\\n    ) internal view returns (bool verified) {\\n        (bool success, bytes memory v) = VERIFY_DIGEST.staticcall(\\n            abi.encode(alg, publicKey, contextOrHash, message, signature)\\n        );\\n        require(success, \\\"verify: failed\\\");\\n        return abi.decode(v, (bool));\\n    }\\n\\n    /**\\n     * @notice Set the current transactions gas usage to a specific amount\\n     * @dev Will cause a reversion if the current usage is more than the amount.\\n     * @param toAmount Gas usage will be set to this amount\\n     * @custom:see @oasisprotocol/oasis-sdk :: precompile/gas.rs :: call_pad_gas\\n     *\\n     */\\n    function padGas(uint128 toAmount) internal view {\\n        (bool success, ) = PAD_GAS.staticcall(abi.encode(toAmount));\\n        require(success, \\\"verify: failed\\\");\\n    }\\n\\n    /**\\n     * @notice Returns the amount of gas currently used by the transaction\\n     * @custom:see @oasisprotocol/oasis-sdk :: precompile/gas.rs :: call_gas_used\\n     */\\n    function gasUsed() internal view returns (uint64) {\\n        (bool success, bytes memory v) = GAS_USED.staticcall(\\\"\\\");\\n        require(success, \\\"gasused: failed\\\");\\n        return abi.decode(v, (uint64));\\n    }\\n}\\n\\n/**\\n * @notice Hash the input data with SHA-512/256, according to\\n * [NIST.FIPS.180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\\n *\\n * #### Precompile address\\n *\\n * `0x0100000000000000000000000000000000000102`\\n *\\n * #### Gas cost\\n *\\n * 115 gas, then 13 gas per word\\n *\\n * #### Example\\n *\\n * ```solidity\\n * bytes32 result = sha512_256(abi.encodePacked(\\\"input data\\\"));\\n * ```\\n *\\n * #### Warning: SHA-512 vs SHA-512/256 Length-Extension Attacks\\n *\\n * [SHA-512](function.sha512.md#sha512) is vulnerable to [length-extension\\n * attacks](https://en.wikipedia.org/wiki/Length_extension_attack), which are\\n * relevant if you are computing the hash of a secret message. The\\n * [SHA-512/256](function.sha512_256.md#sha512_256) variant is **not**\\n * vulnerable to length-extension attacks.\\n *\\n * @param input Bytes to hash.\\n * @return result 32 byte digest.\\n * @custom:standard https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\\n * @custom:see @oasisprotocol/oasis-sdk :: precompile/sha2.rs :: call_sha512_256\\n */\\nfunction sha512_256(bytes memory input) view returns (bytes32 result) {\\n    (bool success, bytes memory output) = Sapphire.SHA512_256.staticcall(input);\\n\\n    require(success, \\\"sha512_256\\\");\\n\\n    return bytes32(output);\\n}\\n\\n/**\\n * @notice Hash the input data with SHA-512, according to\\n * [NIST.FIPS.180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf)\\n *\\n * #### Precompile address\\n *\\n * `0x0100000000000000000000000000000000000101`\\n *\\n * #### Warning: SHA-512 vs SHA-512/256 Length-Extension Attacks\\n *\\n * [SHA-512](function.sha512.md#sha512) is vulnerable to [length-extension\\n * attacks](https://en.wikipedia.org/wiki/Length_extension_attack), which are\\n * relevant if you are computing the hash of a secret message. The\\n * [SHA-512/256](function.sha512_256.md#sha512_256) variant is **not**\\n * vulnerable to length-extension attacks.\\n *\\n * #### Gas Cost\\n *\\n * 115 gas, then 13 gas per word\\n *\\n * #### Example\\n *\\n * ```solidity\\n * bytes memory result = sha512(abi.encodePacked(\\\"input data\\\"));\\n * ```\\n *\\n * @param input Bytes to hash.\\n * @return output 64 byte digest.\\n * @custom:standard https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\\n * @custom:see @oasisprotocol/oasis-sdk :: precompile/sha2.rs :: call_sha512\\n */\\nfunction sha512(bytes memory input) view returns (bytes memory output) {\\n    bool success;\\n\\n    (success, output) = Sapphire.SHA512.staticcall(input);\\n\\n    require(success, \\\"sha512\\\");\\n}\\n\\n/**\\n * @notice Hash the input data with SHA-384.\\n * @param input Bytes to hash.\\n * @return output 48 byte digest.\\n * @custom:standard https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\\n * @custom:see @oasisprotocol/oasis-sdk :: precompile/sha2.rs :: call_sha384\\n */\\nfunction sha384(bytes memory input) view returns (bytes memory output) {\\n    bool success;\\n\\n    (success, output) = Sapphire.SHA384.staticcall(input);\\n\\n    require(success, \\\"sha384\\\");\\n}\\n\",\"keccak256\":\"0x81a0aa5766f7c48ea799114f44e902b2eb11f21808db23d56b6ca9edd48b8f59\",\"license\":\"Apache-2.0\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\",\"keccak256\":\"0x809bc3edb4bcbef8263fa616c1b60ee0004b50a8a1bfa164d8f57fd31f520c58\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"contracts/interfaces/IAuthorizationModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\nimport {UserOperation} from \\\"@account-abstraction/contracts/interfaces/UserOperation.sol\\\";\\r\\n\\r\\n// interface for modules to verify singatures signed over userOpHash\\r\\ninterface IAuthorizationModule {\\r\\n    function validateUserOp(\\r\\n        UserOperation calldata userOp,\\r\\n        bytes32 userOpHash\\r\\n    ) external returns (uint256 validationData);\\r\\n}\\r\\n\",\"keccak256\":\"0x9a1e3f0f381edef142edcb3eb1dcab1f032bb2b68728f4ee22824d79137dd053\",\"license\":\"MIT\"},\"contracts/interfaces/ISignatureValidator.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ncontract ISignatureValidatorConstants {\\r\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\r\\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\\r\\n}\\r\\n\\r\\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\\r\\n    /**\\r\\n     * @dev Should return whether the signature provided is valid for the provided data\\r\\n     * @param _dataHash Arbitrary length data signed on behalf of address(this)\\r\\n     * @param _signature Signature byte array associated with _data\\r\\n     *\\r\\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\\r\\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\\r\\n     * MUST allow external calls\\r\\n     */\\r\\n    function isValidSignature(\\r\\n        bytes32 _dataHash,\\r\\n        bytes memory _signature\\r\\n    ) public view virtual returns (bytes4);\\r\\n}\\r\\n\",\"keccak256\":\"0xec3122bd8aef8b72f764a3f55af5b730965bb48fb095aa2fb351324ceaef3b9c\",\"license\":\"LGPL-3.0-only\"},\"contracts/modules/BaseAuthorizationModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/* solhint-disable no-empty-blocks */\\r\\n\\r\\nimport {IAuthorizationModule} from \\\"../interfaces/IAuthorizationModule.sol\\\";\\r\\nimport {ISignatureValidator} from \\\"../interfaces/ISignatureValidator.sol\\\";\\r\\n\\r\\ncontract AuthorizationModulesConstants {\\r\\n    uint256 internal constant VALIDATION_SUCCESS = 0;\\r\\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\\r\\n}\\r\\n\\r\\nabstract contract BaseAuthorizationModule is\\r\\n    IAuthorizationModule,\\r\\n    ISignatureValidator,\\r\\n    AuthorizationModulesConstants\\r\\n{}\\r\\n\",\"keccak256\":\"0xb63cb5d39610a7be4a1a78f08aebbad67cdb4ac6bcf5361e687de689f087e939\",\"license\":\"MIT\"},\"contracts/modules/KeyManagementContractRegistryModule/KeyManagement.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.17;\\r\\n\\r\\nimport \\\"./interfaces/IAuthorizationModulesKMM.sol\\\";\\r\\n\\r\\nimport {SignatureRSV, EthereumUtils} from \\\"@oasisprotocol/sapphire-contracts/contracts/EthereumUtils.sol\\\";\\r\\nimport {UserOperation} from \\\"@account-abstraction/contracts/interfaces/UserOperation.sol\\\";\\r\\nimport {Sapphire} from \\\"@oasisprotocol/sapphire-contracts/contracts/Sapphire.sol\\\";\\r\\nimport {BaseAuthorizationModule} from \\\"../BaseAuthorizationModule.sol\\\";\\r\\nimport {ECDSA} from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\r\\n\\r\\ncontract KeyManagement is BaseAuthorizationModule {\\r\\n    using ECDSA for bytes32;\\r\\n\\r\\n    address internal constant SENTINEL_MODULES = address(0x1);\\r\\n\\r\\n    mapping(address => mapping(address => address)) public _modules;\\r\\n    mapping(address => address) internal publicAddress;\\r\\n    mapping(address => bytes32) private privateSecret;\\r\\n\\r\\n    error WrongValidationModule(address validationModule);\\r\\n\\r\\n    function initForSmartAccount() external returns (address) {\\r\\n        address keypairAddress;\\r\\n        bytes32 keypairSecret;\\r\\n        (keypairAddress, keypairSecret) = EthereumUtils.generateKeypair();\\r\\n        publicAddress[msg.sender] = keypairAddress;\\r\\n        privateSecret[msg.sender] = keypairSecret;\\r\\n        return address(this);\\r\\n    }\\r\\n\\r\\n    function _setupModule(\\r\\n        address setupContract,\\r\\n        bytes memory setupData\\r\\n    ) internal returns (address module) {\\r\\n        if (setupContract == address(0)) revert(\\\"Wrong Module Setup Address\\\");\\r\\n        assembly {\\r\\n            let success := call(\\r\\n                gas(),\\r\\n                setupContract,\\r\\n                0,\\r\\n                add(setupData, 0x20),\\r\\n                mload(setupData),\\r\\n                0,\\r\\n                0\\r\\n            )\\r\\n            let ptr := mload(0x40)\\r\\n            returndatacopy(ptr, 0, returndatasize())\\r\\n            if iszero(success) {\\r\\n                revert(ptr, returndatasize())\\r\\n            }\\r\\n            module := mload(ptr)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setupAndEnableModule(\\r\\n        address setupContract,\\r\\n        bytes memory setupData\\r\\n    ) external returns (address) {\\r\\n        address module = _setupModule(setupContract, setupData);\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner(bytes calldata data, address smartAccount) {\\r\\n        (bytes memory moduleData, address validationModule) = abi.decode(\\r\\n            data,\\r\\n            (bytes, address)\\r\\n        );\\r\\n        if (_modules[msg.sender][validationModule] != address(0)) {\\r\\n            require(\\r\\n                IAuthorizationModulesKMM(validationModule).validate(\\r\\n                    moduleData,\\r\\n                    smartAccount\\r\\n                ) == true,\\r\\n                \\\"Validate wrong\\\"\\r\\n            );\\r\\n        } else {\\r\\n            revert WrongValidationModule(validationModule);\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function sign(\\r\\n        bytes calldata authenticationData,\\r\\n        address smartAccount,\\r\\n        bytes32 digest\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        onlyOwner(authenticationData, smartAccount)\\r\\n        returns (SignatureRSV memory)\\r\\n    {\\r\\n        return\\r\\n            EthereumUtils.sign(\\r\\n                publicAddress[smartAccount],\\r\\n                privateSecret[smartAccount],\\r\\n                digest\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function validateUserOp(\\r\\n        UserOperation calldata userOp,\\r\\n        bytes32 userOpHash\\r\\n    ) external view virtual returns (uint256) {\\r\\n        (bytes memory cleanEcdsaSignature, ) = abi.decode(\\r\\n            userOp.signature,\\r\\n            (bytes, address)\\r\\n        );\\r\\n        if (_verifySignature(userOpHash, cleanEcdsaSignature, userOp.sender)) {\\r\\n            return VALIDATION_SUCCESS;\\r\\n        }\\r\\n        return SIG_VALIDATION_FAILED;\\r\\n    }\\r\\n\\r\\n    function isValidSignature(\\r\\n        bytes32 dataHash,\\r\\n        bytes memory moduleSignature\\r\\n    ) public view override returns (bytes4) {\\r\\n        return\\r\\n            isValidSignatureForAddress(dataHash, moduleSignature, msg.sender);\\r\\n    }\\r\\n\\r\\n    function isValidSignatureForAddress(\\r\\n        bytes32 dataHash,\\r\\n        bytes memory moduleSignature,\\r\\n        address smartAccount\\r\\n    ) public view virtual returns (bytes4) {\\r\\n        if (_verifySignature(dataHash, moduleSignature, smartAccount)) {\\r\\n            return EIP1271_MAGIC_VALUE;\\r\\n        }\\r\\n        return bytes4(0xffffffff);\\r\\n    }\\r\\n\\r\\n    function _verifySignature(\\r\\n        bytes32 dataHash,\\r\\n        bytes memory signature,\\r\\n        address smartAccount\\r\\n    ) internal view returns (bool) {\\r\\n        address keypairAddress = publicAddress[smartAccount];\\r\\n        address recovered = (dataHash.toEthSignedMessageHash()).recover(\\r\\n            signature\\r\\n        );\\r\\n        if (keypairAddress == recovered) {\\r\\n            return true;\\r\\n        }\\r\\n        recovered = dataHash.recover(signature);\\r\\n        if (keypairAddress == recovered) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n}\\r\\n\\r\\n// bool verify = Sapphire.verify(\\r\\n//     Sapphire.SigningAlg.Secp256k1PrehashedKeccak256,\\r\\n//     bytes(keypairAddress),\\r\\n//     dataHash,\\r\\n//     \\\"\\\",\\r\\n//     signature\\r\\n// );\\r\\n// return verify;\\r\\n\",\"keccak256\":\"0xc9a4f6f937a050450dcf6c777d125b1cd2a1e5d1d4181959b2083303eaed6194\",\"license\":\"MIT\"},\"contracts/modules/KeyManagementContractRegistryModule/interfaces/IAuthorizationModulesKMM.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n// interface for modules to verify singatures signed over userOpHash\\r\\ninterface IAuthorizationModulesKMM {\\r\\n    function validate(\\r\\n        bytes calldata data,\\r\\n        address smartAccount\\r\\n    ) external view returns (bool result);\\r\\n}\\r\\n\",\"keccak256\":\"0xc5f2106be15c653517e923136d0e7ba6c15204c5359689ad944f8086cf8d3129\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080806040523461001657611452908161001c8239f35b600080fdfe604060808152600436101561001357600080fd5b600090813560e01c9182630bfac3d4146100a557505080631626ba7e1461009c5780635305dd27146100935780635bef82e11461008a5780638a72968c14610081578063f44c339d146100785763fff35b7214610070575b600080fd5b61006b610570565b5061006b610524565b5061006b6104bc565b5061006b610426565b5061006b610366565b5061006b6102e9565b346101da57806003193601126101da576100bf60a0604052565b8060805280825160208101906020825284808201526100f2816100e4606082016108b1565b03601f198101835282610255565b51907301000000000000000000000000000000000000015afa610113610812565b90156101965761017961013761013161012b846105bd565b93610957565b506105e0565b336000908152600160205260409020906001600160a01b03167fffffffffffffffffffffffff0000000000000000000000000000000000000000825416179055565b3360009081526002602052604090205551308152602090f35b0390f35b815162461bcd60e51b815260206004820152601360248201527f72616e646f6d42797465733a206661696c6564000000000000000000000000006044820152606490fd5b80fd5b50634e487b7160e01b600052604160045260246000fd5b60e0810190811067ffffffffffffffff82111761021057604052565b6102186101dd565b604052565b6040810190811067ffffffffffffffff82111761021057604052565b6020810190811067ffffffffffffffff82111761021057604052565b90601f8019910116810190811067ffffffffffffffff82111761021057604052565b60209067ffffffffffffffff8111610295575b601f01601f19160190565b61029d6101dd565b61028a565b81601f8201121561006b578035906102b982610277565b926102c76040519485610255565b8284526020838301011161006b57816000926020809301838601378301015290565b503461006b57604036600319011261006b5760243567ffffffffffffffff811161006b5761032a61032060209236906004016102a2565b3390600435611149565b6040517fffffffff000000000000000000000000000000000000000000000000000000009091168152f35b6001600160a01b0381160361006b57565b503461006b57604036600319011261006b5760043561038481610355565b60243567ffffffffffffffff811161006b576103a49036906004016102a2565b906001600160a01b038116156103e157600082819282602083519301915af1604051903d6000833e156103dd5760405160008152602090f35b3d90fd5b60405162461bcd60e51b815260206004820152601a60248201527f57726f6e67204d6f64756c6520536574757020416464726573730000000000006044820152606490fd5b503461006b57606036600319011261006b5760043567ffffffffffffffff80821161006b573660238301121561006b57816004013590811161006b57366024828401011161006b5761019291610498916024359061048382610355565b61048b610a49565b5060246044359301610b56565b60408051825181526020808401519082015291810151908201529081906060820190565b503461006b57604036600319011261006b5760206004356104dc81610355565b61051a6024356104eb81610355565b6001600160a01b03809316600052600084526040600020906001600160a01b0316600052602052604060002090565b5416604051908152f35b503461006b57606036600319011261006b5760243567ffffffffffffffff811161006b5761032a61055b60209236906004016102a2565b6044359061056882610355565b600435611149565b503461006b5760031960403682011261006b576004359067ffffffffffffffff821161006b5761016090823603011261006b576105b5602091602435906004016110e1565b604051908152f35b6020815191015190602081106105d1575090565b6000199060200360031b1b1690565b60218151036106f5576105f7602182015191610707565b5160f81c60006002821415806106ea575b6106d8578060405160208101906020825260206040820152602060608201526401000003d01980600781808a80098a090860808301527f3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff0c60a083015260c082015260c08152610676816101f4565b519060055afa91610685610812565b92156106c6576106aa6106a461069d6106b3956105bd565b93846107d4565b60011690565b6106b657610842565b90565b906106c0906107e1565b90610842565b60405163102875ed60e01b8152600490fd5b60405163ab4be04160e01b8152600490fd5b506003821415610608565b604051636446a2c560e11b8152600490fd5b8051156107145760200190565b634e487b7160e01b600052603260045260246000fd5b8051600210156107145760220190565b8051600110156107145760210190565b8051600310156107145760230190565b8051600410156107145760240190565b908151811015610714570160200190565b50634e487b7160e01b600052601160045260246000fd5b60040190816004116107a057565b6107a861077b565b565b90600182018092116107a057565b90600482018092116107a057565b90600282018092116107a057565b919082018092116107a057565b6401000003d019908103919082116107a057565b6000198101919082116107a057565b60200390602082116107a057565b3d1561083d573d9061082382610277565b916108316040519384610255565b82523d6000602084013e565b606090565b6001600160a01b039160405190602082019283526040820152604081526060810181811067ffffffffffffffff821117610881575b6040525190201690565b6108896101dd565b610877565b60005b8381106108a15750506000910152565b8181015183820152602001610891565b906080519182815260005b8381106108dc5750826000602080949584010152601f8019910116010190565b8060209160a00151828285010152016108bc565b906020916109098151809281855285808601910161088e565b601f01601f1916010190565b81601f8201121561006b57805161092b81610277565b926109396040519485610255565b8184526020828401011161006b576106b3916020808501910161088e565b90604090815160209061097e816100e48482019760048952878084015260608301906108f0565b60008095819251907301000000000000000000000000000000000000055afa906109a6610812565b9115610a065781518201918481838501940312610a0257818101519067ffffffffffffffff918281116109fe5784846109e192840101610915565b958101519182116109fa576106b3949596500101610915565b8680fd5b8780fd5b8580fd5b60649084519062461bcd60e51b82526004820152601b60248201527f67656e207369676e696e67206b6579706169723a206661696c656400000000006044820152fd5b604051906060820182811067ffffffffffffffff821117610a7a575b60405260006040838281528260208201520152565b610a826101dd565b610a65565b919060408382031261006b57823567ffffffffffffffff811161006b57602091610ab29185016102a2565b9201356106b381610355565b9081602091031261006b5751801515810361006b5790565b906001600160a01b03610af66020929594956040855260408501906108f0565b9416910152565b506040513d6000823e3d90fd5b15610b1157565b60405162461bcd60e51b815260206004820152600e60248201527f56616c69646174652077726f6e670000000000000000000000000000000000006044820152606490fd5b610b669194939294810190610a87565b93906001600160a01b0380951694610bbd610bb087610b98336001600160a01b03166000526000602052604060002090565b906001600160a01b0316600052602052604060002090565b546001600160a01b031690565b1615610c4d576001610bf06020846106b39798610c0d95604051809581948293634948a22560e01b845260048401610ad6565b03915afa908115610c40575b600091610c12575b50151514610b0a565b610c6e565b610c33915060203d8111610c39575b610c2b8183610255565b810190610abe565b38610c04565b503d610c21565b610c48610afd565b610bfc565b6040516326cc3fab60e21b81526001600160a01b0386166004820152602490fd5b6001600160a01b0380600092168252602060018152604091828420541692600282528083610d02610d3182842054610ca4610a49565b5083519087820152868152610cb88161021d565b8351908a88830152878252610ccc8261021d565b610d258551610cda81610239565b878152610d15875196879460808d87019a610cf58c60049052565b87015260a08601906108f0565b601f1995868683030160608701526108f0565b90848483030160808501526108f0565b03908101835282610255565b51907301000000000000000000000000000000000000065afa91610d53610812565b9215610d7057505090610d686106b392610de3565b928391610fe5565b60649250519062461bcd60e51b82526004820152600c60248201527f7369676e3a206661696c656400000000000000000000000000000000000000006044820152fd5b908160031b917f1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8116036107a057565b90610dec610a49565b916008815110610f9e576001600160f81b0319600360fc1b81610e1f610e1185610707565b516001600160f81b03191690565b1603610f9e57600160f91b8082610e38610e118661072a565b1603610f9e57610e5c610e56610e50610e118661073a565b60f81c90565b60ff1690565b91610e6f610e56610e50610e118761074a565b9260218411610f9e57610e8184610792565b90610e9d610e56610e50610e11610e97866107aa565b8a61076a565b9360218511610f9e57610ec3610eb6610e11858a61076a565b6001600160f81b03191690565b03610f9e5780610edb610ed686886107d4565b6107b8565b03610f9e57610eeb8651916107c6565b03610f9e57610ef9906107c6565b9060049060218514610fb0575b60218414610f6b575b50906020809286010151940101519160208110610f54575b5060208110610f3c575b509083526020830152565b610f48610f4d91610804565b610db3565b1c38610f31565b610f48610f6391949294610804565b1c9138610f27565b610f7b610e11848896949661076a565b16610f9e576020610f95610f8f82946107aa565b926107f5565b93919250610f0f565b6040516386cd05c560e01b8152600490fd5b939084610fbf610e118861075a565b16610fd65750610fd06005916107f5565b93610f06565b6040516386cd05c560e01b8152fd5b9160408101601b815281519160208101602061101f825160405196888860609194939260808201958252601b602083015260408201520152565b856000968792838052039060015afa156110d4575b83516001600160a01b038097169687911603611053575b505050505050565b6110a5946110898593601c602096525192516040519384938460609194939260808201958252601c602083015260408201520152565b838052039060015afa156110c7575b516001600160a01b031690565b036110b55738808080808061104b565b604051634532600d60e01b8152600490fd5b6110cf610afd565b611098565b6110dc610afd565b611034565b90610140820135601e198336030181121561006b57820191823567ffffffffffffffff811161006b5760208401813603811361006b5760206111299261113b96010190610a87565b5090359161113683610355565b611187565b61114457600190565b600090565b906111549291611187565b61117c577fffffffff0000000000000000000000000000000000000000000000000000000090565b630b135d3f60e11b90565b91906001600160a01b0380921660005260016020528160406000205416927f19457468657265756d205369676e6564204d6573736167653a0a33320000000060005280601c52826111e76111df84603c600020611354565b919091611234565b16841461120b576111fb916111df91611354565b161461120657600090565b600190565b50505050600190565b6005111561121e57565b634e487b7160e01b600052602160045260246000fd5b61123d81611214565b806112455750565b61124e81611214565b6001810361129b5760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e617475726500000000000000006044820152606490fd5b6112a481611214565b600281036112f15760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e677468006044820152606490fd5b806112fd600392611214565b1461130457565b60405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b6064820152608490fd5b9060418151146000146113825761137e916020820151906060604084015193015160001a9061138c565b9091565b5050600090600290565b9291907f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083116114105791608094939160ff602094604051948552168484015260408301526060820152600093849182805260015afa15611403575b81516001600160a01b038116156113fd579190565b50600190565b61140b610afd565b6113e8565b5050505060009060039056fea264697066735822122043eaba019da380bc53ef2f94bce8c8e2451c21e78301708c65d8e84d1ffbc4c564736f6c63430008110033",
  "deployedBytecode": "0x604060808152600436101561001357600080fd5b600090813560e01c9182630bfac3d4146100a557505080631626ba7e1461009c5780635305dd27146100935780635bef82e11461008a5780638a72968c14610081578063f44c339d146100785763fff35b7214610070575b600080fd5b61006b610570565b5061006b610524565b5061006b6104bc565b5061006b610426565b5061006b610366565b5061006b6102e9565b346101da57806003193601126101da576100bf60a0604052565b8060805280825160208101906020825284808201526100f2816100e4606082016108b1565b03601f198101835282610255565b51907301000000000000000000000000000000000000015afa610113610812565b90156101965761017961013761013161012b846105bd565b93610957565b506105e0565b336000908152600160205260409020906001600160a01b03167fffffffffffffffffffffffff0000000000000000000000000000000000000000825416179055565b3360009081526002602052604090205551308152602090f35b0390f35b815162461bcd60e51b815260206004820152601360248201527f72616e646f6d42797465733a206661696c6564000000000000000000000000006044820152606490fd5b80fd5b50634e487b7160e01b600052604160045260246000fd5b60e0810190811067ffffffffffffffff82111761021057604052565b6102186101dd565b604052565b6040810190811067ffffffffffffffff82111761021057604052565b6020810190811067ffffffffffffffff82111761021057604052565b90601f8019910116810190811067ffffffffffffffff82111761021057604052565b60209067ffffffffffffffff8111610295575b601f01601f19160190565b61029d6101dd565b61028a565b81601f8201121561006b578035906102b982610277565b926102c76040519485610255565b8284526020838301011161006b57816000926020809301838601378301015290565b503461006b57604036600319011261006b5760243567ffffffffffffffff811161006b5761032a61032060209236906004016102a2565b3390600435611149565b6040517fffffffff000000000000000000000000000000000000000000000000000000009091168152f35b6001600160a01b0381160361006b57565b503461006b57604036600319011261006b5760043561038481610355565b60243567ffffffffffffffff811161006b576103a49036906004016102a2565b906001600160a01b038116156103e157600082819282602083519301915af1604051903d6000833e156103dd5760405160008152602090f35b3d90fd5b60405162461bcd60e51b815260206004820152601a60248201527f57726f6e67204d6f64756c6520536574757020416464726573730000000000006044820152606490fd5b503461006b57606036600319011261006b5760043567ffffffffffffffff80821161006b573660238301121561006b57816004013590811161006b57366024828401011161006b5761019291610498916024359061048382610355565b61048b610a49565b5060246044359301610b56565b60408051825181526020808401519082015291810151908201529081906060820190565b503461006b57604036600319011261006b5760206004356104dc81610355565b61051a6024356104eb81610355565b6001600160a01b03809316600052600084526040600020906001600160a01b0316600052602052604060002090565b5416604051908152f35b503461006b57606036600319011261006b5760243567ffffffffffffffff811161006b5761032a61055b60209236906004016102a2565b6044359061056882610355565b600435611149565b503461006b5760031960403682011261006b576004359067ffffffffffffffff821161006b5761016090823603011261006b576105b5602091602435906004016110e1565b604051908152f35b6020815191015190602081106105d1575090565b6000199060200360031b1b1690565b60218151036106f5576105f7602182015191610707565b5160f81c60006002821415806106ea575b6106d8578060405160208101906020825260206040820152602060608201526401000003d01980600781808a80098a090860808301527f3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff0c60a083015260c082015260c08152610676816101f4565b519060055afa91610685610812565b92156106c6576106aa6106a461069d6106b3956105bd565b93846107d4565b60011690565b6106b657610842565b90565b906106c0906107e1565b90610842565b60405163102875ed60e01b8152600490fd5b60405163ab4be04160e01b8152600490fd5b506003821415610608565b604051636446a2c560e11b8152600490fd5b8051156107145760200190565b634e487b7160e01b600052603260045260246000fd5b8051600210156107145760220190565b8051600110156107145760210190565b8051600310156107145760230190565b8051600410156107145760240190565b908151811015610714570160200190565b50634e487b7160e01b600052601160045260246000fd5b60040190816004116107a057565b6107a861077b565b565b90600182018092116107a057565b90600482018092116107a057565b90600282018092116107a057565b919082018092116107a057565b6401000003d019908103919082116107a057565b6000198101919082116107a057565b60200390602082116107a057565b3d1561083d573d9061082382610277565b916108316040519384610255565b82523d6000602084013e565b606090565b6001600160a01b039160405190602082019283526040820152604081526060810181811067ffffffffffffffff821117610881575b6040525190201690565b6108896101dd565b610877565b60005b8381106108a15750506000910152565b8181015183820152602001610891565b906080519182815260005b8381106108dc5750826000602080949584010152601f8019910116010190565b8060209160a00151828285010152016108bc565b906020916109098151809281855285808601910161088e565b601f01601f1916010190565b81601f8201121561006b57805161092b81610277565b926109396040519485610255565b8184526020828401011161006b576106b3916020808501910161088e565b90604090815160209061097e816100e48482019760048952878084015260608301906108f0565b60008095819251907301000000000000000000000000000000000000055afa906109a6610812565b9115610a065781518201918481838501940312610a0257818101519067ffffffffffffffff918281116109fe5784846109e192840101610915565b958101519182116109fa576106b3949596500101610915565b8680fd5b8780fd5b8580fd5b60649084519062461bcd60e51b82526004820152601b60248201527f67656e207369676e696e67206b6579706169723a206661696c656400000000006044820152fd5b604051906060820182811067ffffffffffffffff821117610a7a575b60405260006040838281528260208201520152565b610a826101dd565b610a65565b919060408382031261006b57823567ffffffffffffffff811161006b57602091610ab29185016102a2565b9201356106b381610355565b9081602091031261006b5751801515810361006b5790565b906001600160a01b03610af66020929594956040855260408501906108f0565b9416910152565b506040513d6000823e3d90fd5b15610b1157565b60405162461bcd60e51b815260206004820152600e60248201527f56616c69646174652077726f6e670000000000000000000000000000000000006044820152606490fd5b610b669194939294810190610a87565b93906001600160a01b0380951694610bbd610bb087610b98336001600160a01b03166000526000602052604060002090565b906001600160a01b0316600052602052604060002090565b546001600160a01b031690565b1615610c4d576001610bf06020846106b39798610c0d95604051809581948293634948a22560e01b845260048401610ad6565b03915afa908115610c40575b600091610c12575b50151514610b0a565b610c6e565b610c33915060203d8111610c39575b610c2b8183610255565b810190610abe565b38610c04565b503d610c21565b610c48610afd565b610bfc565b6040516326cc3fab60e21b81526001600160a01b0386166004820152602490fd5b6001600160a01b0380600092168252602060018152604091828420541692600282528083610d02610d3182842054610ca4610a49565b5083519087820152868152610cb88161021d565b8351908a88830152878252610ccc8261021d565b610d258551610cda81610239565b878152610d15875196879460808d87019a610cf58c60049052565b87015260a08601906108f0565b601f1995868683030160608701526108f0565b90848483030160808501526108f0565b03908101835282610255565b51907301000000000000000000000000000000000000065afa91610d53610812565b9215610d7057505090610d686106b392610de3565b928391610fe5565b60649250519062461bcd60e51b82526004820152600c60248201527f7369676e3a206661696c656400000000000000000000000000000000000000006044820152fd5b908160031b917f1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8116036107a057565b90610dec610a49565b916008815110610f9e576001600160f81b0319600360fc1b81610e1f610e1185610707565b516001600160f81b03191690565b1603610f9e57600160f91b8082610e38610e118661072a565b1603610f9e57610e5c610e56610e50610e118661073a565b60f81c90565b60ff1690565b91610e6f610e56610e50610e118761074a565b9260218411610f9e57610e8184610792565b90610e9d610e56610e50610e11610e97866107aa565b8a61076a565b9360218511610f9e57610ec3610eb6610e11858a61076a565b6001600160f81b03191690565b03610f9e5780610edb610ed686886107d4565b6107b8565b03610f9e57610eeb8651916107c6565b03610f9e57610ef9906107c6565b9060049060218514610fb0575b60218414610f6b575b50906020809286010151940101519160208110610f54575b5060208110610f3c575b509083526020830152565b610f48610f4d91610804565b610db3565b1c38610f31565b610f48610f6391949294610804565b1c9138610f27565b610f7b610e11848896949661076a565b16610f9e576020610f95610f8f82946107aa565b926107f5565b93919250610f0f565b6040516386cd05c560e01b8152600490fd5b939084610fbf610e118861075a565b16610fd65750610fd06005916107f5565b93610f06565b6040516386cd05c560e01b8152fd5b9160408101601b815281519160208101602061101f825160405196888860609194939260808201958252601b602083015260408201520152565b856000968792838052039060015afa156110d4575b83516001600160a01b038097169687911603611053575b505050505050565b6110a5946110898593601c602096525192516040519384938460609194939260808201958252601c602083015260408201520152565b838052039060015afa156110c7575b516001600160a01b031690565b036110b55738808080808061104b565b604051634532600d60e01b8152600490fd5b6110cf610afd565b611098565b6110dc610afd565b611034565b90610140820135601e198336030181121561006b57820191823567ffffffffffffffff811161006b5760208401813603811361006b5760206111299261113b96010190610a87565b5090359161113683610355565b611187565b61114457600190565b600090565b906111549291611187565b61117c577fffffffff0000000000000000000000000000000000000000000000000000000090565b630b135d3f60e11b90565b91906001600160a01b0380921660005260016020528160406000205416927f19457468657265756d205369676e6564204d6573736167653a0a33320000000060005280601c52826111e76111df84603c600020611354565b919091611234565b16841461120b576111fb916111df91611354565b161461120657600090565b600190565b50505050600190565b6005111561121e57565b634e487b7160e01b600052602160045260246000fd5b61123d81611214565b806112455750565b61124e81611214565b6001810361129b5760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e617475726500000000000000006044820152606490fd5b6112a481611214565b600281036112f15760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e677468006044820152606490fd5b806112fd600392611214565b1461130457565b60405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b6064820152608490fd5b9060418151146000146113825761137e916020820151906060604084015193015160001a9061138c565b9091565b5050600090600290565b9291907f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083116114105791608094939160ff602094604051948552168484015260408301526060820152600093849182805260015afa15611403575b81516001600160a01b038116156113fd579190565b50600190565b61140b610afd565b6113e8565b5050505060009060039056fea264697066735822122043eaba019da380bc53ef2f94bce8c8e2451c21e78301708c65d8e84d1ffbc4c564736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3241,
        "contract": "contracts/modules/KeyManagementContractRegistryModule/KeyManagement.sol:KeyManagement",
        "label": "_modules",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_mapping(t_address,t_address))"
      },
      {
        "astId": 3245,
        "contract": "contracts/modules/KeyManagementContractRegistryModule/KeyManagement.sol:KeyManagement",
        "label": "publicAddress",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_address)"
      },
      {
        "astId": 3249,
        "contract": "contracts/modules/KeyManagementContractRegistryModule/KeyManagement.sol:KeyManagement",
        "label": "privateSecret",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_bytes32)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_address,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_address,t_mapping(t_address,t_address))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => address))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_address)"
      }
    }
  }
}