{
  "address": "0xa513E6E4b8f2a923D98304ec87F64353C4D5C853",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IEntryPoint",
          "name": "anEntryPoint",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BaseImplementationCannotBeZero",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "CallerIsNotAnEntryPoint",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "CallerIsNotEntryPoint",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "CallerIsNotEntryPointOrOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "CallerIsNotEntryPointOrSelf",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "CallerIsNotOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "CallerIsNotSelf",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DelegateCallsOnly",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "EntryPointCannotBeZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "HandlerCannotBeZero",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "implementationAddress",
          "type": "address"
        }
      ],
      "name": "InvalidImplementation",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "MixedAuthFail",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "module",
          "type": "address"
        }
      ],
      "name": "ModuleAlreadyEnabled",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "expectedModule",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "returnedModule",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "prevModule",
          "type": "address"
        }
      ],
      "name": "ModuleAndPrevModuleMismatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "module",
          "type": "address"
        }
      ],
      "name": "ModuleCannotBeZeroOrSentinel",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "module",
          "type": "address"
        }
      ],
      "name": "ModuleNotEnabled",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ModulesAlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ModulesSetupExecutionFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OwnerCanNotBeSelf",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OwnerCannotBeZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OwnerProvidedIsSame",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TransferToZeroAddressAttempt",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "destLength",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "valueLength",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "funcLength",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "operationLength",
          "type": "uint256"
        }
      ],
      "name": "WrongBatchProvided",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "contractSignature",
          "type": "bytes"
        }
      ],
      "name": "WrongContractSignature",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "uintS",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "contractSignatureLength",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "signatureLength",
          "type": "uint256"
        }
      ],
      "name": "WrongContractSignatureFormat",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "moduleAddressProvided",
          "type": "address"
        }
      ],
      "name": "WrongValidationModule",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousHandler",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "handler",
          "type": "address"
        }
      ],
      "name": "ChangedFallbackHandler",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "module",
          "type": "address"
        }
      ],
      "name": "DisabledModule",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "module",
          "type": "address"
        }
      ],
      "name": "EnabledModule",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "enum Enum.Operation",
          "name": "operation",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "txGas",
          "type": "uint256"
        }
      ],
      "name": "ExecutionFailure",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "module",
          "type": "address"
        }
      ],
      "name": "ExecutionFromModuleFailure",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "module",
          "type": "address"
        }
      ],
      "name": "ExecutionFromModuleSuccess",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "enum Enum.Operation",
          "name": "operation",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "txGas",
          "type": "uint256"
        }
      ],
      "name": "ExecutionSuccess",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "oldImplementation",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "ImplementationUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "module",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "enum Enum.Operation",
          "name": "operation",
          "type": "uint8"
        }
      ],
      "name": "ModuleTransaction",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "SmartAccountReceivedNativeToken",
      "type": "event"
    },
    {
      "stateMutability": "nonpayable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "addDeposit",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "prevModule",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "module",
          "type": "address"
        }
      ],
      "name": "disableModule",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "module",
          "type": "address"
        }
      ],
      "name": "enableModule",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "entryPoint",
      "outputs": [
        {
          "internalType": "contract IEntryPoint",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "to",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "value",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        },
        {
          "internalType": "enum Enum.Operation[]",
          "name": "operations",
          "type": "uint8[]"
        }
      ],
      "name": "execBatchTransactionFromModule",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "enum Enum.Operation",
          "name": "operation",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "txGas",
          "type": "uint256"
        }
      ],
      "name": "execTransactionFromModule",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "enum Enum.Operation",
          "name": "operation",
          "type": "uint8"
        }
      ],
      "name": "execTransactionFromModule",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "enum Enum.Operation",
          "name": "operation",
          "type": "uint8"
        }
      ],
      "name": "execTransactionFromModuleReturnData",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "returnData",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "dest",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "func",
          "type": "bytes"
        }
      ],
      "name": "execute",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "dest",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "value",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes[]",
          "name": "func",
          "type": "bytes[]"
        }
      ],
      "name": "executeBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "dest",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "value",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes[]",
          "name": "func",
          "type": "bytes[]"
        }
      ],
      "name": "executeBatch_y6U",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "dest",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "func",
          "type": "bytes"
        }
      ],
      "name": "execute_ncC",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDeposit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getFallbackHandler",
      "outputs": [
        {
          "internalType": "address",
          "name": "_handler",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "_implementation",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "start",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "pageSize",
          "type": "uint256"
        }
      ],
      "name": "getModulesPaginated",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "array",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "next",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "handler",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "sessionKeyModuleContract",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "authModuleSetupContract",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "authModuleSetupData",
          "type": "bytes"
        }
      ],
      "name": "init",
      "outputs": [
        {
          "internalType": "address",
          "name": "authAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "module",
          "type": "address"
        }
      ],
      "name": "isModuleEnabled",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "dataHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "isValidSignature",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint192",
          "name": "_key",
          "type": "uint192"
        }
      ],
      "name": "nonce",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "noncesDeprecated",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ownerDeprecated",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "handler",
          "type": "address"
        }
      ],
      "name": "setFallbackHandler",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "setupContract",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "setupData",
          "type": "bytes"
        }
      ],
      "name": "setupAndEnableModule",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "_interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_implementation",
          "type": "address"
        }
      ],
      "name": "updateImplementation",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "initCode",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            },
            {
              "internalType": "uint256",
              "name": "callGasLimit",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "verificationGasLimit",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxFeePerGas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxPriorityFeePerGas",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "paymasterAndData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct UserOperation",
          "name": "userOp",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "userOpHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "missingAccountFunds",
          "type": "uint256"
        }
      ],
      "name": "validateUserOp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "validationData",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "withdrawAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawDepositTo",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x134eb8b45cf1cb2603264824d81f9708c3916d303fc7b9dd66b10c6ffe35a0d4",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xa513E6E4b8f2a923D98304ec87F64353C4D5C853",
    "transactionIndex": 0,
    "gasUsed": "1866606",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x89515a580433f049161d0e950550431c5439710437739feeea9257a7f54bceda",
    "transactionHash": "0x134eb8b45cf1cb2603264824d81f9708c3916d303fc7b9dd66b10c6ffe35a0d4",
    "logs": [],
    "blockNumber": 154,
    "cumulativeGasUsed": "1866606",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x5FC8d32690cc91D4c39d9d3abcBD16989F875707"
  ],
  "numDeployments": 1,
  "solcInputHash": "66929e62e058f56fd12897526c075a13",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IEntryPoint\",\"name\":\"anEntryPoint\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseImplementationCannotBeZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotAnEntryPoint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotEntryPoint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotEntryPointOrOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotEntryPointOrSelf\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotSelf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DelegateCallsOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EntryPointCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HandlerCannotBeZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementationAddress\",\"type\":\"address\"}],\"name\":\"InvalidImplementation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"MixedAuthFail\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ModuleAlreadyEnabled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"expectedModule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"returnedModule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"prevModule\",\"type\":\"address\"}],\"name\":\"ModuleAndPrevModuleMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ModuleCannotBeZeroOrSentinel\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ModuleNotEnabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ModulesAlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ModulesSetupExecutionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerCanNotBeSelf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerProvidedIsSame\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddressAttempt\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"destLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"funcLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operationLength\",\"type\":\"uint256\"}],\"name\":\"WrongBatchProvided\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"contractSignature\",\"type\":\"bytes\"}],\"name\":\"WrongContractSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uintS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractSignatureLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"signatureLength\",\"type\":\"uint256\"}],\"name\":\"WrongContractSignatureFormat\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"moduleAddressProvided\",\"type\":\"address\"}],\"name\":\"WrongValidationModule\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousHandler\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"}],\"name\":\"ChangedFallbackHandler\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"DisabledModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"EnabledModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"txGas\",\"type\":\"uint256\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ExecutionFromModuleFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ExecutionFromModuleSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"txGas\",\"type\":\"uint256\"}],\"name\":\"ExecutionSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"ImplementationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"ModuleTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SmartAccountReceivedNativeToken\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"prevModule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"disableModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"enableModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryPoint\",\"outputs\":[{\"internalType\":\"contract IEntryPoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"value\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"},{\"internalType\":\"enum Enum.Operation[]\",\"name\":\"operations\",\"type\":\"uint8[]\"}],\"name\":\"execBatchTransactionFromModule\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"txGas\",\"type\":\"uint256\"}],\"name\":\"execTransactionFromModule\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"execTransactionFromModule\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"execTransactionFromModuleReturnData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"func\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"dest\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"value\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"func\",\"type\":\"bytes[]\"}],\"name\":\"executeBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"dest\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"value\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"func\",\"type\":\"bytes[]\"}],\"name\":\"executeBatch_y6U\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"func\",\"type\":\"bytes\"}],\"name\":\"execute_ncC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFallbackHandler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_handler\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"start\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getModulesPaginated\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"array\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"next\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sessionKeyModuleContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"authModuleSetupContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"authModuleSetupData\",\"type\":\"bytes\"}],\"name\":\"init\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"authAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"isModuleEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint192\",\"name\":\"_key\",\"type\":\"uint192\"}],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"noncesDeprecated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerDeprecated\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"}],\"name\":\"setFallbackHandler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"setupContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"setupData\",\"type\":\"bytes\"}],\"name\":\"setupAndEnableModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"updateImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"missingAccountFunds\",\"type\":\"uint256\"}],\"name\":\"validateUserOp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"validationData\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"withdrawAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDepositTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"author\":\"Chirag Titiya - <chirag@biconomy.io>, Filipp Makarov - <filipp.makarov@biconomy.io>\",\"details\":\"This contract is the base for the Smart Account functionality.         - It is modular by nature. UserOp and txns validation happens in Authorization Modules.         - It provides the functionality to execute AA (EIP-4337) userOps. Gnosis style txns removed to a module.         - It allows to receive and manage assets.         - It is responsible for managing the modules and fallbacks.         - The Smart Account can be extended with modules, such as Social Recovery, Session Key and others.\",\"errors\":{\"CallerIsNotAnEntryPoint(address)\":[{\"params\":{\"caller\":\"address that tried to call onlyEntryPoint-protected method\"}}],\"CallerIsNotEntryPoint(address)\":[{\"params\":{\"caller\":\"address that tried to call _requireFromEntryPoint-protected method\"}}],\"CallerIsNotEntryPointOrOwner(address)\":[{\"params\":{\"caller\":\"address that tried to call _requireFromEntryPointOrOwner-protected method\"}}],\"CallerIsNotEntryPointOrSelf(address)\":[{\"params\":{\"caller\":\"address that tried to call _requireFromEntryPointOrSelf-protected method\"}}],\"CallerIsNotOwner(address)\":[{\"params\":{\"caller\":\"address that tried to call onlyOwner method\"}}],\"CallerIsNotSelf(address)\":[{\"params\":{\"caller\":\"Caller address\"}}],\"InvalidImplementation(address)\":[{\"params\":{\"implementationAddress\":\"implementation address provided\"}}],\"MixedAuthFail(address)\":[{\"params\":{\"caller\":\"address that tried to call mixedAuth-protected method\"}}],\"ModuleAlreadyEnabled(address)\":[{\"params\":{\"module\":\"Module address provided\"}}],\"ModuleAndPrevModuleMismatch(address,address,address)\":[{\"params\":{\"expectedModule\":\"expected module at modules[prevModule]\",\"prevModule\":\"previous module address provided at call\",\"returnedModule\":\"the module that has been found at modules[prevModule]\"}}],\"ModuleCannotBeZeroOrSentinel(address)\":[{\"params\":{\"module\":\"Module address provided\"}}],\"ModuleNotEnabled(address)\":[{\"params\":{\"module\":\"Module address provided\"}}],\"WrongBatchProvided(uint256,uint256,uint256,uint256)\":[{\"params\":{\"destLength\":\"length of destination contracts array\",\"funcLength\":\"length of function signatures array\",\"operationLength\":\"length of operation types array. 0 if there's no operations\",\"valueLength\":\"length of txn values array\"}}],\"WrongContractSignature(bytes)\":[{\"params\":{\"contractSignature\":\"the contract signature that has been verified\"}}],\"WrongContractSignatureFormat(uint256,uint256,uint256)\":[{\"params\":{\"contractSignatureLength\":\"length of a contract signature\",\"signatureLength\":\"the whole signature length\",\"uintS\":\"s converted to uint256\"}}],\"WrongValidationModule(address)\":[{\"params\":{\"moduleAddressProvided\":\"module address taken from signature\"}}]},\"kind\":\"dev\",\"methods\":{\"addDeposit()\":{\"details\":\"Deposit more funds for this account in the entryPoint\"},\"constructor\":{\"details\":\"Constructor that sets the entry point contract.      _modules[SENTINEL_MODULES] = SENTINEL_MODULES protects implementation from initialization\",\"params\":{\"anEntryPoint\":\"The address of the entry point contract.\"}},\"disableModule(address,address)\":{\"details\":\"Removes a module from the allowlist.\",\"params\":{\"module\":\"Module to be removed.\",\"prevModule\":\"Module that pointed to the module to be removed in the linked list\"}},\"enableModule(address)\":{\"details\":\"Adds a module to the allowlist.\",\"params\":{\"module\":\"Module to be allow-listed.\"}},\"entryPoint()\":{\"details\":\"Returns the current entry point used by this account.This function should be implemented by the subclass to return the current entry point used by this account.\",\"returns\":{\"_0\":\"EntryPoint as an `IEntryPoint` interface.\"}},\"execBatchTransactionFromModule(address[],uint256[],bytes[],uint8[])\":{\"details\":\"Allows a Module to execute a batch of Smart Account transactions without any further confirmations.\",\"params\":{\"data\":\"Data payload of module transaction.\",\"operations\":\"Operation type of module transaction.\",\"to\":\"Destination address of module transaction.\",\"value\":\"Ether value of module transaction.\"}},\"execTransactionFromModule(address,uint256,bytes,uint8,uint256)\":{\"details\":\"Allows a Module to execute a Smart Account transaction without any further confirmations.\",\"params\":{\"data\":\"Data payload of module transaction.\",\"operation\":\"Operation type of module transaction.\",\"to\":\"Destination address of module transaction.\",\"value\":\"Ether value of module transaction.\"}},\"execTransactionFromModuleReturnData(address,uint256,bytes,uint8)\":{\"details\":\"Allows a Module to execute a wallet transaction without any further confirmations and returns data\",\"params\":{\"data\":\"Data payload of module transaction.\",\"operation\":\"Operation type of module transaction.\",\"to\":\"Destination address of module transaction.\",\"value\":\"Ether value of module transaction.\"}},\"execute(address,uint256,bytes)\":{\"details\":\"Interface function with the standard name for execute_ncC\",\"params\":{\"dest\":\"Address of the contract to call\",\"func\":\"Data of the transaction\",\"value\":\"Amount of native tokens to send along with the transaction\"}},\"executeBatch(address[],uint256[],bytes[])\":{\"details\":\"Interface function with the standard name for executeBatch_y6U\",\"params\":{\"dest\":\"Addresses of the contracts to call\",\"func\":\"Data of the transactions\",\"value\":\"Amounts of native tokens to send along with the transactions\"}},\"executeBatch_y6U(address[],uint256[],bytes[])\":{\"details\":\"Execute a sequence of transactions\",\"params\":{\"dest\":\"Addresses of the contracts to call\",\"func\":\"Data of the transactions\",\"value\":\"Amounts of native tokens to send along with the transactions\"}},\"execute_ncC(address,uint256,bytes)\":{\"details\":\"Execute a transaction (called by entryPoint)\",\"params\":{\"dest\":\"Address of the contract to call\",\"func\":\"Data of the transaction\",\"value\":\"Amount of native tokens to send along with the transaction\"}},\"getDeposit()\":{\"details\":\"Check current account deposit in the entryPoint\"},\"getImplementation()\":{\"details\":\"Returns the address of the implementation contract associated with this contract.\"},\"getModulesPaginated(address,uint256)\":{\"details\":\"Returns array of modules. Useful for a widget\",\"params\":{\"pageSize\":\"Maximum number of modules that should be returned.\",\"start\":\"Start of the page.\"},\"returns\":{\"array\":\"Array of modules.\",\"next\":\"Start of the next page.\"}},\"init(address,address,address,bytes)\":{\"details\":\"Initialize the Smart Account with required states\",\"params\":{\"authModuleSetupContract\":\"Contract, that setups initial auth module for this smart account. It can be a module factory or a registry module that serves several smart accounts\",\"authModuleSetupData\":\"modules setup data (a standard calldata for the module setup contract)\",\"handler\":\"Default fallback handler provided in Smart Account\",\"sessionKeyModuleContract\":\"Contract, that enables session key module\"}},\"isModuleEnabled(address)\":{\"details\":\"Returns if a module is enabled\",\"returns\":{\"_0\":\"True if the module is enabled\"}},\"isValidSignature(bytes32,bytes)\":{\"details\":\"Forwards the validation to the module specified in the signature\",\"params\":{\"dataHash\":\"32 bytes hash of the data signed on the behalf of address(msg.sender)\",\"signature\":\"Signature byte array associated with dataHash\"},\"returns\":{\"_0\":\"bytes4 value.\"}},\"nonce(uint192)\":{\"details\":\"This method returns the next sequential nonce.\",\"returns\":{\"_0\":\"nonce the account nonce.\"}},\"setFallbackHandler(address)\":{\"details\":\"Sets the fallback handler.\",\"params\":{\"handler\":\"Handler to be set.\"}},\"setupAndEnableModule(address,bytes)\":{\"details\":\"Setups module for this Smart Account and enables it.\"},\"supportsInterface(bytes4)\":{\"params\":{\"_interfaceId\":\"The interface identifier, as specified in ERC165\"},\"returns\":{\"_0\":\"`true` if the contract implements `_interfaceID`\"}},\"updateImplementation(address)\":{\"params\":{\"_implementation\":\"New wallet implementation\"}},\"validateUserOp((address,uint256,bytes,bytes,uint256,uint256,uint256,uint256,uint256,bytes,bytes),bytes32,uint256)\":{\"params\":{\"missingAccountFunds\":\"the amount of funds required to pay to EntryPoint to pay for the userOp execution.\",\"userOp\":\"validate the userOp.signature field\",\"userOpHash\":\"convenient field: the hash of the request, to check the signature against          (also hashes the entrypoint and chain id)\"},\"returns\":{\"validationData\":\"signature and time-range of this operation      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,         otherwise, an address of an \\\"authorizer\\\" contract.      <6-byte> validUntil - last timestamp this operation is valid. 0 for \\\"indefinite\\\"      <6-byte> validAfter - first timestamp this operation is valid      If no time-range in account, return SIG_VALIDATION_FAILED (1) for signature failure.      Note that the validation code cannot use block.timestamp (or block.number) directly.\"}},\"withdrawDepositTo(address,uint256)\":{\"details\":\"Withdraw value from the account's deposit\",\"params\":{\"amount\":\"to withdraw\",\"withdrawAddress\":\"target to send to\"}}},\"title\":\"SmartAccount - EIP-4337 compatible smart contract wallet.\",\"version\":1},\"userdoc\":{\"errors\":{\"AlreadyInitialized()\":[{\"notice\":\"Throws if trying to initialize a Smart Account that has already been initialized\"}],\"BaseImplementationCannotBeZero()\":[{\"notice\":\"Throws if zero address has been provided as Base Implementation address\"}],\"CallerIsNotAnEntryPoint(address)\":[{\"notice\":\"Throws at onlyEntryPoint when msg.sender is not an EntryPoint set for this Smart Account\"}],\"CallerIsNotEntryPoint(address)\":[{\"notice\":\"Throws at _requireFromEntryPoint when msg.sender is not an EntryPoint\"}],\"CallerIsNotEntryPointOrOwner(address)\":[{\"notice\":\"Throws at _requireFromEntryPointOrOwner when msg.sender is not an EntryPoint neither an owner\"}],\"CallerIsNotEntryPointOrSelf(address)\":[{\"notice\":\"Throws at _requireFromEntryPointOrSelf when msg.sender is not an EntryPoint neither self\"}],\"CallerIsNotOwner(address)\":[{\"notice\":\"Throws at onlyOwner when msg.sender is not an owner\"}],\"CallerIsNotSelf(address)\":[{\"notice\":\"Throws when the caller is not address(this)\"}],\"DelegateCallsOnly()\":[{\"notice\":\"Thrown when the function that must be called only via delegatecall is called directly\"}],\"EntryPointCannotBeZero()\":[{\"notice\":\"Throws if zero address has been provided as Entry Point address\"}],\"HandlerCannotBeZero()\":[{\"notice\":\"Throws if zero address has been provided as Fallback Handler address\"}],\"InvalidImplementation(address)\":[{\"notice\":\"Throws if there is no code at implementationAddress\"}],\"MixedAuthFail(address)\":[{\"notice\":\"Throws at mixedAuth when msg.sender is not an owner neither _self\"}],\"ModuleAlreadyEnabled(address)\":[{\"notice\":\"Throws when trying to enable module that has already been enabled\"}],\"ModuleAndPrevModuleMismatch(address,address,address)\":[{\"notice\":\"Throws when module and previous module mismatch\"}],\"ModuleCannotBeZeroOrSentinel(address)\":[{\"notice\":\"Throws when address(0) or SENTINEL_MODULES constant has been provided as a module address\"}],\"ModuleNotEnabled(address)\":[{\"notice\":\"Throws when trying to execute transaction from module that is not enabled\"}],\"ModulesAlreadyInitialized()\":[{\"notice\":\"Throws when trying to initialize module manager that already been initialized\"}],\"ModulesSetupExecutionFailed()\":[{\"notice\":\"Throws when a delegatecall in course of module manager initialization has failed\"}],\"OwnerCanNotBeSelf()\":[{\"notice\":\"Thrown when trying to use address of the Smart Account as an owner for itself\"}],\"OwnerCannotBeZero()\":[{\"notice\":\"Throws if trying to change an owner of a SmartAccount to the zero address\"}],\"OwnerProvidedIsSame()\":[{\"notice\":\"Thrown when trying to use current owner as a new owner in a _setOwner() call\"}],\"TransferToZeroAddressAttempt()\":[{\"notice\":\"Throws when if trying to transfer to zero address\"}],\"WrongBatchProvided(uint256,uint256,uint256,uint256)\":[{\"notice\":\"Throws when data for executeBatchCall provided in wrong format (i.e. empty array or lengths mismatch)\"}],\"WrongContractSignature(bytes)\":[{\"notice\":\"Throws if isValidSignature for the conrtact signature and data hash differs from EIP1271 Magic Value\"}],\"WrongContractSignatureFormat(uint256,uint256,uint256)\":[{\"notice\":\"Throws if contract signature is provided in frong format\"}],\"WrongValidationModule(address)\":[{\"notice\":\"Throws when module address taken from signature is not enabled\"}]},\"kind\":\"user\",\"methods\":{\"disableModule(address,address)\":{\"notice\":\"This can only be done via a wallet transaction.Disables the module `module` for the wallet.\"},\"enableModule(address)\":{\"notice\":\"This can only be done via a userOp or a selfcall.Enables the module `module` for the wallet.\"},\"executeBatch_y6U(address[],uint256[],bytes[])\":{\"notice\":\"Name is optimized for this method to be cheaper to be called\"},\"execute_ncC(address,uint256,bytes)\":{\"notice\":\"Name is optimized for this method to be cheaper to be called\"},\"getImplementation()\":{\"notice\":\"The implementation address is stored in the contract's storage slot with index 0.\"},\"init(address,address,address,bytes)\":{\"notice\":\"devs need to make sure it is only callable once by initializer or state check restrictionsany further implementations that introduces a new state must have a reinit methodreinitialization is not possible, as _initialSetupModules reverts if the account is already initialized         which is when there is at least one enabled module\"},\"isValidSignature(bytes32,bytes)\":{\"notice\":\"Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)\"},\"nonce(uint192)\":{\"notice\":\"Provides 2D nonce functionality by allowing to use a nonce of a specific key.\"},\"setFallbackHandler(address)\":{\"notice\":\"This can only be done via a UserOp sent by EntryPoint.\"},\"setupAndEnableModule(address,bytes)\":{\"notice\":\"This can only be done via userOp or a selfcall.Enables the module `module` for the wallet.\"},\"supportsInterface(bytes4)\":{\"notice\":\"Query if a contract implements an interface\"},\"updateImplementation(address)\":{\"notice\":\"All the new implementations MUST have this method!Updates the implementation of the base wallet\"},\"validateUserOp((address,uint256,bytes,bytes,uint256,uint256,uint256,uint256,uint256,bytes,bytes),bytes32,uint256)\":{\"notice\":\"Validates the userOp.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/smart-account/SmartAccount.sol\":\"SmartAccount\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@account-abstraction/contracts/core/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n/**\\n * returned data from validateUserOp.\\n * validateUserOp returns a uint256, with is created by `_packedValidationData` and parsed by `_parseValidationData`\\n * @param aggregator - address(0) - the account validated the signature by itself.\\n *              address(1) - the account failed to validate the signature.\\n *              otherwise - this is an address of a signature aggregator that must be used to validate the signature.\\n * @param validAfter - this UserOp is valid only after this timestamp.\\n * @param validaUntil - this UserOp is valid only up to this timestamp.\\n */\\n    struct ValidationData {\\n        address aggregator;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n    }\\n\\n//extract sigFailed, validAfter, validUntil.\\n// also convert zero validUntil to type(uint48).max\\n    function _parseValidationData(uint validationData) pure returns (ValidationData memory data) {\\n        address aggregator = address(uint160(validationData));\\n        uint48 validUntil = uint48(validationData >> 160);\\n        if (validUntil == 0) {\\n            validUntil = type(uint48).max;\\n        }\\n        uint48 validAfter = uint48(validationData >> (48 + 160));\\n        return ValidationData(aggregator, validAfter, validUntil);\\n    }\\n\\n// intersect account and paymaster ranges.\\n    function _intersectTimeRange(uint256 validationData, uint256 paymasterValidationData) pure returns (ValidationData memory) {\\n        ValidationData memory accountValidationData = _parseValidationData(validationData);\\n        ValidationData memory pmValidationData = _parseValidationData(paymasterValidationData);\\n        address aggregator = accountValidationData.aggregator;\\n        if (aggregator == address(0)) {\\n            aggregator = pmValidationData.aggregator;\\n        }\\n        uint48 validAfter = accountValidationData.validAfter;\\n        uint48 validUntil = accountValidationData.validUntil;\\n        uint48 pmValidAfter = pmValidationData.validAfter;\\n        uint48 pmValidUntil = pmValidationData.validUntil;\\n\\n        if (validAfter < pmValidAfter) validAfter = pmValidAfter;\\n        if (validUntil > pmValidUntil) validUntil = pmValidUntil;\\n        return ValidationData(aggregator, validAfter, validUntil);\\n    }\\n\\n/**\\n * helper to pack the return value for validateUserOp\\n * @param data - the ValidationData to pack\\n */\\n    function _packValidationData(ValidationData memory data) pure returns (uint256) {\\n        return uint160(data.aggregator) | (uint256(data.validUntil) << 160) | (uint256(data.validAfter) << (160 + 48));\\n    }\\n\\n/**\\n * helper to pack the return value for validateUserOp, when not using an aggregator\\n * @param sigFailed - true for signature failure, false for success\\n * @param validUntil last timestamp this UserOperation is valid (or zero for infinite)\\n * @param validAfter first timestamp this UserOperation is valid\\n */\\n    function _packValidationData(bool sigFailed, uint48 validUntil, uint48 validAfter) pure returns (uint256) {\\n        return (sigFailed ? 1 : 0) | (uint256(validUntil) << 160) | (uint256(validAfter) << (160 + 48));\\n    }\\n\\n/**\\n * keccak function over calldata.\\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\\n */\\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\\n        assembly {\\n            let mem := mload(0x40)\\n            let len := data.length\\n            calldatacopy(mem, data.offset, len)\\n            ret := keccak256(mem, len)\\n        }\\n    }\\n\\n\",\"keccak256\":\"0x591c87519f7155d1909210276b77925ab2722a99b7b5d5649aecc36ebbdb045a\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/interfaces/IAccount.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\ninterface IAccount {\\n\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\\n     * This allows making a \\\"simulation call\\\" without a valid signature\\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp the operation that is about to be executed.\\n     * @param userOpHash hash of the user's request data. can be used as the basis for signature.\\n     * @param missingAccountFunds missing funds on the account's deposit in the entrypoint.\\n     *      This is the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\\n     *      The excess is left as a deposit in the entrypoint, for future calls.\\n     *      can be withdrawn anytime using \\\"entryPoint.withdrawTo()\\\"\\n     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero.\\n     * @return validationData packaged ValidationData structure. use `_packValidationData` and `_unpackValidationData` to encode and decode\\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\\n     *         otherwise, an address of an \\\"authorizer\\\" contract.\\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \\\"indefinite\\\"\\n     *      <6-byte> validAfter - first timestamp this operation is valid\\n     *      If an account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds)\\n    external returns (uint256 validationData);\\n}\\n\",\"keccak256\":\"0x556a0e5980de18e90b115553ed502408155ba35f58642823010d9288047bc418\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/interfaces/IAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\n/**\\n * Aggregated Signatures validator.\\n */\\ninterface IAggregator {\\n\\n    /**\\n     * validate aggregated signature.\\n     * revert if the aggregated signature does not match the given list of operations.\\n     */\\n    function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature) external view;\\n\\n    /**\\n     * validate signature of a single userOp\\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\\n     * @param userOp the userOperation received from the user.\\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\\n     *    (usually empty, unless account and aggregator support some kind of \\\"multisig\\\"\\n     */\\n    function validateUserOpSignature(UserOperation calldata userOp)\\n    external view returns (bytes memory sigForUserOp);\\n\\n    /**\\n     * aggregate multiple signatures into a single value.\\n     * This method is called off-chain to calculate the signature to pass with handleOps()\\n     * bundler MAY use optimized custom code perform this aggregation\\n     * @param userOps array of UserOperations to collect the signatures from.\\n     * @return aggregatedSignature the aggregated signature\\n     */\\n    function aggregateSignatures(UserOperation[] calldata userOps) external view returns (bytes memory aggregatedSignature);\\n}\\n\",\"keccak256\":\"0x060e9ddb0152250c269ba0640dc5753834ac44cf182a2837d508c0c529cae26a\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/interfaces/IEntryPoint.sol\":{\"content\":\"/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"./UserOperation.sol\\\";\\nimport \\\"./IStakeManager.sol\\\";\\nimport \\\"./IAggregator.sol\\\";\\nimport \\\"./INonceManager.sol\\\";\\n\\ninterface IEntryPoint is IStakeManager, INonceManager {\\n\\n    /***\\n     * An event emitted after each successful request\\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\\n     * @param sender - the account that generates this request.\\n     * @param paymaster - if non-null, the paymaster that pays for this request.\\n     * @param nonce - the nonce value from the request.\\n     * @param success - true if the sender transaction succeeded, false if reverted.\\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation.\\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution).\\n     */\\n    event UserOperationEvent(bytes32 indexed userOpHash, address indexed sender, address indexed paymaster, uint256 nonce, bool success, uint256 actualGasCost, uint256 actualGasUsed);\\n\\n    /**\\n     * account \\\"sender\\\" was deployed.\\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\\n     * @param sender the account that is deployed\\n     * @param factory the factory used to deploy this account (in the initCode)\\n     * @param paymaster the paymaster used by this UserOp\\n     */\\n    event AccountDeployed(bytes32 indexed userOpHash, address indexed sender, address factory, address paymaster);\\n\\n    /**\\n     * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length\\n     * @param userOpHash the request unique identifier.\\n     * @param sender the sender of this request\\n     * @param nonce the nonce used in the request\\n     * @param revertReason - the return bytes from the (reverted) call to \\\"callData\\\".\\n     */\\n    event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason);\\n\\n    /**\\n     * an event emitted by handleOps(), before starting the execution loop.\\n     * any event emitted before this event, is part of the validation.\\n     */\\n    event BeforeExecution();\\n\\n    /**\\n     * signature aggregator used by the following UserOperationEvents within this bundle.\\n     */\\n    event SignatureAggregatorChanged(address indexed aggregator);\\n\\n    /**\\n     * a custom revert error of handleOps, to identify the offending op.\\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\\n     *  @param reason - revert reason\\n     *      The string starts with a unique code \\\"AAmn\\\", where \\\"m\\\" is \\\"1\\\" for factory, \\\"2\\\" for account and \\\"3\\\" for paymaster issues,\\n     *      so a failure can be attributed to the correct entity.\\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\\n     */\\n    error FailedOp(uint256 opIndex, string reason);\\n\\n    /**\\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\\n     */\\n    error SignatureValidationFailed(address aggregator);\\n\\n    /**\\n     * Successful result from simulateValidation.\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     */\\n    error ValidationResult(ReturnInfo returnInfo,\\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo);\\n\\n    /**\\n     * Successful result from simulateValidation, if the account returns a signature aggregator\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\\n     */\\n    error ValidationResultWithAggregation(ReturnInfo returnInfo,\\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo,\\n        AggregatorStakeInfo aggregatorInfo);\\n\\n    /**\\n     * return value of getSenderAddress\\n     */\\n    error SenderAddressResult(address sender);\\n\\n    /**\\n     * return value of simulateHandleOp\\n     */\\n    error ExecutionResult(uint256 preOpGas, uint256 paid, uint48 validAfter, uint48 validUntil, bool targetSuccess, bytes targetResult);\\n\\n    //UserOps handled, per aggregator\\n    struct UserOpsPerAggregator {\\n        UserOperation[] userOps;\\n\\n        // aggregator address\\n        IAggregator aggregator;\\n        // aggregated signature\\n        bytes signature;\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperation.\\n     * no signature aggregator is used.\\n     * if any account requires an aggregator (that is, it returned an aggregator when\\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n     * @param ops the operations to execute\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) external;\\n\\n    /**\\n     * Execute a batch of UserOperation with Aggregators\\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata opsPerAggregator,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * generate a request Id - unique identifier for this request.\\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n     */\\n    function getUserOpHash(UserOperation calldata userOp) external view returns (bytes32);\\n\\n    /**\\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\\n     * @param userOp the user operation to validate.\\n     */\\n    function simulateValidation(UserOperation calldata userOp) external;\\n\\n    /**\\n     * gas and return values during simulation\\n     * @param preOpGas the gas used for validation (including preValidationGas)\\n     * @param prefund the required prefund for this operation\\n     * @param sigFailed validateUserOp's (or paymaster's) signature check failed\\n     * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\\n     */\\n    struct ReturnInfo {\\n        uint256 preOpGas;\\n        uint256 prefund;\\n        bool sigFailed;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n        bytes paymasterContext;\\n    }\\n\\n    /**\\n     * returned aggregated signature info.\\n     * the aggregator returned by the account, and its current stake.\\n     */\\n    struct AggregatorStakeInfo {\\n        address aggregator;\\n        StakeInfo stakeInfo;\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * this method always revert, and returns the address in SenderAddressResult error\\n     * @param initCode the constructor code to be passed into the UserOperation.\\n     */\\n    function getSenderAddress(bytes memory initCode) external;\\n\\n\\n    /**\\n     * simulate full execution of a UserOperation (including both validation and target execution)\\n     * this method will always revert with \\\"ExecutionResult\\\".\\n     * it performs full validation of the UserOperation, but ignores signature error.\\n     * an optional target address is called after the userop succeeds, and its value is returned\\n     * (before the entire call is reverted)\\n     * Note that in order to collect the the success/failure of the target call, it must be executed\\n     * with trace enabled to track the emitted events.\\n     * @param op the UserOperation to simulate\\n     * @param target if nonzero, a target address to call after userop simulation. If called, the targetSuccess and targetResult\\n     *        are set to the return from that call.\\n     * @param targetCallData callData to pass to target address\\n     */\\n    function simulateHandleOp(UserOperation calldata op, address target, bytes calldata targetCallData) external;\\n}\\n\\n\",\"keccak256\":\"0x3a90bf308819ed125fa4202f880999caff8a8686633b8ddb79a30ca240d5b8f8\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/interfaces/INonceManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\ninterface INonceManager {\\n\\n    /**\\n     * Return the next nonce for this sender.\\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\\n     * But UserOp with different keys can come with arbitrary order.\\n     *\\n     * @param sender the account address\\n     * @param key the high 192 bit of the nonce\\n     * @return nonce a full nonce to pass for next UserOp with this sender.\\n     */\\n    function getNonce(address sender, uint192 key)\\n    external view returns (uint256 nonce);\\n\\n    /**\\n     * Manually increment the nonce of the sender.\\n     * This method is exposed just for completeness..\\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\\n     * as the EntryPoint will update the nonce regardless.\\n     * Possible use-case is call it with various keys to \\\"initialize\\\" their nonces to one, so that future\\n     * UserOperations will not pay extra for the first transaction with a given key.\\n     */\\n    function incrementNonce(uint192 key) external;\\n}\\n\",\"keccak256\":\"0x509871e6c63663cdcc3eba19920fe84e991f38b289b1377ac3c3a6d9f22d7e12\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/interfaces/IStakeManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.12;\\n\\n/**\\n * manage deposits and stakes.\\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\\n * stake is value locked for at least \\\"unstakeDelay\\\" by the staked entity.\\n */\\ninterface IStakeManager {\\n\\n    event Deposited(\\n        address indexed account,\\n        uint256 totalDeposit\\n    );\\n\\n    event Withdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /// Emitted when stake or unstake delay are modified\\n    event StakeLocked(\\n        address indexed account,\\n        uint256 totalStaked,\\n        uint256 unstakeDelaySec\\n    );\\n\\n    /// Emitted once a stake is scheduled for withdrawal\\n    event StakeUnlocked(\\n        address indexed account,\\n        uint256 withdrawTime\\n    );\\n\\n    event StakeWithdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @param deposit the entity's deposit\\n     * @param staked true if this entity is staked.\\n     * @param stake actual amount of ether staked for this entity.\\n     * @param unstakeDelaySec minimum delay to withdraw the stake.\\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\\n     * @dev sizes were chosen so that (deposit,staked, stake) fit into one cell (used during handleOps)\\n     *    and the rest fit into a 2nd cell.\\n     *    112 bit allows for 10^15 eth\\n     *    48 bit for full timestamp\\n     *    32 bit allows 150 years for unstake delay\\n     */\\n    struct DepositInfo {\\n        uint112 deposit;\\n        bool staked;\\n        uint112 stake;\\n        uint32 unstakeDelaySec;\\n        uint48 withdrawTime;\\n    }\\n\\n    //API struct used by getStakeInfo and simulateValidation\\n    struct StakeInfo {\\n        uint256 stake;\\n        uint256 unstakeDelaySec;\\n    }\\n\\n    /// @return info - full deposit information of given account\\n    function getDepositInfo(address account) external view returns (DepositInfo memory info);\\n\\n    /// @return the deposit (for gas payment) of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * add to the deposit of the given account\\n     */\\n    function depositTo(address account) external payable;\\n\\n    /**\\n     * add to the account's stake - amount and delay\\n     * any pending unstake is first cancelled.\\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\\n     */\\n    function addStake(uint32 _unstakeDelaySec) external payable;\\n\\n    /**\\n     * attempt to unlock the stake.\\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\\n     */\\n    function unlockStake() external;\\n\\n    /**\\n     * withdraw from the (unlocked) stake.\\n     * must first call unlockStake and wait for the unstakeDelay to pass\\n     * @param withdrawAddress the address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external;\\n\\n    /**\\n     * withdraw from the deposit.\\n     * @param withdrawAddress the address to send withdrawn value.\\n     * @param withdrawAmount the amount to withdraw.\\n     */\\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external;\\n}\\n\",\"keccak256\":\"0xd227b02888cd4ac68daebcdfd992ec00f9fff66fa3b3bb16f656cd582fa3480f\",\"license\":\"GPL-3.0-only\"},\"@account-abstraction/contracts/interfaces/UserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\nimport {calldataKeccak} from \\\"../core/Helpers.sol\\\";\\n\\n/**\\n * User Operation struct\\n * @param sender the sender account of this request.\\n     * @param nonce unique value the sender uses to verify it is not a replay.\\n     * @param initCode if set, the account contract will be created by this constructor/\\n     * @param callData the method call to execute on this account.\\n     * @param callGasLimit the gas limit passed to the callData method call.\\n     * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\\n     * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\\n     * @param maxFeePerGas same as EIP-1559 gas parameter.\\n     * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\\n     * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\\n     * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n     */\\n    struct UserOperation {\\n\\n        address sender;\\n        uint256 nonce;\\n        bytes initCode;\\n        bytes callData;\\n        uint256 callGasLimit;\\n        uint256 verificationGasLimit;\\n        uint256 preVerificationGas;\\n        uint256 maxFeePerGas;\\n        uint256 maxPriorityFeePerGas;\\n        bytes paymasterAndData;\\n        bytes signature;\\n    }\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n\\n    function getSender(UserOperation calldata userOp) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {data := calldataload(userOp)}\\n        return address(uint160(data));\\n    }\\n\\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\\n    // pay above what he signed for.\\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint256) {\\n    unchecked {\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        if (maxFeePerGas == maxPriorityFeePerGas) {\\n            //legacy mode (for networks that don't support basefee opcode)\\n            return maxFeePerGas;\\n        }\\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n    }\\n    }\\n\\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\\n        address sender = getSender(userOp);\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        uint256 callGasLimit = userOp.callGasLimit;\\n        uint256 verificationGasLimit = userOp.verificationGasLimit;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return abi.encode(\\n            sender, nonce,\\n            hashInitCode, hashCallData,\\n            callGasLimit, verificationGasLimit, preVerificationGas,\\n            maxFeePerGas, maxPriorityFeePerGas,\\n            hashPaymasterAndData\\n        );\\n    }\\n\\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\\n        return keccak256(pack(userOp));\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\",\"keccak256\":\"0x61374003361059087fdcf17967a7bba052badeaf5c7f0ae689166f8aafd3a45c\",\"license\":\"GPL-3.0\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\",\"keccak256\":\"0x809bc3edb4bcbef8263fa616c1b60ee0004b50a8a1bfa164d8f57fd31f520c58\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"contracts/smart-account/BaseSmartAccount.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport {IAccount} from \\\"@account-abstraction/contracts/interfaces/IAccount.sol\\\";\\r\\nimport {IEntryPoint} from \\\"@account-abstraction/contracts/interfaces/IEntryPoint.sol\\\";\\r\\nimport {UserOperationLib, UserOperation} from \\\"@account-abstraction/contracts/interfaces/UserOperation.sol\\\";\\r\\nimport {BaseSmartAccountErrors} from \\\"./common/Errors.sol\\\";\\r\\nimport \\\"@account-abstraction/contracts/core/Helpers.sol\\\";\\r\\n\\r\\n/**\\r\\n * Basic account implementation.\\r\\n * This contract provides the basic logic for implementing the IAccount interface: validateUserOp function\\r\\n * Specific account implementation should inherit it and provide the account-specific logic\\r\\n */\\r\\nabstract contract BaseSmartAccount is IAccount, BaseSmartAccountErrors {\\r\\n    using UserOperationLib for UserOperation;\\r\\n\\r\\n    // Return value in case of signature failure, with no time-range.\\r\\n    // equivalent to _packValidationData(true,0,0);\\r\\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\\r\\n\\r\\n    /**\\r\\n     * @dev Initialize the Smart Account with required states.\\r\\n     * @param handler Default fallback handler for the Smart Account.\\r\\n     * @param sessionKeyModuleContract Initializes the session key module\\r\\n     * @param authModuleSetupContract Initializes the auth module; can be a factory or registry for multiple accounts.\\r\\n     * @param authModuleSetupData Contains address of the Setup Contract and setup data.\\r\\n     * @notice Ensure this is callable only once (use initializer modifier or state checks).\\r\\n     */\\r\\n    function init(\\r\\n        address handler,\\r\\n        address sessionKeyModuleContract,\\r\\n        address authModuleSetupContract,\\r\\n        bytes calldata authModuleSetupData\\r\\n    ) external virtual returns (address);\\r\\n\\r\\n    /**\\r\\n     * Validates the userOp.\\r\\n     * @param userOp validate the userOp.signature field\\r\\n     * @param userOpHash convenient field: the hash of the request, to check the signature against\\r\\n     *          (also hashes the entrypoint and chain id)\\r\\n     * @param missingAccountFunds the amount of funds required to pay to EntryPoint to pay for the userOp execution.\\r\\n     * @return validationData signature and time-range of this operation\\r\\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\\r\\n     *         otherwise, an address of an \\\"authorizer\\\" contract.\\r\\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \\\"indefinite\\\"\\r\\n     *      <6-byte> validAfter - first timestamp this operation is valid\\r\\n     *      If no time-range in account, return SIG_VALIDATION_FAILED (1) for signature failure.\\r\\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\\r\\n     */\\r\\n    function validateUserOp(\\r\\n        UserOperation calldata userOp,\\r\\n        bytes32 userOpHash,\\r\\n        uint256 missingAccountFunds\\r\\n    ) external virtual override returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @return nonce the account nonce.\\r\\n     * @dev This method returns the next sequential nonce.\\r\\n     * @notice Provides 2D nonce functionality by allowing to use a nonce of a specific key.\\r\\n     */\\r\\n    function nonce(uint192 _key) public view virtual returns (uint256) {\\r\\n        return entryPoint().getNonce(address(this), _key);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * return the entryPoint used by this account.\\r\\n     * subclass should return the current entryPoint used by this account.\\r\\n     */\\r\\n    function entryPoint() public view virtual returns (IEntryPoint);\\r\\n\\r\\n    /**\\r\\n     * sends to the entrypoint (msg.sender) the missing funds for this transaction.\\r\\n     * subclass MAY override this method for better funds management\\r\\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\\r\\n     * it will not be required to send again)\\r\\n     * @param missingAccountFunds the minimum value this method should send the entrypoint.\\r\\n     *  this value MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\\r\\n     */\\r\\n    function _payPrefund(uint256 missingAccountFunds) internal virtual {\\r\\n        if (missingAccountFunds != 0) {\\r\\n            payable(msg.sender).call{\\r\\n                value: missingAccountFunds,\\r\\n                gas: type(uint256).max\\r\\n            }(\\\"\\\");\\r\\n            //ignore failure (its EntryPoint's job to verify, not account.)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x0ec7ca16f6ad6d83bcc74902c3a76844d5e48bdecb566619b26d2038996abc3a\",\"license\":\"GPL-3.0\"},\"contracts/smart-account/SmartAccount.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport {BaseSmartAccount, IEntryPoint, UserOperation} from \\\"./BaseSmartAccount.sol\\\";\\r\\nimport {ModuleManager} from \\\"./base/ModuleManager.sol\\\";\\r\\nimport {FallbackManager} from \\\"./base/FallbackManager.sol\\\";\\r\\nimport {LibAddress} from \\\"./libs/LibAddress.sol\\\";\\r\\nimport {ISignatureValidator} from \\\"./interfaces/ISignatureValidator.sol\\\";\\r\\nimport {IERC165} from \\\"./interfaces/IERC165.sol\\\";\\r\\nimport {SmartAccountErrors} from \\\"./common/Errors.sol\\\";\\r\\nimport {ECDSA} from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\r\\nimport {IAuthorizationModule} from \\\"./interfaces/IAuthorizationModule.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SmartAccount - EIP-4337 compatible smart contract wallet.\\r\\n * @dev This contract is the base for the Smart Account functionality.\\r\\n *         - It is modular by nature. UserOp and txns validation happens in Authorization Modules.\\r\\n *         - It provides the functionality to execute AA (EIP-4337) userOps. Gnosis style txns removed to a module.\\r\\n *         - It allows to receive and manage assets.\\r\\n *         - It is responsible for managing the modules and fallbacks.\\r\\n *         - The Smart Account can be extended with modules, such as Social Recovery, Session Key and others.\\r\\n * @author Chirag Titiya - <chirag@biconomy.io>, Filipp Makarov - <filipp.makarov@biconomy.io>\\r\\n */\\r\\ncontract SmartAccount is\\r\\n    BaseSmartAccount,\\r\\n    ModuleManager,\\r\\n    FallbackManager,\\r\\n    IERC165,\\r\\n    SmartAccountErrors,\\r\\n    ISignatureValidator\\r\\n{\\r\\n    using ECDSA for bytes32;\\r\\n    using LibAddress for address;\\r\\n\\r\\n    // Storage Version\\r\\n    string public constant VERSION = \\\"2.0.0\\\";\\r\\n\\r\\n    // Owner storage. Deprecated. Left for storage layout compatibility\\r\\n    address public ownerDeprecated;\\r\\n\\r\\n    // changed to 2D nonce below\\r\\n    // @notice there is no _nonce\\r\\n    // Deprecated. Left for storage layout compatibility\\r\\n    mapping(uint256 => uint256) public noncesDeprecated;\\r\\n\\r\\n    // AA immutable storage\\r\\n    IEntryPoint private immutable ENTRY_POINT;\\r\\n    address private immutable SELF;\\r\\n\\r\\n    // Events\\r\\n    event ImplementationUpdated(\\r\\n        address indexed oldImplementation,\\r\\n        address indexed newImplementation\\r\\n    );\\r\\n    event SmartAccountReceivedNativeToken(\\r\\n        address indexed sender,\\r\\n        uint256 indexed value\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Constructor that sets the entry point contract.\\r\\n     *      _modules[SENTINEL_MODULES] = SENTINEL_MODULES protects implementation from initialization\\r\\n     * @param anEntryPoint The address of the entry point contract.\\r\\n     */\\r\\n    constructor(IEntryPoint anEntryPoint) {\\r\\n        SELF = address(this);\\r\\n        if (address(anEntryPoint) == address(0))\\r\\n            revert EntryPointCannotBeZero();\\r\\n        ENTRY_POINT = anEntryPoint;\\r\\n        _modules[SENTINEL_MODULES] = SENTINEL_MODULES;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This function is a special fallback function that is triggered when the contract receives Ether.\\r\\n     * It logs an event indicating the amount of Ether received and the sender's address.\\r\\n     * @notice This function is marked as external and payable, meaning it can be called from external\\r\\n     * sources and accepts Ether as payment.\\r\\n     */\\r\\n    receive() external payable {\\r\\n        if (address(this) == SELF) revert DelegateCallsOnly();\\r\\n        emit SmartAccountReceivedNativeToken(msg.sender, msg.value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Initialize the Smart Account with required states\\r\\n     * @param handler Default fallback handler provided in Smart Account\\r\\n     * @param sessionKeyModuleContract Contract, that enables session key module\\r\\n     * @param authModuleSetupContract Contract, that setups initial auth module for this smart account.\\r\\n     * It can be a module factory or a registry module that serves several smart accounts\\r\\n     * @param authModuleSetupData modules setup data (a standard calldata for the module setup contract)\\r\\n     * @notice devs need to make sure it is only callable once by initializer or state check restrictions\\r\\n     * @notice any further implementations that introduces a new state must have a reinit method\\r\\n     * @notice reinitialization is not possible, as _initialSetupModules reverts if the account is already initialized\\r\\n     *         which is when there is at least one enabled module\\r\\n     */\\r\\n    function init(\\r\\n        address handler,\\r\\n        address sessionKeyModuleContract,\\r\\n        address authModuleSetupContract,\\r\\n        bytes calldata authModuleSetupData\\r\\n    ) external virtual override returns (address authAddress) {\\r\\n        if (\\r\\n            _modules[SENTINEL_MODULES] != address(0) ||\\r\\n            getFallbackHandler() != address(0)\\r\\n        ) revert AlreadyInitialized();\\r\\n        _setFallbackHandler(handler);\\r\\n        authAddress = _initialSetupModules(\\r\\n            authModuleSetupContract,\\r\\n            authModuleSetupData\\r\\n        );\\r\\n        _enableModule(sessionKeyModuleContract);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Interface function with the standard name for execute_ncC\\r\\n     * @param dest Address of the contract to call\\r\\n     * @param value Amount of native tokens to send along with the transaction\\r\\n     * @param func Data of the transaction\\r\\n     */\\r\\n    function execute(\\r\\n        address dest,\\r\\n        uint256 value,\\r\\n        bytes calldata func\\r\\n    ) external {\\r\\n        execute_ncC(dest, value, func);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Interface function with the standard name for executeBatch_y6U\\r\\n     * @param dest Addresses of the contracts to call\\r\\n     * @param value Amounts of native tokens to send along with the transactions\\r\\n     * @param func Data of the transactions\\r\\n     */\\r\\n    function executeBatch(\\r\\n        address[] calldata dest,\\r\\n        uint256[] calldata value,\\r\\n        bytes[] calldata func\\r\\n    ) external {\\r\\n        executeBatch_y6U(dest, value, func);\\r\\n    }\\r\\n\\r\\n    function validateUserOp(\\r\\n        UserOperation calldata userOp,\\r\\n        bytes32 userOpHash,\\r\\n        uint256 missingAccountFunds\\r\\n    ) external virtual override returns (uint256 validationData) {\\r\\n        if (msg.sender != address(entryPoint()))\\r\\n            revert CallerIsNotAnEntryPoint(msg.sender);\\r\\n\\r\\n        (, address validationModule) = abi.decode(\\r\\n            userOp.signature,\\r\\n            (bytes, address)\\r\\n        );\\r\\n        if (address(_modules[validationModule]) != address(0)) {\\r\\n            validationData = IAuthorizationModule(validationModule)\\r\\n                .validateUserOp(userOp, userOpHash);\\r\\n        } else {\\r\\n            revert WrongValidationModule(validationModule);\\r\\n        }\\r\\n        // Check nonce requirement if any\\r\\n        _payPrefund(missingAccountFunds);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds a module to the allowlist.\\r\\n     * @notice This can only be done via a userOp or a selfcall.\\r\\n     * @notice Enables the module `module` for the wallet.\\r\\n     * @param module Module to be allow-listed.\\r\\n     */\\r\\n    function enableModule(address module) external virtual override {\\r\\n        _requireFromEntryPointOrSelf();\\r\\n        _enableModule(module);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Setups module for this Smart Account and enables it.\\r\\n     * @notice This can only be done via userOp or a selfcall.\\r\\n     * @notice Enables the module `module` for the wallet.\\r\\n     */\\r\\n    function setupAndEnableModule(\\r\\n        address setupContract,\\r\\n        bytes memory setupData\\r\\n    ) external virtual override returns (address) {\\r\\n        _requireFromEntryPointOrSelf();\\r\\n        return _setupAndEnableModule(setupContract, setupData);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the fallback handler.\\r\\n     * @notice This can only be done via a UserOp sent by EntryPoint.\\r\\n     * @param handler Handler to be set.\\r\\n     */\\r\\n    function setFallbackHandler(address handler) external virtual override {\\r\\n        _requireFromEntryPointOrSelf();\\r\\n        _setFallbackHandler(handler);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the implementation contract associated with this contract.\\r\\n     * @notice The implementation address is stored in the contract's storage slot with index 0.\\r\\n     */\\r\\n    function getImplementation()\\r\\n        external\\r\\n        view\\r\\n        returns (address _implementation)\\r\\n    {\\r\\n        assembly {\\r\\n            _implementation := sload(address())\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Query if a contract implements an interface\\r\\n     * @param _interfaceId The interface identifier, as specified in ERC165\\r\\n     * @return `true` if the contract implements `_interfaceID`\\r\\n     */\\r\\n    function supportsInterface(\\r\\n        bytes4 _interfaceId\\r\\n    ) external view virtual override returns (bool) {\\r\\n        return _interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice All the new implementations MUST have this method!\\r\\n     * @notice Updates the implementation of the base wallet\\r\\n     * @param _implementation New wallet implementation\\r\\n     */\\r\\n    function updateImplementation(address _implementation) public virtual {\\r\\n        _requireFromEntryPointOrSelf();\\r\\n        require(_implementation != address(0), \\\"Address cannot be zero\\\");\\r\\n        if (!_implementation.isContract())\\r\\n            revert InvalidImplementation(_implementation);\\r\\n        address oldImplementation;\\r\\n\\r\\n        assembly {\\r\\n            oldImplementation := sload(address())\\r\\n            sstore(address(), _implementation)\\r\\n        }\\r\\n        emit ImplementationUpdated(oldImplementation, _implementation);\\r\\n    }\\r\\n\\r\\n    /* solhint-disable func-name-mixedcase */\\r\\n\\r\\n    /**\\r\\n     * @dev Execute a transaction (called by entryPoint)\\r\\n     * @notice Name is optimized for this method to be cheaper to be called\\r\\n     * @param dest Address of the contract to call\\r\\n     * @param value Amount of native tokens to send along with the transaction\\r\\n     * @param func Data of the transaction\\r\\n     */\\r\\n    function execute_ncC(\\r\\n        address dest,\\r\\n        uint256 value,\\r\\n        bytes calldata func\\r\\n    ) public {\\r\\n        _requireFromEntryPoint();\\r\\n        _call(dest, value, func);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Execute a sequence of transactions\\r\\n     * @notice Name is optimized for this method to be cheaper to be called\\r\\n     * @param dest Addresses of the contracts to call\\r\\n     * @param value Amounts of native tokens to send along with the transactions\\r\\n     * @param func Data of the transactions\\r\\n     */\\r\\n    function executeBatch_y6U(\\r\\n        address[] calldata dest,\\r\\n        uint256[] calldata value,\\r\\n        bytes[] calldata func\\r\\n    ) public {\\r\\n        _requireFromEntryPoint();\\r\\n        if (\\r\\n            dest.length == 0 ||\\r\\n            dest.length != value.length ||\\r\\n            value.length != func.length\\r\\n        ) revert WrongBatchProvided(dest.length, value.length, func.length, 0);\\r\\n        for (uint256 i; i < dest.length; ) {\\r\\n            _call(dest[i], value[i], func[i]);\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* solhint-enable func-name-mixedcase */\\r\\n\\r\\n    /**\\r\\n     * @dev Deposit more funds for this account in the entryPoint\\r\\n     */\\r\\n    function addDeposit() public payable {\\r\\n        entryPoint().depositTo{value: msg.value}(address(this));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Withdraw value from the account's deposit\\r\\n     * @param withdrawAddress target to send to\\r\\n     * @param amount to withdraw\\r\\n     */\\r\\n    function withdrawDepositTo(\\r\\n        address payable withdrawAddress,\\r\\n        uint256 amount\\r\\n    ) public payable {\\r\\n        _requireFromEntryPointOrSelf();\\r\\n        entryPoint().withdrawTo(withdrawAddress, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a module from the allowlist.\\r\\n     * @notice This can only be done via a wallet transaction.\\r\\n     * @notice Disables the module `module` for the wallet.\\r\\n     * @param prevModule Module that pointed to the module to be removed in the linked list\\r\\n     * @param module Module to be removed.\\r\\n     */\\r\\n    function disableModule(address prevModule, address module) public virtual {\\r\\n        _requireFromEntryPointOrSelf();\\r\\n        _disableModule(prevModule, module);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current entry point used by this account.\\r\\n     * @return EntryPoint as an `IEntryPoint` interface.\\r\\n     * @dev This function should be implemented by the subclass to return the current entry point used by this account.\\r\\n     */\\r\\n    function entryPoint() public view virtual override returns (IEntryPoint) {\\r\\n        return ENTRY_POINT;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check current account deposit in the entryPoint\\r\\n     */\\r\\n    function getDeposit() public view returns (uint256) {\\r\\n        return entryPoint().balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)\\r\\n     * @dev Forwards the validation to the module specified in the signature\\r\\n     * @param dataHash 32 bytes hash of the data signed on the behalf of address(msg.sender)\\r\\n     * @param signature Signature byte array associated with dataHash\\r\\n     * @return bytes4 value.\\r\\n     */\\r\\n    function isValidSignature(\\r\\n        bytes32 dataHash,\\r\\n        bytes memory signature\\r\\n    ) public view override returns (bytes4) {\\r\\n        (bytes memory moduleSignature, address validationModule) = abi.decode(\\r\\n            signature,\\r\\n            (bytes, address)\\r\\n        );\\r\\n        if (address(_modules[validationModule]) != address(0)) {\\r\\n            return\\r\\n                ISignatureValidator(validationModule).isValidSignature(\\r\\n                    dataHash,\\r\\n                    moduleSignature\\r\\n                );\\r\\n        } else {\\r\\n            revert WrongValidationModule(validationModule);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev internal method that fecilitates the extenral calls from SmartAccount\\r\\n     * @dev similar to execute() of Executor.sol\\r\\n     * @param target destination address contract/non-contract\\r\\n     * @param value amount of native tokens\\r\\n     * @param data function singature of destination\\r\\n     */\\r\\n    function _call(address target, uint256 value, bytes memory data) internal {\\r\\n        assembly {\\r\\n            let success := call(\\r\\n                gas(),\\r\\n                target,\\r\\n                value,\\r\\n                add(data, 0x20),\\r\\n                mload(data),\\r\\n                0,\\r\\n                0\\r\\n            )\\r\\n            let ptr := mload(0x40)\\r\\n            returndatacopy(ptr, 0, returndatasize())\\r\\n            if iszero(success) {\\r\\n                revert(ptr, returndatasize())\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This function allows entry point or SA itself to execute certain actions.\\r\\n     * If the caller is not authorized, the function will revert with an error message.\\r\\n     * @notice This function acts as modifier and is marked as internal to be be called\\r\\n     * within the contract itself only.\\r\\n     */\\r\\n    function _requireFromEntryPointOrSelf() internal view {\\r\\n        if (msg.sender != address(entryPoint()) && msg.sender != address(this))\\r\\n            revert CallerIsNotEntryPointOrSelf(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This function allows entry point to execute certain actions.\\r\\n     * If the caller is not authorized, the function will revert with an error message.\\r\\n     * @notice This function acts as modifier and is marked as internal to be be called\\r\\n     * within the contract itself only.\\r\\n     */\\r\\n    function _requireFromEntryPoint() internal view {\\r\\n        if (msg.sender != address(entryPoint()))\\r\\n            revert CallerIsNotEntryPoint(msg.sender);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x8587b948c46931780e82d1b9df20a42ba94eaa18377ee4967a45a3a139565db1\",\"license\":\"MIT\"},\"contracts/smart-account/base/Executor.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport {Enum} from \\\"../common/Enum.sol\\\";\\r\\n\\r\\n/// @title Executor - A contract that can execute transactions\\r\\nabstract contract Executor {\\r\\n    // Could add a flag fromEntryPoint for AA txn\\r\\n    event ExecutionFailure(\\r\\n        address indexed to,\\r\\n        uint256 indexed value,\\r\\n        bytes indexed data,\\r\\n        Enum.Operation operation,\\r\\n        uint256 txGas\\r\\n    );\\r\\n    event ExecutionSuccess(\\r\\n        address indexed to,\\r\\n        uint256 indexed value,\\r\\n        bytes indexed data,\\r\\n        Enum.Operation operation,\\r\\n        uint256 txGas\\r\\n    );\\r\\n\\r\\n    function _execute(\\r\\n        address to,\\r\\n        uint256 value,\\r\\n        bytes memory data,\\r\\n        Enum.Operation operation,\\r\\n        uint256 txGas\\r\\n    ) internal returns (bool success) {\\r\\n        if (operation == Enum.Operation.DelegateCall) {\\r\\n            assembly {\\r\\n                success := delegatecall(\\r\\n                    txGas,\\r\\n                    to,\\r\\n                    add(data, 0x20),\\r\\n                    mload(data),\\r\\n                    0,\\r\\n                    0\\r\\n                )\\r\\n            }\\r\\n        } else {\\r\\n            assembly {\\r\\n                success := call(\\r\\n                    txGas,\\r\\n                    to,\\r\\n                    value,\\r\\n                    add(data, 0x20),\\r\\n                    mload(data),\\r\\n                    0,\\r\\n                    0\\r\\n                )\\r\\n            }\\r\\n        }\\r\\n        if (success) emit ExecutionSuccess(to, value, data, operation, txGas);\\r\\n        else emit ExecutionFailure(to, value, data, operation, txGas);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x09760fe4fe6edb6ac8f4c0b7b6a52f5ae62e4c5a8bdb4b96d5a5872e8844329e\",\"license\":\"LGPL-3.0-only\"},\"contracts/smart-account/base/FallbackManager.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport {SelfAuthorized} from \\\"../common/SelfAuthorized.sol\\\";\\r\\nimport {FallbackManagerErrors} from \\\"../common/Errors.sol\\\";\\r\\n\\r\\n/**\\r\\n *   @title Fallback Manager - A contract that manages fallback calls made to the Smart Account\\r\\n *   @dev Fallback calls are handled by a `handler` contract that is stored at FALLBACK_HANDLER_STORAGE_SLOT\\r\\n *        fallback calls are not delegated to the `handler` so they can not directly change Smart Account storage\\r\\n */\\r\\nabstract contract FallbackManager is SelfAuthorized, FallbackManagerErrors {\\r\\n    // keccak-256 hash of \\\"fallback_manager.handler.address\\\" subtracted by 1\\r\\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT =\\r\\n        0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d4;\\r\\n\\r\\n    uint256[24] private __gap;\\r\\n\\r\\n    event ChangedFallbackHandler(\\r\\n        address indexed previousHandler,\\r\\n        address indexed handler\\r\\n    );\\r\\n\\r\\n    fallback() external {\\r\\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\\r\\n\\r\\n        assembly {\\r\\n            let handler := sload(slot)\\r\\n            if iszero(handler) {\\r\\n                return(0, 0)\\r\\n            }\\r\\n            calldatacopy(0, 0, calldatasize())\\r\\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\\r\\n            // Then the address without padding is stored right after the calldata\\r\\n            mstore(calldatasize(), shl(96, caller()))\\r\\n            // Add 20 bytes for the address appended add the end\\r\\n            let success := call(\\r\\n                gas(),\\r\\n                handler,\\r\\n                0,\\r\\n                0,\\r\\n                add(calldatasize(), 20),\\r\\n                0,\\r\\n                0\\r\\n            )\\r\\n            returndatacopy(0, 0, returndatasize())\\r\\n            if iszero(success) {\\r\\n                revert(0, returndatasize())\\r\\n            }\\r\\n            return(0, returndatasize())\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Allows to add a contract to handle fallback calls.\\r\\n    ///      Only fallback calls without value and with data will be forwarded\\r\\n    /// @param handler contract to handle fallback calls.\\r\\n    function setFallbackHandler(address handler) external virtual;\\r\\n\\r\\n    function getFallbackHandler() public view returns (address _handler) {\\r\\n        assembly {\\r\\n            _handler := sload(FALLBACK_HANDLER_STORAGE_SLOT)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _setFallbackHandler(address handler) internal {\\r\\n        if (handler == address(0)) revert HandlerCannotBeZero();\\r\\n        address previousHandler;\\r\\n\\r\\n        assembly {\\r\\n            previousHandler := sload(FALLBACK_HANDLER_STORAGE_SLOT)\\r\\n            //}\\r\\n            //bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\\r\\n\\r\\n            //assembly {\\r\\n            sstore(FALLBACK_HANDLER_STORAGE_SLOT, handler)\\r\\n        }\\r\\n        emit ChangedFallbackHandler(previousHandler, handler);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x29f42258224ed746b84470084b455731632d710bd7236d3d8576084bf6be3fb4\",\"license\":\"LGPL-3.0-only\"},\"contracts/smart-account/base/ModuleManager.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport {SelfAuthorized} from \\\"../common/SelfAuthorized.sol\\\";\\r\\nimport {Executor, Enum} from \\\"./Executor.sol\\\";\\r\\nimport {ModuleManagerErrors} from \\\"../common/Errors.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Module Manager - A contract that manages modules that can execute transactions\\r\\n *        on behalf of the Smart Account via this contract.\\r\\n */\\r\\nabstract contract ModuleManager is\\r\\n    SelfAuthorized,\\r\\n    Executor,\\r\\n    ModuleManagerErrors\\r\\n{\\r\\n    address internal constant SENTINEL_MODULES = address(0x1);\\r\\n    mapping(address => address) internal _modules;\\r\\n    uint256[24] private __gap;\\r\\n\\r\\n    // Events\\r\\n    event EnabledModule(address module);\\r\\n    event DisabledModule(address module);\\r\\n    event ExecutionFromModuleSuccess(address indexed module);\\r\\n    event ExecutionFromModuleFailure(address indexed module);\\r\\n    event ModuleTransaction(\\r\\n        address module,\\r\\n        address to,\\r\\n        uint256 value,\\r\\n        bytes data,\\r\\n        Enum.Operation operation\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Adds a module to the allowlist.\\r\\n     * @notice This SHOULD only be done via userOp or a selfcall.\\r\\n     */\\r\\n    function enableModule(address module) external virtual;\\r\\n\\r\\n    /**\\r\\n     * @dev Setups module for this Smart Account and enables it.\\r\\n     * @notice This SHOULD only be done via userOp or a selfcall.\\r\\n     */\\r\\n    function setupAndEnableModule(\\r\\n        address setupContract,\\r\\n        bytes memory setupData\\r\\n    ) external virtual returns (address);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns array of modules. Useful for a widget\\r\\n     * @param start Start of the page.\\r\\n     * @param pageSize Maximum number of modules that should be returned.\\r\\n     * @return array Array of modules.\\r\\n     * @return next Start of the next page.\\r\\n     */\\r\\n    function getModulesPaginated(\\r\\n        address start,\\r\\n        uint256 pageSize\\r\\n    ) external view returns (address[] memory array, address next) {\\r\\n        // Init array with max page size\\r\\n        array = new address[](pageSize);\\r\\n\\r\\n        // Populate return array\\r\\n        uint256 moduleCount;\\r\\n        address currentModule = _modules[start];\\r\\n        while (\\r\\n            currentModule != address(0x0) &&\\r\\n            currentModule != SENTINEL_MODULES &&\\r\\n            moduleCount < pageSize\\r\\n        ) {\\r\\n            array[moduleCount] = currentModule;\\r\\n            currentModule = _modules[currentModule];\\r\\n            moduleCount++;\\r\\n        }\\r\\n        next = currentModule;\\r\\n        // Set correct size of returned array\\r\\n\\r\\n        assembly {\\r\\n            mstore(array, moduleCount)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows a Module to execute a Smart Account transaction without any further confirmations.\\r\\n     * @param to Destination address of module transaction.\\r\\n     * @param value Ether value of module transaction.\\r\\n     * @param data Data payload of module transaction.\\r\\n     * @param operation Operation type of module transaction.\\r\\n     */\\r\\n    function execTransactionFromModule(\\r\\n        address to,\\r\\n        uint256 value,\\r\\n        bytes memory data,\\r\\n        Enum.Operation operation,\\r\\n        uint256 txGas\\r\\n    ) public virtual returns (bool success) {\\r\\n        // Only whitelisted modules are allowed.\\r\\n        if (\\r\\n            msg.sender == SENTINEL_MODULES || _modules[msg.sender] == address(0)\\r\\n        ) revert ModuleNotEnabled(msg.sender);\\r\\n        // Execute transaction without further confirmations.\\r\\n        // Can add guards here to allow delegatecalls for selected modules (msg.senders) only\\r\\n        success = _execute(\\r\\n            to,\\r\\n            value,\\r\\n            data,\\r\\n            operation,\\r\\n            txGas == 0 ? gasleft() : txGas\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function execTransactionFromModule(\\r\\n        address to,\\r\\n        uint256 value,\\r\\n        bytes memory data,\\r\\n        Enum.Operation operation\\r\\n    ) public virtual returns (bool) {\\r\\n        return execTransactionFromModule(to, value, data, operation, 0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows a Module to execute a wallet transaction without any further confirmations and returns data\\r\\n     * @param to Destination address of module transaction.\\r\\n     * @param value Ether value of module transaction.\\r\\n     * @param data Data payload of module transaction.\\r\\n     * @param operation Operation type of module transaction.\\r\\n     */\\r\\n    function execTransactionFromModuleReturnData(\\r\\n        address to,\\r\\n        uint256 value,\\r\\n        bytes memory data,\\r\\n        Enum.Operation operation\\r\\n    ) public returns (bool success, bytes memory returnData) {\\r\\n        success = execTransactionFromModule(to, value, data, operation);\\r\\n\\r\\n        assembly {\\r\\n            // Load free memory location\\r\\n            let ptr := mload(0x40)\\r\\n            // We allocate memory for the return data by setting the free memory location to\\r\\n            // current free memory location + data size + 32 bytes for data size value\\r\\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\\r\\n            // Store the size\\r\\n            mstore(ptr, returndatasize())\\r\\n            // Store the data\\r\\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\\r\\n            // Point the return data to the correct memory location\\r\\n            returnData := ptr\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows a Module to execute a batch of Smart Account transactions without any further confirmations.\\r\\n     * @param to Destination address of module transaction.\\r\\n     * @param value Ether value of module transaction.\\r\\n     * @param data Data payload of module transaction.\\r\\n     * @param operations Operation type of module transaction.\\r\\n     */\\r\\n    function execBatchTransactionFromModule(\\r\\n        address[] calldata to,\\r\\n        uint256[] calldata value,\\r\\n        bytes[] calldata data,\\r\\n        Enum.Operation[] calldata operations\\r\\n    ) public virtual returns (bool success) {\\r\\n        if (\\r\\n            to.length == 0 ||\\r\\n            to.length != value.length ||\\r\\n            value.length != data.length ||\\r\\n            data.length != operations.length\\r\\n        )\\r\\n            revert WrongBatchProvided(\\r\\n                to.length,\\r\\n                value.length,\\r\\n                data.length,\\r\\n                operations.length\\r\\n            );\\r\\n\\r\\n        // Only whitelisted modules are allowed.\\r\\n        if (\\r\\n            msg.sender == SENTINEL_MODULES || _modules[msg.sender] == address(0)\\r\\n        ) revert ModuleNotEnabled(msg.sender);\\r\\n\\r\\n        for (uint256 i; i < to.length; ) {\\r\\n            // Execute transaction without further confirmations.\\r\\n            success = _executeFromModule(\\r\\n                to[i],\\r\\n                value[i],\\r\\n                data[i],\\r\\n                operations[i]\\r\\n            );\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns if a module is enabled\\r\\n     * @return True if the module is enabled\\r\\n     */\\r\\n    function isModuleEnabled(address module) public view returns (bool) {\\r\\n        return SENTINEL_MODULES != module && _modules[module] != address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds a module to the allowlist.\\r\\n     * @notice This can only be done via a userOp or a selfcall.\\r\\n     * @notice Enables the module `module` for the wallet.\\r\\n     * @param module Module to be allow-listed.\\r\\n     */\\r\\n    function _enableModule(address module) internal virtual {\\r\\n        // Module address cannot be null or sentinel.\\r\\n        if (module == address(0) || module == SENTINEL_MODULES)\\r\\n            revert ModuleCannotBeZeroOrSentinel(module);\\r\\n        // Module cannot be added twice.\\r\\n        if (_modules[module] != address(0)) revert ModuleAlreadyEnabled(module);\\r\\n\\r\\n        _modules[module] = _modules[SENTINEL_MODULES];\\r\\n        _modules[SENTINEL_MODULES] = module;\\r\\n\\r\\n        emit EnabledModule(module);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Setups module for this Smart Account and enables it.\\r\\n     * @notice This can only be done via userOp or a selfcall.\\r\\n     */\\r\\n    function _setupAndEnableModule(\\r\\n        address setupContract,\\r\\n        bytes memory setupData\\r\\n    ) internal virtual returns (address) {\\r\\n        address module = _setupModule(setupContract, setupData);\\r\\n        _enableModule(module);\\r\\n        return module;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a module from the allowlist.\\r\\n     * @notice This can only be done via a wallet transaction.\\r\\n     * @notice Disables the module `module` for the wallet.\\r\\n     * @param prevModule Module that pointed to the module to be removed in the linked list\\r\\n     * @param module Module to be removed.\\r\\n     */\\r\\n    function _disableModule(\\r\\n        address prevModule,\\r\\n        address module\\r\\n    ) internal virtual {\\r\\n        // Validate module address and check that it corresponds to module index.\\r\\n        if (module == address(0) || module == SENTINEL_MODULES)\\r\\n            revert ModuleCannotBeZeroOrSentinel(module);\\r\\n        if (_modules[prevModule] != module)\\r\\n            revert ModuleAndPrevModuleMismatch(\\r\\n                module,\\r\\n                _modules[prevModule],\\r\\n                prevModule\\r\\n            );\\r\\n        _modules[prevModule] = _modules[module];\\r\\n        delete _modules[module];\\r\\n        emit DisabledModule(module);\\r\\n    }\\r\\n\\r\\n    // TODO: can use not executor.execute, but SmartAccount._call for the unification\\r\\n\\r\\n    function _executeFromModule(\\r\\n        address to,\\r\\n        uint256 value,\\r\\n        bytes memory data,\\r\\n        Enum.Operation operation\\r\\n    ) internal returns (bool success) {\\r\\n        success = _execute(to, value, data, operation, gasleft());\\r\\n        if (success) {\\r\\n            emit ModuleTransaction(msg.sender, to, value, data, operation);\\r\\n            emit ExecutionFromModuleSuccess(msg.sender);\\r\\n        } else emit ExecutionFromModuleFailure(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Setup function sets the initial storage of the contract.\\r\\n     * @param setupContract initializing the auth module; can be a module factory or a registry for multiple accounts.\\r\\n     * @param setupData modules setup data (a standard calldata for the module setup contract)\\r\\n     */\\r\\n    function _initialSetupModules(\\r\\n        address setupContract,\\r\\n        bytes memory setupData\\r\\n    ) internal virtual returns (address) {\\r\\n        address initialAuthorizationModule = _setupModule(\\r\\n            setupContract,\\r\\n            setupData\\r\\n        );\\r\\n\\r\\n        // Module address cannot be null or sentinel.\\r\\n        if (\\r\\n            initialAuthorizationModule == address(0) ||\\r\\n            initialAuthorizationModule == SENTINEL_MODULES\\r\\n        ) revert ModuleCannotBeZeroOrSentinel(initialAuthorizationModule);\\r\\n\\r\\n        _modules[initialAuthorizationModule] = SENTINEL_MODULES;\\r\\n        _modules[SENTINEL_MODULES] = initialAuthorizationModule;\\r\\n        return initialAuthorizationModule;\\r\\n    }\\r\\n\\r\\n    function _setupModule(\\r\\n        address setupContract,\\r\\n        bytes memory setupData\\r\\n    ) internal returns (address module) {\\r\\n        if (setupContract == address(0)) revert(\\\"Wrong Module Setup Address\\\");\\r\\n        assembly {\\r\\n            let success := call(\\r\\n                gas(),\\r\\n                setupContract,\\r\\n                0,\\r\\n                add(setupData, 0x20),\\r\\n                mload(setupData),\\r\\n                0,\\r\\n                0\\r\\n            )\\r\\n            let ptr := mload(0x40)\\r\\n            returndatacopy(ptr, 0, returndatasize())\\r\\n            if iszero(success) {\\r\\n                revert(ptr, returndatasize())\\r\\n            }\\r\\n            module := mload(ptr)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x4209e17f016c6d952138a0def75017f07a934ba35d98e3b793e1dc00fedcf91a\",\"license\":\"LGPL-3.0-only\"},\"contracts/smart-account/common/Enum.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/// @title Enum - Collection of enums\\r\\nabstract contract Enum {\\r\\n    enum Operation {\\r\\n        Call,\\r\\n        DelegateCall\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xd698e9e2472532343ca89edcb08b2a545c04d88bbf6972676d783f13ed70c36b\",\"license\":\"LGPL-3.0-only\"},\"contracts/smart-account/common/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ncontract BaseSmartAccountErrors {\\r\\n    /**\\r\\n     * @notice Throws at onlyEntryPoint when msg.sender is not an EntryPoint set for this Smart Account\\r\\n     * @param caller address that tried to call onlyEntryPoint-protected method\\r\\n     */\\r\\n    error CallerIsNotAnEntryPoint(address caller);\\r\\n}\\r\\n\\r\\ncontract FallbackManagerErrors {\\r\\n    /**\\r\\n     * @notice Throws if zero address has been provided as Fallback Handler address\\r\\n     */\\r\\n    error HandlerCannotBeZero();\\r\\n}\\r\\n\\r\\ncontract ModuleManagerErrors {\\r\\n    /**\\r\\n     * @notice Throws when trying to initialize module manager that already been initialized\\r\\n     */\\r\\n    error ModulesAlreadyInitialized();\\r\\n\\r\\n    /**\\r\\n     * @notice Throws when a delegatecall in course of module manager initialization has failed\\r\\n     */\\r\\n    error ModulesSetupExecutionFailed();\\r\\n\\r\\n    /**\\r\\n     * @notice Throws when address(0) or SENTINEL_MODULES constant has been provided as a module address\\r\\n     * @param module Module address provided\\r\\n     */\\r\\n    error ModuleCannotBeZeroOrSentinel(address module);\\r\\n\\r\\n    /**\\r\\n     * @notice Throws when trying to enable module that has already been enabled\\r\\n     * @param module Module address provided\\r\\n     */\\r\\n    error ModuleAlreadyEnabled(address module);\\r\\n\\r\\n    /**\\r\\n     * @notice Throws when module and previous module mismatch\\r\\n     * @param expectedModule expected module at modules[prevModule]\\r\\n     * @param returnedModule the module that has been found at modules[prevModule]\\r\\n     * @param prevModule previous module address provided at call\\r\\n     */\\r\\n    error ModuleAndPrevModuleMismatch(\\r\\n        address expectedModule,\\r\\n        address returnedModule,\\r\\n        address prevModule\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Throws when trying to execute transaction from module that is not enabled\\r\\n     * @param module Module address provided\\r\\n     */\\r\\n    error ModuleNotEnabled(address module);\\r\\n\\r\\n    /**\\r\\n     * @notice Throws when data for executeBatchCall provided in wrong format (i.e. empty array or lengths mismatch)\\r\\n     * @param destLength length of destination contracts array\\r\\n     * @param valueLength length of txn values array\\r\\n     * @param funcLength length of function signatures array\\r\\n     * @param operationLength length of operation types array. 0 if there's no operations\\r\\n     */\\r\\n    error WrongBatchProvided(\\r\\n        uint256 destLength,\\r\\n        uint256 valueLength,\\r\\n        uint256 funcLength,\\r\\n        uint256 operationLength\\r\\n    );\\r\\n}\\r\\n\\r\\ncontract SmartAccountErrors is BaseSmartAccountErrors, ModuleManagerErrors {\\r\\n    /**\\r\\n     * @notice Throws if zero address has been provided as Entry Point address\\r\\n     */\\r\\n    error EntryPointCannotBeZero();\\r\\n\\r\\n    /**\\r\\n     * @notice Throws at mixedAuth when msg.sender is not an owner neither _self\\r\\n     * @param caller address that tried to call mixedAuth-protected method\\r\\n     */\\r\\n    error MixedAuthFail(address caller);\\r\\n\\r\\n    /**\\r\\n     * @notice Throws if trying to change an owner of a SmartAccount to the zero address\\r\\n     */\\r\\n    error OwnerCannotBeZero();\\r\\n\\r\\n    /**\\r\\n     * @notice Throws if zero address has been provided as Base Implementation address\\r\\n     */\\r\\n    error BaseImplementationCannotBeZero();\\r\\n\\r\\n    /**\\r\\n     * @notice Throws if there is no code at implementationAddress\\r\\n     * @param implementationAddress implementation address provided\\r\\n     */\\r\\n    error InvalidImplementation(address implementationAddress);\\r\\n\\r\\n    /**\\r\\n     * @notice Throws at onlyOwner when msg.sender is not an owner\\r\\n     * @param caller address that tried to call onlyOwner method\\r\\n     */\\r\\n    error CallerIsNotOwner(address caller);\\r\\n\\r\\n    /**\\r\\n     * @notice Throws at _requireFromEntryPointOrOwner when msg.sender is not an EntryPoint neither an owner\\r\\n     * @param caller address that tried to call _requireFromEntryPointOrOwner-protected method\\r\\n     */\\r\\n    error CallerIsNotEntryPointOrOwner(address caller);\\r\\n\\r\\n    /**\\r\\n     * @notice Throws at _requireFromEntryPointOrSelf when msg.sender is not an EntryPoint neither self\\r\\n     * @param caller address that tried to call _requireFromEntryPointOrSelf-protected method\\r\\n     */\\r\\n    error CallerIsNotEntryPointOrSelf(address caller);\\r\\n\\r\\n    /**\\r\\n     * @notice Throws at _requireFromEntryPoint when msg.sender is not an EntryPoint\\r\\n     * @param caller address that tried to call _requireFromEntryPoint-protected method\\r\\n     */\\r\\n    error CallerIsNotEntryPoint(address caller);\\r\\n\\r\\n    /**\\r\\n     * @notice Throws if trying to initialize a Smart Account that has already been initialized\\r\\n     */\\r\\n    error AlreadyInitialized();\\r\\n\\r\\n    /**\\r\\n     * @notice Throws if contract signature is provided in frong format\\r\\n     * @param uintS s converted to uint256\\r\\n     * @param contractSignatureLength length of a contract signature\\r\\n     * @param signatureLength the whole signature length\\r\\n     */\\r\\n    error WrongContractSignatureFormat(\\r\\n        uint256 uintS,\\r\\n        uint256 contractSignatureLength,\\r\\n        uint256 signatureLength\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Throws if isValidSignature for the conrtact signature and data hash differs from EIP1271 Magic Value\\r\\n     * @param contractSignature the contract signature that has been verified\\r\\n     */\\r\\n    error WrongContractSignature(bytes contractSignature);\\r\\n\\r\\n    /**\\r\\n     * @notice Throws when if trying to transfer to zero address\\r\\n     */\\r\\n    error TransferToZeroAddressAttempt();\\r\\n\\r\\n    /**\\r\\n     * @notice Throws when module address taken from signature is not enabled\\r\\n     * @param moduleAddressProvided module address taken from signature\\r\\n     */\\r\\n    error WrongValidationModule(address moduleAddressProvided);\\r\\n\\r\\n    /**\\r\\n     * @notice Thrown when the function that must be called only via delegatecall is called directly\\r\\n     */\\r\\n    error DelegateCallsOnly();\\r\\n\\r\\n    /**\\r\\n     * @notice Thrown when trying to use address of the Smart Account as an owner for itself\\r\\n     */\\r\\n    error OwnerCanNotBeSelf();\\r\\n\\r\\n    /**\\r\\n     * @notice Thrown when trying to use current owner as a new owner in a _setOwner() call\\r\\n     */\\r\\n    error OwnerProvidedIsSame();\\r\\n}\\r\\n\\r\\ncontract SmartAccountFactoryErrors is SmartAccountErrors {\\r\\n    /**\\r\\n     * @notice Throws when the new Proxy deployment fails\\r\\n     * @param owner Owner of a Proxy (Smart Account)\\r\\n     * @param index Deployment index\\r\\n     */\\r\\n    error ProxyDeploymentFailed(address owner, uint256 index);\\r\\n}\\r\\n\\r\\ncontract SelfAuthorizedErrors {\\r\\n    /**\\r\\n     * @notice Throws when the caller is not address(this)\\r\\n     * @param caller Caller address\\r\\n     */\\r\\n    error CallerIsNotSelf(address caller);\\r\\n}\\r\\n\\r\\ncontract SingletonPaymasterErrors {\\r\\n    /**\\r\\n     * @notice Throws when the Entrypoint address provided is address(0)\\r\\n     */\\r\\n    error EntryPointCannotBeZero();\\r\\n\\r\\n    /**\\r\\n     * @notice Throws when the verifiying signer address provided is address(0)\\r\\n     */\\r\\n    error VerifyingSignerCannotBeZero();\\r\\n\\r\\n    /**\\r\\n     * @notice Throws when the paymaster address provided is address(0)\\r\\n     */\\r\\n    error PaymasterIdCannotBeZero();\\r\\n\\r\\n    /**\\r\\n     * @notice Throws when the 0 has been provided as deposit\\r\\n     */\\r\\n    error DepositCanNotBeZero();\\r\\n\\r\\n    /**\\r\\n     * @notice Throws when trying to withdraw to address(0)\\r\\n     */\\r\\n    error CanNotWithdrawToZeroAddress();\\r\\n\\r\\n    /**\\r\\n     * @notice Throws when trying to withdraw more than balance available\\r\\n     * @param amountRequired required balance\\r\\n     * @param currentBalance available balance\\r\\n     */\\r\\n    error InsufficientBalance(uint256 amountRequired, uint256 currentBalance);\\r\\n\\r\\n    /**\\r\\n     * @notice Throws when signature provided has invalid length\\r\\n     * @param sigLength length oif the signature provided\\r\\n     */\\r\\n    error InvalidPaymasterSignatureLength(uint256 sigLength);\\r\\n}\\r\\n\\r\\n//\\r\\n\",\"keccak256\":\"0x66a111ac7755f3f2efb6146c650bdb21ecc2d925b3ac9e3b8966f63ccdb219da\",\"license\":\"LGPL-3.0-only\"},\"contracts/smart-account/common/SelfAuthorized.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport {SelfAuthorizedErrors} from \\\"../common/Errors.sol\\\";\\r\\n\\r\\n/// @title SelfAuthorized - authorizes current contract to perform actions\\r\\ncontract SelfAuthorized is SelfAuthorizedErrors {\\r\\n    modifier authorized() {\\r\\n        // This is a function call as it minimized the bytecode size\\r\\n        _requireSelfCall();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _requireSelfCall() private view {\\r\\n        if (msg.sender != address(this)) revert CallerIsNotSelf(msg.sender);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xa0635e3eecdc565e8c7d5410ff96ce8502079d1491a5e5e2ff44b7155543bcd1\",\"license\":\"LGPL-3.0-only\"},\"contracts/smart-account/interfaces/IAuthorizationModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\nimport {UserOperation} from \\\"@account-abstraction/contracts/interfaces/UserOperation.sol\\\";\\r\\n\\r\\n// interface for modules to verify singatures signed over userOpHash\\r\\ninterface IAuthorizationModule {\\r\\n    function validateUserOp(\\r\\n        UserOperation calldata userOp,\\r\\n        bytes32 userOpHash\\r\\n    ) external returns (uint256 validationData);\\r\\n}\\r\\n\",\"keccak256\":\"0x9a1e3f0f381edef142edcb3eb1dcab1f032bb2b68728f4ee22824d79137dd053\",\"license\":\"MIT\"},\"contracts/smart-account/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0xd688092f2fb09da9d545a96b3b443dc446f390ab4007ae65b1c437222e994e22\",\"license\":\"LGPL-3.0-only\"},\"contracts/smart-account/interfaces/ISignatureValidator.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ncontract ISignatureValidatorConstants {\\r\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\r\\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\\r\\n}\\r\\n\\r\\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\\r\\n    /**\\r\\n     * @dev Should return whether the signature provided is valid for the provided data\\r\\n     * @param _dataHash Arbitrary length data signed on behalf of address(this)\\r\\n     * @param _signature Signature byte array associated with _data\\r\\n     *\\r\\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\\r\\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\\r\\n     * MUST allow external calls\\r\\n     */\\r\\n    function isValidSignature(\\r\\n        bytes32 _dataHash,\\r\\n        bytes memory _signature\\r\\n    ) public view virtual returns (bytes4);\\r\\n}\\r\\n\",\"keccak256\":\"0xec3122bd8aef8b72f764a3f55af5b730965bb48fb095aa2fb351324ceaef3b9c\",\"license\":\"LGPL-3.0-only\"},\"contracts/smart-account/libs/LibAddress.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nlibrary LibAddress {\\r\\n    /**\\r\\n     * @notice Will return true if provided address is a contract\\r\\n     * @param account Address to verify if contract or not\\r\\n     * @dev This contract will return false if called within the constructor of\\r\\n     *      a contract's deployment, as the code is not yet stored on-chain.\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        uint256 csize;\\r\\n\\r\\n        assembly {\\r\\n            csize := extcodesize(account)\\r\\n        }\\r\\n        return csize != 0;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x589c99fec96eb541e63782604eea5b73672c8f3a6e1050a586a92dbe5dc7b219\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c0346100fc57601f61214d38819003918201601f19168301916001600160401b03831184841017610101578084926020946040528339810103126100fc57516001600160a01b0381168082036100fc573060a052156100ea57608052600160008181526020527fada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d80546001600160a01b03191690911790556040516120359081610118823960805181818161080e01528181610a0501528181610aa601528181610dc401528181610e1701528181611041015281816118c0015261191b015260a051816114620152f35b60405163091748f960e21b8152600490fd5b600080fd5b634e487b7160e01b600052604160045260246000fdfe60806040526004361015610030575b361561002857346100235761002161195b565b005b600080fd5b610021611458565b60003560e01c8061189a146101bc57806146801461021f57806301ffc9a71461025e578063025b22bc146102555780631626ba7e1461024c57806321632045146102435780632d9ad53d1461023a5780633a871cdd14610231578063468721a71461022857806347e1da2a1461021f5780634a58db19146102165780634d44560d1461020d5780635229073f146102045780635305dd27146101fb578063610b5925146101f25780636424e9fe146101e9578063856dfd99146101e0578063aaf10f42146101d7578063acfdf503146101ce578063b0d691fe146101c5578063b61d27f6146101bc578063c399ec88146101b3578063cc2f8452146101aa578063d86f2b3c146101a1578063dfdfbd0b14610198578063e009cfde1461018f578063f08a032314610186578063f33623b11461017d5763ffa1ad740361000e576101786113be565b61000e565b50610178611391565b50610178611363565b506101786111ab565b506101786110af565b50610178610fdd565b50610178610edb565b50610178610de8565b506101786102b3565b50610178610da3565b50610178610d00565b50610178610cd9565b50610178610c92565b50610178610c6a565b50610178610c3c565b50610178610bd0565b50610178610b4e565b50610178610a77565b506101786109ed565b50610178610342565b5061017861099f565b506101786107c8565b5061017861076a565b506101786106ab565b5061017861064f565b5061017861049d565b50610178610461565b6001600160a01b0381160361002357565b359061028382610267565b565b9181601f840112156100235782359167ffffffffffffffff8311610023576020838186019501011161002357565b5034610023576060366003190112610023576004356102d181610267565b6044359067ffffffffffffffff8211610023576103076102f8610021933690600401610285565b610300611911565b36916105fa565b9060243590611892565b9181601f840112156100235782359167ffffffffffffffff8311610023576020808501948460051b01011161002357565b50346100235760603660031901126100235767ffffffffffffffff60043581811161002357610375903690600401610311565b906024358381116100235761038e903690600401610311565b93604435908111610023576103a7903690600401610311565b926103b0611911565b84158015610445575b801561043b575b61040f5760005b8581106103d057005b806104096103e96103e46001948a876116ca565b6116e8565b6103f4838b896116ca565b35610403610300858b8a6116f2565b91611892565b016103c7565b5050506084926040519263470c355760e01b845260048401526024830152604482015260006064820152fd5b50838614156103c0565b50858514156103b9565b6001600160e01b031981160361002357565b50346100235760203660031901126100235760206004356104818161044f565b6040516001600160e01b03199091166301ffc9a760e01b148152f35b5034610023576020366003190112610023576004356104bb81610267565b6104c36118b6565b6001600160a01b0380821691821561053057803b15610509573054903055167faa3f731066a578e5f39b4215468d826cdd15373cbc0dfc9cb9bdc649718ef7da600080a3005b604051630c76093760e01b81526001600160a01b03919091166004820152602490fd5b0390fd5b60405162461bcd60e51b815260206004820152601660248201527f416464726573732063616e6e6f74206265207a65726f000000000000000000006044820152606490fd5b50634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff81116105a057604052565b6105a8610575565b604052565b90601f8019910116810190811067ffffffffffffffff8211176105a057604052565b60209067ffffffffffffffff81116105ed575b601f01601f19160190565b6105f5610575565b6105e2565b929192610606826105cf565b9161061460405193846105ad565b829481845281830111610023578281602093846000960137010152565b9080601f830112156100235781602061064c933591016105fa565b90565b50346100235760403660031901126100235760243567ffffffffffffffff81116100235761068e6106866020923690600401610631565b6004356117b9565b6040516001600160e01b03199091168152f35b6002111561002357565b50346100235760a0366003190112610023576004356106c981610267565b60443567ffffffffffffffff8111610023576106e9903690600401610631565b90606435906106f7826106a1565b6084359160013314801561074b575b61073357602093610723938061072d57505a925b60243590611adf565b6040519015158152f35b9261071a565b6040516321ac7c5f60e01b8152336004820152602490fd5b503360005260006020526001600160a01b036040600020541615610706565b503461002357602036600319011261002357602060043561078a81610267565b6001600160a01b0380911690816001141591826107ae575b50506040519015158152f35b9091506000526000825260406000205416151538806107a2565b503461002357600319606036820112610023576004359067ffffffffffffffff82116100235761016082600401918336030112610023576000906001600160a01b0392837f000000000000000000000000000000000000000000000000000000000000000016330361093e5761084e610846610144869301846114c2565b8101906114f5565b9050169261087f610872856001600160a01b03166000526000602052604060002090565b546001600160a01b031690565b161561091d5760206108b06108de948493604051948580948193637ff9adb960e11b8352602435906004840161157f565b03925af1918215610910575b916108e2575b506108ce604435611676565b6040519081529081906020820190565b0390f35b610903915060203d8111610909575b6108fb81836105ad565b81019061143c565b386108c2565b503d6108f1565b61091861144b565b6108bc565b6040516326cc3fab60e21b81526001600160a01b0384166004820152602490fd5b604051635dac3db760e11b8152336004820152602490fd5b60806003198201126100235760043561096e81610267565b91602435916044359067ffffffffffffffff82116100235761099291600401610631565b9060643561064c816106a1565b5034610023576109ae36610956565b6001939193331480156109ce575b61073357602093610723935a93611adf565b503360005260006020526001600160a01b0360406000205416156109bc565b50600080600319360112610a74576001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001681813b15610a745760405163b760faf960e01b8152306004820152918290602490829034905af18015610a67575b610a5b575080f35b610a649061058c565b80f35b610a6f61144b565b610a53565b80fd5b5060006040366003190112610a7457600435610a9281610267565b610a9a6118b6565b816001600160a01b03807f00000000000000000000000000000000000000000000000000000000000000001692833b15610b025760449083604051958694859363040b850f60e31b855216600484015260243560248401525af18015610a6757610a5b575080f35b8280fd5b60005b838110610b195750506000910152565b8181015183820152602001610b09565b90602091610b4281518092818552858086019101610b06565b601f01601f1916010190565b503461002357610b5d36610956565b90600193929333148015610bb1575b61073357610b7b935a93611adf565b6040519060203d8301016040523d82523d6000602084013e6108de60405192839215158352604060208401526040830190610b29565b503360005260006020526001600160a01b036040600020541615610b6c565b503461002357604036600319011261002357600435610bee81610267565b60243567ffffffffffffffff811161002357602091610c14610c22923690600401610631565b90610c1d6118b6565b611f89565b610c2b81611ced565b6001600160a01b0360405191168152f35b503461002357602036600319011261002357610021600435610c5d81610267565b610c656118b6565b611ced565b50346100235760003660031901126100235760206001600160a01b0360315416604051908152f35b50346100235760003660031901126100235760207f6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d4546001600160a01b0360405191168152f35b503461002357600036600319011261002357602030546001600160a01b0360405191168152f35b50346100235760803660031901126100235767ffffffffffffffff60043581811161002357610d33903690600401610311565b60249291923582811161002357610d4e903690600401610311565b60449491943584811161002357610d69903690600401610311565b91606435958611610023576108de96610d89610d91973690600401610311565b969095611ba7565b60405190151581529081906020820190565b50346100235760003660031901126100235760206040516001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152f35b5034610023576000366003190112610023576040516370a0823160e01b815230600482015260209081816024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa908115610e77575b600091610e5a575b50604051908152f35b610e719150823d8111610909576108fb81836105ad565b38610e51565b610e7f61144b565b610e49565b90929192604082016040835281518091526060830160208093019160005b84828210610ebe575050506001600160a01b0391509416910152565b84516001600160a01b031684529384019390920191600101610ea2565b503461002357604036600319011261002357600435610ef981610267565b602435610f0581611a1b565b610f1260405191826105ad565b818152601f19610f2183611a1b565b01366020830137610f4a6108726000946001600160a01b03166000526000602052604060002090565b6001600160a01b0381168015159081610fd1575b5080610fc8575b15610fb557610fa961087282610f90610faf94610f828988611a3c565b906001600160a01b03169052565b6001600160a01b03166000526000602052604060002090565b93611a5e565b92610f4a565b908381526108de60405192839283610e84565b50828410610f65565b60019150141538610f5e565b50346100235760203660031901126100235760043577ffffffffffffffffffffffffffffffffffffffffffffffff8116809103610023576108de9060405190631aab3f0d60e11b825230600483015260248201526020816044816001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000165afa9081156110a2575b600091611084575b506040519081529081906020820190565b61109c915060203d8111610909576108fb81836105ad565b38611073565b6110aa61144b565b61106b565b5034610023576080366003190112610023576004356110cd81610267565b6024356110d981610267565b6044356110e581610267565b60643567ffffffffffffffff811161002357611105903690600401610285565b9091600160005260006020526001600160a01b038060406000205416159081159161117e575b5061116d576111476111539361114d936103006108de986119a9565b90611eff565b91611ced565b6040516001600160a01b0390911681529081906020820190565b60405162dc149f60e41b8152600490fd5b90507f6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d4541615153861112b565b5034610023576040366003190112610023576004356111c981610267565b6024356111d581610267565b6111dd6118b6565b6001600160a01b03811680158015611359575b61133857611223611217610872856001600160a01b03166000526000602052604060002090565b6001600160a01b031690565b036112de57806112a97faab4fa2b463f581b2b32cb3b7e3b704b9ce37cc209b5fb4d77e593ace40542769361128e6112746108726112d9966001600160a01b03166000526000602052604060002090565b916001600160a01b03166000526000602052604060002090565b906001600160a01b03166001600160a01b0319825416179055565b6111536112c9826001600160a01b03166000526000602052604060002090565b6001600160a01b03198154169055565b0390a1005b61052c611301610872846001600160a01b03166000526000602052604060002090565b604051633103525b60e21b81526001600160a01b039384166004820152908316602482015292909116604483015281906064820190565b60405163cadb248f60e01b81526001600160a01b0383166004820152602490fd5b50600181146111f0565b50346100235760203660031901126100235761002160043561138481610267565b61138c6118b6565b6119a9565b50346100235760203660031901126100235760043560005260326020526020604060002054604051908152f35b5034610023576000366003190112610023576108de6040516040810181811067ffffffffffffffff82111761142f575b604052600581527f322e302e300000000000000000000000000000000000000000000000000000006020820152604051918291602083526020830190610b29565b611437610575565b6113ee565b90816020910312610023575190565b506040513d6000823e3d90fd5b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001630146114b05734337ed05ab44e279ac59e855cb75dc2ae23b200ad994797b6f1f028f96a46ecce02600080a3565b604051633c97166560e21b8152600490fd5b903590601e1981360301821215610023570180359067ffffffffffffffff82116100235760200191813603831361002357565b919060408382031261002357823567ffffffffffffffff811161002357602091611520918501610631565b92013561064c81610267565b9035601e198236030181121561002357016020813591019167ffffffffffffffff821161002357813603831361002357565b908060209392818452848401376000828201840152601f01601f1916010190565b9291906116716115dc602092604087526115ac6040880161159f83610278565b6001600160a01b03169052565b8381013560608801526116616115c5604083018361152c565b9390610160948560808c01526101a08b019161155e565b916116586116046115f0606084018461152c565b603f198d8803810160a08f0152969161155e565b608083013560c08c015260a083013560e08c01528a6101009660c08501358883015261164861012060e087013581850152610140998701358a85015286018661152c565b929091888286030191015261155e565b9381019061152c565b918884030161018089015261155e565b930152565b8061167e5750565b600080808093338219f1503d15610283573d611699816105cf565b906116a760405192836105ad565b8152600060203d92013e565b50634e487b7160e01b600052603260045260246000fd5b91908110156116db575b60051b0190565b6116e36116b3565b6116d4565b3561064c81610267565b909161170b9281101561170f575b60051b8101906114c2565b9091565b6117176116b3565b611700565b919060408382031261002357825167ffffffffffffffff81116100235783019080601f8301121561002357815191611753836105cf565b9161176160405193846105ad565b838352602084830101116100235760209261178191848085019101610b06565b92015161064c81610267565b90816020910312610023575161064c8161044f565b60409061064c939281528160208201520190610b29565b906117cd906020808251830101910161171c565b90916001600160a01b03809216916117fb610872846001600160a01b03166000526000602052604060002090565b1615611871579160209161182593604051809581948293630b135d3f60e11b8452600484016117a2565b03915afa908115611864575b60009161183c575090565b61064c915060203d811161185d575b61185581836105ad565b81019061178d565b503d61184b565b61186c61144b565b611831565b6040516326cc3fab60e21b81526001600160a01b0383166004820152602490fd5b916000928392602083519301915af1604051903d6000833e156118b25750565b3d90fd5b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001633141580611907575b6118ef57565b604051634776242160e01b8152336004820152602490fd5b50303314156118e9565b6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016330361194357565b60405163e6fce6a560e01b8152336004820152602490fd5b507f6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d4548015610021576000808092368280373360601b3652818060143601925af13d82803e156118b2573d90f35b6001600160a01b03808216918215611a09577f6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d49081549155167f06be9a1bea257286cf2afa8205ed494ca9d6a4b41aa58d04238deebada20fb0c600080a3565b60405163dd449f5f60e01b8152600490fd5b60209067ffffffffffffffff8111611a345760051b0190565b6116e3610575565b6020918151811015611a51575b60051b010190565b611a596116b3565b611a49565b6000198114611a6d5760010190565b634e487b7160e01b600052601160045260246000fd5b611a9b90602060405192828480945193849201610b06565b810103902090565b906002821015611ab05752565b634e487b7160e01b600052602160045260246000fd5b60209093929193611adb816040810196611aa3565b0152565b9493929091946002821015611ab05760018203611b8a576000808751602089018488f4955b8615611b54577f81d12fffced46c214dfae8ab8fa0b9f7b69f70c9d500e33f612f2105deb261ee91611b4f611b406001600160a01b0393611a83565b96604051938493169583611ac6565b0390a4565b7f3ddd038f78c876172d5dbfd730b14c9f8692dfa197ef104eaac6df3f85a0874a91611b4f611b406001600160a01b0393611a83565b600080875160208901868589f195611b04565b3561064c816106a1565b9497969391929795909560009887158015611ce3575b8015611cd9575b8015611ccf575b611ca0576001978833148015611c70575b6107335797969594939291906000985b808a10611bff5750505050505050505050565b9091929394959697899b50611c60888888611c5a89869f8f81611c45818e611c3e8f968f97611c386103e483611c529b611c4d9b6116ca565b9c6116ca565b35986116f2565b9890946116ca565b611b9d565b9436916105fa565b91611e30565b9b01989796959493929190611bec565b506001600160a01b03611c99610872336001600160a01b03166000526000602052604060002090565b1615611bdc565b60405163470c355760e01b81526004810189905260248101919091526044810182905260648101869052608490fd5b5085821415611bcb565b5081811415611bc4565b5080881415611bbd565b6001600160a01b0381168015908115611e25575b50611e0257611d29611217610872836001600160a01b03166000526000602052604060002090565b611ddf57600160009081526020527fecdf3a3effea5783a3c4c2140e677577666428d44ed9d474a0b3a4c9943f844090611dda90611da6611d897fada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d610872565b61128e836001600160a01b03166000526000602052604060002090565b60016000908152602052611153817fada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d61128e565b0390a1565b60405163b29d459560e01b81526001600160a01b03919091166004820152602490fd5b60405163cadb248f60e01b81526001600160a01b03919091166004820152602490fd5b600191501438611d01565b939293611e405a86858585611adf565b948515611ed357611ea8611e9d7f8c014e41cffd68ba64f3e7830b8b2e4ee860509d8deab25ebbcbba2f0405e2da956001600160a01b0395604051968796338852166020870152604086015260a0606086015260a0850190610b29565b916080840190611aa3565b0390a1337f6895c13664aa4f67288b25d7a21d7aaa34916e355fb9b6fae0a139a9085becb8600080a2565b50505050337facd2c8702804128fdb0db2bb49f6d127dd0181c13fd45dbfe16de0930e2bd375600080a2565b90611f0991611f89565b6001600160a01b03811680158015611f7f575b611f67576000526000602052604060002060016001600160a01b0319825416179055600160005261064c816040600020906001600160a01b03166001600160a01b0319825416179055565b6024906040519063cadb248f60e01b82526004820152fd5b5060018114611f1c565b6001600160a01b03811615611fba5781600092918360208194519301915af1604051903d6000833e156118b2575190565b60405162461bcd60e51b815260206004820152601a60248201527f57726f6e67204d6f64756c6520536574757020416464726573730000000000006044820152606490fdfea2646970667358221220cff3a3a36f2f0d3a69e555a32683ff2559d10b0b07d83682045d7528ff80c58e64736f6c63430008110033",
  "deployedBytecode": "0x60806040526004361015610030575b361561002857346100235761002161195b565b005b600080fd5b610021611458565b60003560e01c8061189a146101bc57806146801461021f57806301ffc9a71461025e578063025b22bc146102555780631626ba7e1461024c57806321632045146102435780632d9ad53d1461023a5780633a871cdd14610231578063468721a71461022857806347e1da2a1461021f5780634a58db19146102165780634d44560d1461020d5780635229073f146102045780635305dd27146101fb578063610b5925146101f25780636424e9fe146101e9578063856dfd99146101e0578063aaf10f42146101d7578063acfdf503146101ce578063b0d691fe146101c5578063b61d27f6146101bc578063c399ec88146101b3578063cc2f8452146101aa578063d86f2b3c146101a1578063dfdfbd0b14610198578063e009cfde1461018f578063f08a032314610186578063f33623b11461017d5763ffa1ad740361000e576101786113be565b61000e565b50610178611391565b50610178611363565b506101786111ab565b506101786110af565b50610178610fdd565b50610178610edb565b50610178610de8565b506101786102b3565b50610178610da3565b50610178610d00565b50610178610cd9565b50610178610c92565b50610178610c6a565b50610178610c3c565b50610178610bd0565b50610178610b4e565b50610178610a77565b506101786109ed565b50610178610342565b5061017861099f565b506101786107c8565b5061017861076a565b506101786106ab565b5061017861064f565b5061017861049d565b50610178610461565b6001600160a01b0381160361002357565b359061028382610267565b565b9181601f840112156100235782359167ffffffffffffffff8311610023576020838186019501011161002357565b5034610023576060366003190112610023576004356102d181610267565b6044359067ffffffffffffffff8211610023576103076102f8610021933690600401610285565b610300611911565b36916105fa565b9060243590611892565b9181601f840112156100235782359167ffffffffffffffff8311610023576020808501948460051b01011161002357565b50346100235760603660031901126100235767ffffffffffffffff60043581811161002357610375903690600401610311565b906024358381116100235761038e903690600401610311565b93604435908111610023576103a7903690600401610311565b926103b0611911565b84158015610445575b801561043b575b61040f5760005b8581106103d057005b806104096103e96103e46001948a876116ca565b6116e8565b6103f4838b896116ca565b35610403610300858b8a6116f2565b91611892565b016103c7565b5050506084926040519263470c355760e01b845260048401526024830152604482015260006064820152fd5b50838614156103c0565b50858514156103b9565b6001600160e01b031981160361002357565b50346100235760203660031901126100235760206004356104818161044f565b6040516001600160e01b03199091166301ffc9a760e01b148152f35b5034610023576020366003190112610023576004356104bb81610267565b6104c36118b6565b6001600160a01b0380821691821561053057803b15610509573054903055167faa3f731066a578e5f39b4215468d826cdd15373cbc0dfc9cb9bdc649718ef7da600080a3005b604051630c76093760e01b81526001600160a01b03919091166004820152602490fd5b0390fd5b60405162461bcd60e51b815260206004820152601660248201527f416464726573732063616e6e6f74206265207a65726f000000000000000000006044820152606490fd5b50634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff81116105a057604052565b6105a8610575565b604052565b90601f8019910116810190811067ffffffffffffffff8211176105a057604052565b60209067ffffffffffffffff81116105ed575b601f01601f19160190565b6105f5610575565b6105e2565b929192610606826105cf565b9161061460405193846105ad565b829481845281830111610023578281602093846000960137010152565b9080601f830112156100235781602061064c933591016105fa565b90565b50346100235760403660031901126100235760243567ffffffffffffffff81116100235761068e6106866020923690600401610631565b6004356117b9565b6040516001600160e01b03199091168152f35b6002111561002357565b50346100235760a0366003190112610023576004356106c981610267565b60443567ffffffffffffffff8111610023576106e9903690600401610631565b90606435906106f7826106a1565b6084359160013314801561074b575b61073357602093610723938061072d57505a925b60243590611adf565b6040519015158152f35b9261071a565b6040516321ac7c5f60e01b8152336004820152602490fd5b503360005260006020526001600160a01b036040600020541615610706565b503461002357602036600319011261002357602060043561078a81610267565b6001600160a01b0380911690816001141591826107ae575b50506040519015158152f35b9091506000526000825260406000205416151538806107a2565b503461002357600319606036820112610023576004359067ffffffffffffffff82116100235761016082600401918336030112610023576000906001600160a01b0392837f000000000000000000000000000000000000000000000000000000000000000016330361093e5761084e610846610144869301846114c2565b8101906114f5565b9050169261087f610872856001600160a01b03166000526000602052604060002090565b546001600160a01b031690565b161561091d5760206108b06108de948493604051948580948193637ff9adb960e11b8352602435906004840161157f565b03925af1918215610910575b916108e2575b506108ce604435611676565b6040519081529081906020820190565b0390f35b610903915060203d8111610909575b6108fb81836105ad565b81019061143c565b386108c2565b503d6108f1565b61091861144b565b6108bc565b6040516326cc3fab60e21b81526001600160a01b0384166004820152602490fd5b604051635dac3db760e11b8152336004820152602490fd5b60806003198201126100235760043561096e81610267565b91602435916044359067ffffffffffffffff82116100235761099291600401610631565b9060643561064c816106a1565b5034610023576109ae36610956565b6001939193331480156109ce575b61073357602093610723935a93611adf565b503360005260006020526001600160a01b0360406000205416156109bc565b50600080600319360112610a74576001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001681813b15610a745760405163b760faf960e01b8152306004820152918290602490829034905af18015610a67575b610a5b575080f35b610a649061058c565b80f35b610a6f61144b565b610a53565b80fd5b5060006040366003190112610a7457600435610a9281610267565b610a9a6118b6565b816001600160a01b03807f00000000000000000000000000000000000000000000000000000000000000001692833b15610b025760449083604051958694859363040b850f60e31b855216600484015260243560248401525af18015610a6757610a5b575080f35b8280fd5b60005b838110610b195750506000910152565b8181015183820152602001610b09565b90602091610b4281518092818552858086019101610b06565b601f01601f1916010190565b503461002357610b5d36610956565b90600193929333148015610bb1575b61073357610b7b935a93611adf565b6040519060203d8301016040523d82523d6000602084013e6108de60405192839215158352604060208401526040830190610b29565b503360005260006020526001600160a01b036040600020541615610b6c565b503461002357604036600319011261002357600435610bee81610267565b60243567ffffffffffffffff811161002357602091610c14610c22923690600401610631565b90610c1d6118b6565b611f89565b610c2b81611ced565b6001600160a01b0360405191168152f35b503461002357602036600319011261002357610021600435610c5d81610267565b610c656118b6565b611ced565b50346100235760003660031901126100235760206001600160a01b0360315416604051908152f35b50346100235760003660031901126100235760207f6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d4546001600160a01b0360405191168152f35b503461002357600036600319011261002357602030546001600160a01b0360405191168152f35b50346100235760803660031901126100235767ffffffffffffffff60043581811161002357610d33903690600401610311565b60249291923582811161002357610d4e903690600401610311565b60449491943584811161002357610d69903690600401610311565b91606435958611610023576108de96610d89610d91973690600401610311565b969095611ba7565b60405190151581529081906020820190565b50346100235760003660031901126100235760206040516001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152f35b5034610023576000366003190112610023576040516370a0823160e01b815230600482015260209081816024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa908115610e77575b600091610e5a575b50604051908152f35b610e719150823d8111610909576108fb81836105ad565b38610e51565b610e7f61144b565b610e49565b90929192604082016040835281518091526060830160208093019160005b84828210610ebe575050506001600160a01b0391509416910152565b84516001600160a01b031684529384019390920191600101610ea2565b503461002357604036600319011261002357600435610ef981610267565b602435610f0581611a1b565b610f1260405191826105ad565b818152601f19610f2183611a1b565b01366020830137610f4a6108726000946001600160a01b03166000526000602052604060002090565b6001600160a01b0381168015159081610fd1575b5080610fc8575b15610fb557610fa961087282610f90610faf94610f828988611a3c565b906001600160a01b03169052565b6001600160a01b03166000526000602052604060002090565b93611a5e565b92610f4a565b908381526108de60405192839283610e84565b50828410610f65565b60019150141538610f5e565b50346100235760203660031901126100235760043577ffffffffffffffffffffffffffffffffffffffffffffffff8116809103610023576108de9060405190631aab3f0d60e11b825230600483015260248201526020816044816001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000165afa9081156110a2575b600091611084575b506040519081529081906020820190565b61109c915060203d8111610909576108fb81836105ad565b38611073565b6110aa61144b565b61106b565b5034610023576080366003190112610023576004356110cd81610267565b6024356110d981610267565b6044356110e581610267565b60643567ffffffffffffffff811161002357611105903690600401610285565b9091600160005260006020526001600160a01b038060406000205416159081159161117e575b5061116d576111476111539361114d936103006108de986119a9565b90611eff565b91611ced565b6040516001600160a01b0390911681529081906020820190565b60405162dc149f60e41b8152600490fd5b90507f6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d4541615153861112b565b5034610023576040366003190112610023576004356111c981610267565b6024356111d581610267565b6111dd6118b6565b6001600160a01b03811680158015611359575b61133857611223611217610872856001600160a01b03166000526000602052604060002090565b6001600160a01b031690565b036112de57806112a97faab4fa2b463f581b2b32cb3b7e3b704b9ce37cc209b5fb4d77e593ace40542769361128e6112746108726112d9966001600160a01b03166000526000602052604060002090565b916001600160a01b03166000526000602052604060002090565b906001600160a01b03166001600160a01b0319825416179055565b6111536112c9826001600160a01b03166000526000602052604060002090565b6001600160a01b03198154169055565b0390a1005b61052c611301610872846001600160a01b03166000526000602052604060002090565b604051633103525b60e21b81526001600160a01b039384166004820152908316602482015292909116604483015281906064820190565b60405163cadb248f60e01b81526001600160a01b0383166004820152602490fd5b50600181146111f0565b50346100235760203660031901126100235761002160043561138481610267565b61138c6118b6565b6119a9565b50346100235760203660031901126100235760043560005260326020526020604060002054604051908152f35b5034610023576000366003190112610023576108de6040516040810181811067ffffffffffffffff82111761142f575b604052600581527f322e302e300000000000000000000000000000000000000000000000000000006020820152604051918291602083526020830190610b29565b611437610575565b6113ee565b90816020910312610023575190565b506040513d6000823e3d90fd5b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001630146114b05734337ed05ab44e279ac59e855cb75dc2ae23b200ad994797b6f1f028f96a46ecce02600080a3565b604051633c97166560e21b8152600490fd5b903590601e1981360301821215610023570180359067ffffffffffffffff82116100235760200191813603831361002357565b919060408382031261002357823567ffffffffffffffff811161002357602091611520918501610631565b92013561064c81610267565b9035601e198236030181121561002357016020813591019167ffffffffffffffff821161002357813603831361002357565b908060209392818452848401376000828201840152601f01601f1916010190565b9291906116716115dc602092604087526115ac6040880161159f83610278565b6001600160a01b03169052565b8381013560608801526116616115c5604083018361152c565b9390610160948560808c01526101a08b019161155e565b916116586116046115f0606084018461152c565b603f198d8803810160a08f0152969161155e565b608083013560c08c015260a083013560e08c01528a6101009660c08501358883015261164861012060e087013581850152610140998701358a85015286018661152c565b929091888286030191015261155e565b9381019061152c565b918884030161018089015261155e565b930152565b8061167e5750565b600080808093338219f1503d15610283573d611699816105cf565b906116a760405192836105ad565b8152600060203d92013e565b50634e487b7160e01b600052603260045260246000fd5b91908110156116db575b60051b0190565b6116e36116b3565b6116d4565b3561064c81610267565b909161170b9281101561170f575b60051b8101906114c2565b9091565b6117176116b3565b611700565b919060408382031261002357825167ffffffffffffffff81116100235783019080601f8301121561002357815191611753836105cf565b9161176160405193846105ad565b838352602084830101116100235760209261178191848085019101610b06565b92015161064c81610267565b90816020910312610023575161064c8161044f565b60409061064c939281528160208201520190610b29565b906117cd906020808251830101910161171c565b90916001600160a01b03809216916117fb610872846001600160a01b03166000526000602052604060002090565b1615611871579160209161182593604051809581948293630b135d3f60e11b8452600484016117a2565b03915afa908115611864575b60009161183c575090565b61064c915060203d811161185d575b61185581836105ad565b81019061178d565b503d61184b565b61186c61144b565b611831565b6040516326cc3fab60e21b81526001600160a01b0383166004820152602490fd5b916000928392602083519301915af1604051903d6000833e156118b25750565b3d90fd5b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001633141580611907575b6118ef57565b604051634776242160e01b8152336004820152602490fd5b50303314156118e9565b6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016330361194357565b60405163e6fce6a560e01b8152336004820152602490fd5b507f6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d4548015610021576000808092368280373360601b3652818060143601925af13d82803e156118b2573d90f35b6001600160a01b03808216918215611a09577f6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d49081549155167f06be9a1bea257286cf2afa8205ed494ca9d6a4b41aa58d04238deebada20fb0c600080a3565b60405163dd449f5f60e01b8152600490fd5b60209067ffffffffffffffff8111611a345760051b0190565b6116e3610575565b6020918151811015611a51575b60051b010190565b611a596116b3565b611a49565b6000198114611a6d5760010190565b634e487b7160e01b600052601160045260246000fd5b611a9b90602060405192828480945193849201610b06565b810103902090565b906002821015611ab05752565b634e487b7160e01b600052602160045260246000fd5b60209093929193611adb816040810196611aa3565b0152565b9493929091946002821015611ab05760018203611b8a576000808751602089018488f4955b8615611b54577f81d12fffced46c214dfae8ab8fa0b9f7b69f70c9d500e33f612f2105deb261ee91611b4f611b406001600160a01b0393611a83565b96604051938493169583611ac6565b0390a4565b7f3ddd038f78c876172d5dbfd730b14c9f8692dfa197ef104eaac6df3f85a0874a91611b4f611b406001600160a01b0393611a83565b600080875160208901868589f195611b04565b3561064c816106a1565b9497969391929795909560009887158015611ce3575b8015611cd9575b8015611ccf575b611ca0576001978833148015611c70575b6107335797969594939291906000985b808a10611bff5750505050505050505050565b9091929394959697899b50611c60888888611c5a89869f8f81611c45818e611c3e8f968f97611c386103e483611c529b611c4d9b6116ca565b9c6116ca565b35986116f2565b9890946116ca565b611b9d565b9436916105fa565b91611e30565b9b01989796959493929190611bec565b506001600160a01b03611c99610872336001600160a01b03166000526000602052604060002090565b1615611bdc565b60405163470c355760e01b81526004810189905260248101919091526044810182905260648101869052608490fd5b5085821415611bcb565b5081811415611bc4565b5080881415611bbd565b6001600160a01b0381168015908115611e25575b50611e0257611d29611217610872836001600160a01b03166000526000602052604060002090565b611ddf57600160009081526020527fecdf3a3effea5783a3c4c2140e677577666428d44ed9d474a0b3a4c9943f844090611dda90611da6611d897fada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d610872565b61128e836001600160a01b03166000526000602052604060002090565b60016000908152602052611153817fada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d61128e565b0390a1565b60405163b29d459560e01b81526001600160a01b03919091166004820152602490fd5b60405163cadb248f60e01b81526001600160a01b03919091166004820152602490fd5b600191501438611d01565b939293611e405a86858585611adf565b948515611ed357611ea8611e9d7f8c014e41cffd68ba64f3e7830b8b2e4ee860509d8deab25ebbcbba2f0405e2da956001600160a01b0395604051968796338852166020870152604086015260a0606086015260a0850190610b29565b916080840190611aa3565b0390a1337f6895c13664aa4f67288b25d7a21d7aaa34916e355fb9b6fae0a139a9085becb8600080a2565b50505050337facd2c8702804128fdb0db2bb49f6d127dd0181c13fd45dbfe16de0930e2bd375600080a2565b90611f0991611f89565b6001600160a01b03811680158015611f7f575b611f67576000526000602052604060002060016001600160a01b0319825416179055600160005261064c816040600020906001600160a01b03166001600160a01b0319825416179055565b6024906040519063cadb248f60e01b82526004820152fd5b5060018114611f1c565b6001600160a01b03811615611fba5781600092918360208194519301915af1604051903d6000833e156118b2575190565b60405162461bcd60e51b815260206004820152601a60248201527f57726f6e67204d6f64756c6520536574757020416464726573730000000000006044820152606490fdfea2646970667358221220cff3a3a36f2f0d3a69e555a32683ff2559d10b0b07d83682045d7528ff80c58e64736f6c63430008110033",
  "devdoc": {
    "author": "Chirag Titiya - <chirag@biconomy.io>, Filipp Makarov - <filipp.makarov@biconomy.io>",
    "details": "This contract is the base for the Smart Account functionality.         - It is modular by nature. UserOp and txns validation happens in Authorization Modules.         - It provides the functionality to execute AA (EIP-4337) userOps. Gnosis style txns removed to a module.         - It allows to receive and manage assets.         - It is responsible for managing the modules and fallbacks.         - The Smart Account can be extended with modules, such as Social Recovery, Session Key and others.",
    "errors": {
      "CallerIsNotAnEntryPoint(address)": [
        {
          "params": {
            "caller": "address that tried to call onlyEntryPoint-protected method"
          }
        }
      ],
      "CallerIsNotEntryPoint(address)": [
        {
          "params": {
            "caller": "address that tried to call _requireFromEntryPoint-protected method"
          }
        }
      ],
      "CallerIsNotEntryPointOrOwner(address)": [
        {
          "params": {
            "caller": "address that tried to call _requireFromEntryPointOrOwner-protected method"
          }
        }
      ],
      "CallerIsNotEntryPointOrSelf(address)": [
        {
          "params": {
            "caller": "address that tried to call _requireFromEntryPointOrSelf-protected method"
          }
        }
      ],
      "CallerIsNotOwner(address)": [
        {
          "params": {
            "caller": "address that tried to call onlyOwner method"
          }
        }
      ],
      "CallerIsNotSelf(address)": [
        {
          "params": {
            "caller": "Caller address"
          }
        }
      ],
      "InvalidImplementation(address)": [
        {
          "params": {
            "implementationAddress": "implementation address provided"
          }
        }
      ],
      "MixedAuthFail(address)": [
        {
          "params": {
            "caller": "address that tried to call mixedAuth-protected method"
          }
        }
      ],
      "ModuleAlreadyEnabled(address)": [
        {
          "params": {
            "module": "Module address provided"
          }
        }
      ],
      "ModuleAndPrevModuleMismatch(address,address,address)": [
        {
          "params": {
            "expectedModule": "expected module at modules[prevModule]",
            "prevModule": "previous module address provided at call",
            "returnedModule": "the module that has been found at modules[prevModule]"
          }
        }
      ],
      "ModuleCannotBeZeroOrSentinel(address)": [
        {
          "params": {
            "module": "Module address provided"
          }
        }
      ],
      "ModuleNotEnabled(address)": [
        {
          "params": {
            "module": "Module address provided"
          }
        }
      ],
      "WrongBatchProvided(uint256,uint256,uint256,uint256)": [
        {
          "params": {
            "destLength": "length of destination contracts array",
            "funcLength": "length of function signatures array",
            "operationLength": "length of operation types array. 0 if there's no operations",
            "valueLength": "length of txn values array"
          }
        }
      ],
      "WrongContractSignature(bytes)": [
        {
          "params": {
            "contractSignature": "the contract signature that has been verified"
          }
        }
      ],
      "WrongContractSignatureFormat(uint256,uint256,uint256)": [
        {
          "params": {
            "contractSignatureLength": "length of a contract signature",
            "signatureLength": "the whole signature length",
            "uintS": "s converted to uint256"
          }
        }
      ],
      "WrongValidationModule(address)": [
        {
          "params": {
            "moduleAddressProvided": "module address taken from signature"
          }
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "addDeposit()": {
        "details": "Deposit more funds for this account in the entryPoint"
      },
      "constructor": {
        "details": "Constructor that sets the entry point contract.      _modules[SENTINEL_MODULES] = SENTINEL_MODULES protects implementation from initialization",
        "params": {
          "anEntryPoint": "The address of the entry point contract."
        }
      },
      "disableModule(address,address)": {
        "details": "Removes a module from the allowlist.",
        "params": {
          "module": "Module to be removed.",
          "prevModule": "Module that pointed to the module to be removed in the linked list"
        }
      },
      "enableModule(address)": {
        "details": "Adds a module to the allowlist.",
        "params": {
          "module": "Module to be allow-listed."
        }
      },
      "entryPoint()": {
        "details": "Returns the current entry point used by this account.This function should be implemented by the subclass to return the current entry point used by this account.",
        "returns": {
          "_0": "EntryPoint as an `IEntryPoint` interface."
        }
      },
      "execBatchTransactionFromModule(address[],uint256[],bytes[],uint8[])": {
        "details": "Allows a Module to execute a batch of Smart Account transactions without any further confirmations.",
        "params": {
          "data": "Data payload of module transaction.",
          "operations": "Operation type of module transaction.",
          "to": "Destination address of module transaction.",
          "value": "Ether value of module transaction."
        }
      },
      "execTransactionFromModule(address,uint256,bytes,uint8,uint256)": {
        "details": "Allows a Module to execute a Smart Account transaction without any further confirmations.",
        "params": {
          "data": "Data payload of module transaction.",
          "operation": "Operation type of module transaction.",
          "to": "Destination address of module transaction.",
          "value": "Ether value of module transaction."
        }
      },
      "execTransactionFromModuleReturnData(address,uint256,bytes,uint8)": {
        "details": "Allows a Module to execute a wallet transaction without any further confirmations and returns data",
        "params": {
          "data": "Data payload of module transaction.",
          "operation": "Operation type of module transaction.",
          "to": "Destination address of module transaction.",
          "value": "Ether value of module transaction."
        }
      },
      "execute(address,uint256,bytes)": {
        "details": "Interface function with the standard name for execute_ncC",
        "params": {
          "dest": "Address of the contract to call",
          "func": "Data of the transaction",
          "value": "Amount of native tokens to send along with the transaction"
        }
      },
      "executeBatch(address[],uint256[],bytes[])": {
        "details": "Interface function with the standard name for executeBatch_y6U",
        "params": {
          "dest": "Addresses of the contracts to call",
          "func": "Data of the transactions",
          "value": "Amounts of native tokens to send along with the transactions"
        }
      },
      "executeBatch_y6U(address[],uint256[],bytes[])": {
        "details": "Execute a sequence of transactions",
        "params": {
          "dest": "Addresses of the contracts to call",
          "func": "Data of the transactions",
          "value": "Amounts of native tokens to send along with the transactions"
        }
      },
      "execute_ncC(address,uint256,bytes)": {
        "details": "Execute a transaction (called by entryPoint)",
        "params": {
          "dest": "Address of the contract to call",
          "func": "Data of the transaction",
          "value": "Amount of native tokens to send along with the transaction"
        }
      },
      "getDeposit()": {
        "details": "Check current account deposit in the entryPoint"
      },
      "getImplementation()": {
        "details": "Returns the address of the implementation contract associated with this contract."
      },
      "getModulesPaginated(address,uint256)": {
        "details": "Returns array of modules. Useful for a widget",
        "params": {
          "pageSize": "Maximum number of modules that should be returned.",
          "start": "Start of the page."
        },
        "returns": {
          "array": "Array of modules.",
          "next": "Start of the next page."
        }
      },
      "init(address,address,address,bytes)": {
        "details": "Initialize the Smart Account with required states",
        "params": {
          "authModuleSetupContract": "Contract, that setups initial auth module for this smart account. It can be a module factory or a registry module that serves several smart accounts",
          "authModuleSetupData": "modules setup data (a standard calldata for the module setup contract)",
          "handler": "Default fallback handler provided in Smart Account",
          "sessionKeyModuleContract": "Contract, that enables session key module"
        }
      },
      "isModuleEnabled(address)": {
        "details": "Returns if a module is enabled",
        "returns": {
          "_0": "True if the module is enabled"
        }
      },
      "isValidSignature(bytes32,bytes)": {
        "details": "Forwards the validation to the module specified in the signature",
        "params": {
          "dataHash": "32 bytes hash of the data signed on the behalf of address(msg.sender)",
          "signature": "Signature byte array associated with dataHash"
        },
        "returns": {
          "_0": "bytes4 value."
        }
      },
      "nonce(uint192)": {
        "details": "This method returns the next sequential nonce.",
        "returns": {
          "_0": "nonce the account nonce."
        }
      },
      "setFallbackHandler(address)": {
        "details": "Sets the fallback handler.",
        "params": {
          "handler": "Handler to be set."
        }
      },
      "setupAndEnableModule(address,bytes)": {
        "details": "Setups module for this Smart Account and enables it."
      },
      "supportsInterface(bytes4)": {
        "params": {
          "_interfaceId": "The interface identifier, as specified in ERC165"
        },
        "returns": {
          "_0": "`true` if the contract implements `_interfaceID`"
        }
      },
      "updateImplementation(address)": {
        "params": {
          "_implementation": "New wallet implementation"
        }
      },
      "validateUserOp((address,uint256,bytes,bytes,uint256,uint256,uint256,uint256,uint256,bytes,bytes),bytes32,uint256)": {
        "params": {
          "missingAccountFunds": "the amount of funds required to pay to EntryPoint to pay for the userOp execution.",
          "userOp": "validate the userOp.signature field",
          "userOpHash": "convenient field: the hash of the request, to check the signature against          (also hashes the entrypoint and chain id)"
        },
        "returns": {
          "validationData": "signature and time-range of this operation      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,         otherwise, an address of an \"authorizer\" contract.      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"      <6-byte> validAfter - first timestamp this operation is valid      If no time-range in account, return SIG_VALIDATION_FAILED (1) for signature failure.      Note that the validation code cannot use block.timestamp (or block.number) directly."
        }
      },
      "withdrawDepositTo(address,uint256)": {
        "details": "Withdraw value from the account's deposit",
        "params": {
          "amount": "to withdraw",
          "withdrawAddress": "target to send to"
        }
      }
    },
    "title": "SmartAccount - EIP-4337 compatible smart contract wallet.",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "AlreadyInitialized()": [
        {
          "notice": "Throws if trying to initialize a Smart Account that has already been initialized"
        }
      ],
      "BaseImplementationCannotBeZero()": [
        {
          "notice": "Throws if zero address has been provided as Base Implementation address"
        }
      ],
      "CallerIsNotAnEntryPoint(address)": [
        {
          "notice": "Throws at onlyEntryPoint when msg.sender is not an EntryPoint set for this Smart Account"
        }
      ],
      "CallerIsNotEntryPoint(address)": [
        {
          "notice": "Throws at _requireFromEntryPoint when msg.sender is not an EntryPoint"
        }
      ],
      "CallerIsNotEntryPointOrOwner(address)": [
        {
          "notice": "Throws at _requireFromEntryPointOrOwner when msg.sender is not an EntryPoint neither an owner"
        }
      ],
      "CallerIsNotEntryPointOrSelf(address)": [
        {
          "notice": "Throws at _requireFromEntryPointOrSelf when msg.sender is not an EntryPoint neither self"
        }
      ],
      "CallerIsNotOwner(address)": [
        {
          "notice": "Throws at onlyOwner when msg.sender is not an owner"
        }
      ],
      "CallerIsNotSelf(address)": [
        {
          "notice": "Throws when the caller is not address(this)"
        }
      ],
      "DelegateCallsOnly()": [
        {
          "notice": "Thrown when the function that must be called only via delegatecall is called directly"
        }
      ],
      "EntryPointCannotBeZero()": [
        {
          "notice": "Throws if zero address has been provided as Entry Point address"
        }
      ],
      "HandlerCannotBeZero()": [
        {
          "notice": "Throws if zero address has been provided as Fallback Handler address"
        }
      ],
      "InvalidImplementation(address)": [
        {
          "notice": "Throws if there is no code at implementationAddress"
        }
      ],
      "MixedAuthFail(address)": [
        {
          "notice": "Throws at mixedAuth when msg.sender is not an owner neither _self"
        }
      ],
      "ModuleAlreadyEnabled(address)": [
        {
          "notice": "Throws when trying to enable module that has already been enabled"
        }
      ],
      "ModuleAndPrevModuleMismatch(address,address,address)": [
        {
          "notice": "Throws when module and previous module mismatch"
        }
      ],
      "ModuleCannotBeZeroOrSentinel(address)": [
        {
          "notice": "Throws when address(0) or SENTINEL_MODULES constant has been provided as a module address"
        }
      ],
      "ModuleNotEnabled(address)": [
        {
          "notice": "Throws when trying to execute transaction from module that is not enabled"
        }
      ],
      "ModulesAlreadyInitialized()": [
        {
          "notice": "Throws when trying to initialize module manager that already been initialized"
        }
      ],
      "ModulesSetupExecutionFailed()": [
        {
          "notice": "Throws when a delegatecall in course of module manager initialization has failed"
        }
      ],
      "OwnerCanNotBeSelf()": [
        {
          "notice": "Thrown when trying to use address of the Smart Account as an owner for itself"
        }
      ],
      "OwnerCannotBeZero()": [
        {
          "notice": "Throws if trying to change an owner of a SmartAccount to the zero address"
        }
      ],
      "OwnerProvidedIsSame()": [
        {
          "notice": "Thrown when trying to use current owner as a new owner in a _setOwner() call"
        }
      ],
      "TransferToZeroAddressAttempt()": [
        {
          "notice": "Throws when if trying to transfer to zero address"
        }
      ],
      "WrongBatchProvided(uint256,uint256,uint256,uint256)": [
        {
          "notice": "Throws when data for executeBatchCall provided in wrong format (i.e. empty array or lengths mismatch)"
        }
      ],
      "WrongContractSignature(bytes)": [
        {
          "notice": "Throws if isValidSignature for the conrtact signature and data hash differs from EIP1271 Magic Value"
        }
      ],
      "WrongContractSignatureFormat(uint256,uint256,uint256)": [
        {
          "notice": "Throws if contract signature is provided in frong format"
        }
      ],
      "WrongValidationModule(address)": [
        {
          "notice": "Throws when module address taken from signature is not enabled"
        }
      ]
    },
    "kind": "user",
    "methods": {
      "disableModule(address,address)": {
        "notice": "This can only be done via a wallet transaction.Disables the module `module` for the wallet."
      },
      "enableModule(address)": {
        "notice": "This can only be done via a userOp or a selfcall.Enables the module `module` for the wallet."
      },
      "executeBatch_y6U(address[],uint256[],bytes[])": {
        "notice": "Name is optimized for this method to be cheaper to be called"
      },
      "execute_ncC(address,uint256,bytes)": {
        "notice": "Name is optimized for this method to be cheaper to be called"
      },
      "getImplementation()": {
        "notice": "The implementation address is stored in the contract's storage slot with index 0."
      },
      "init(address,address,address,bytes)": {
        "notice": "devs need to make sure it is only callable once by initializer or state check restrictionsany further implementations that introduces a new state must have a reinit methodreinitialization is not possible, as _initialSetupModules reverts if the account is already initialized         which is when there is at least one enabled module"
      },
      "isValidSignature(bytes32,bytes)": {
        "notice": "Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)"
      },
      "nonce(uint192)": {
        "notice": "Provides 2D nonce functionality by allowing to use a nonce of a specific key."
      },
      "setFallbackHandler(address)": {
        "notice": "This can only be done via a UserOp sent by EntryPoint."
      },
      "setupAndEnableModule(address,bytes)": {
        "notice": "This can only be done via userOp or a selfcall.Enables the module `module` for the wallet."
      },
      "supportsInterface(bytes4)": {
        "notice": "Query if a contract implements an interface"
      },
      "updateImplementation(address)": {
        "notice": "All the new implementations MUST have this method!Updates the implementation of the base wallet"
      },
      "validateUserOp((address,uint256,bytes,bytes,uint256,uint256,uint256,uint256,uint256,bytes,bytes),bytes32,uint256)": {
        "notice": "Validates the userOp."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7870,
        "contract": "contracts/smart-account/SmartAccount.sol:SmartAccount",
        "label": "_modules",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_address)"
      },
      {
        "astId": 7874,
        "contract": "contracts/smart-account/SmartAccount.sol:SmartAccount",
        "label": "__gap",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint256)24_storage"
      },
      {
        "astId": 7790,
        "contract": "contracts/smart-account/SmartAccount.sol:SmartAccount",
        "label": "__gap",
        "offset": 0,
        "slot": "25",
        "type": "t_array(t_uint256)24_storage"
      },
      {
        "astId": 7060,
        "contract": "contracts/smart-account/SmartAccount.sol:SmartAccount",
        "label": "ownerDeprecated",
        "offset": 0,
        "slot": "49",
        "type": "t_address"
      },
      {
        "astId": 7064,
        "contract": "contracts/smart-account/SmartAccount.sol:SmartAccount",
        "label": "noncesDeprecated",
        "offset": 0,
        "slot": "50",
        "type": "t_mapping(t_uint256,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)24_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[24]",
        "numberOfBytes": "768"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}