{
  "language": "Solidity",
  "sources": {
    "@account-abstraction/contracts/core/EntryPoint.sol": {
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IPaymaster.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\n\nimport \"../utils/Exec.sol\";\nimport \"./StakeManager.sol\";\nimport \"./SenderCreator.sol\";\nimport \"./Helpers.sol\";\nimport \"./NonceManager.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract EntryPoint is IEntryPoint, StakeManager, NonceManager, ReentrancyGuard {\n\n    using UserOperationLib for UserOperation;\n\n    SenderCreator private immutable senderCreator = new SenderCreator();\n\n    // internal value used during simulation: need to query aggregator.\n    address private constant SIMULATE_FIND_AGGREGATOR = address(1);\n\n    // marker for inner call revert on out of gas\n    bytes32 private constant INNER_OUT_OF_GAS = hex'deaddead';\n\n    uint256 private constant REVERT_REASON_MAX_LEN = 2048;\n\n    /**\n     * for simulation purposes, validateUserOp (and validatePaymasterUserOp) must return this value\n     * in case of signature failure, instead of revert.\n     */\n    uint256 public constant SIG_VALIDATION_FAILED = 1;\n\n    /**\n     * compensate the caller's beneficiary address with the collected fees of all UserOperations.\n     * @param beneficiary the address to receive the fees\n     * @param amount amount to transfer.\n     */\n    function _compensate(address payable beneficiary, uint256 amount) internal {\n        require(beneficiary != address(0), \"AA90 invalid beneficiary\");\n        (bool success,) = beneficiary.call{value : amount}(\"\");\n        require(success, \"AA91 failed send to beneficiary\");\n    }\n\n    /**\n     * execute a user op\n     * @param opIndex index into the opInfo array\n     * @param userOp the userOp to execute\n     * @param opInfo the opInfo filled by validatePrepayment for this userOp.\n     * @return collected the total amount this userOp paid.\n     */\n    function _executeUserOp(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory opInfo) private returns (uint256 collected) {\n        uint256 preGas = gasleft();\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\n\n        try this.innerHandleOp(userOp.callData, opInfo, context) returns (uint256 _actualGasCost) {\n            collected = _actualGasCost;\n        } catch {\n            bytes32 innerRevertCode;\n            assembly {\n                returndatacopy(0, 0, 32)\n                innerRevertCode := mload(0)\n            }\n            // handleOps was called with gas limit too low. abort entire bundle.\n            if (innerRevertCode == INNER_OUT_OF_GAS) {\n                //report paymaster, since if it is not deliberately caused by the bundler,\n                // it must be a revert caused by paymaster.\n                revert FailedOp(opIndex, \"AA95 out of gas\");\n            }\n\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            collected = _handlePostOp(opIndex, IPaymaster.PostOpMode.postOpReverted, opInfo, context, actualGas);\n        }\n    }\n\n    /**\n     * Execute a batch of UserOperations.\n     * no signature aggregator is used.\n     * if any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) public nonReentrant {\n\n        uint256 opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n    unchecked {\n        for (uint256 i = 0; i < opslen; i++) {\n            UserOpInfo memory opInfo = opInfos[i];\n            (uint256 validationData, uint256 pmValidationData) = _validatePrepayment(i, ops[i], opInfo);\n            _validateAccountAndPaymasterValidationData(i, validationData, pmValidationData, address(0));\n        }\n\n        uint256 collected = 0;\n        emit BeforeExecution();\n\n        for (uint256 i = 0; i < opslen; i++) {\n            collected += _executeUserOp(i, ops[i], opInfos[i]);\n        }\n\n        _compensate(beneficiary, collected);\n    } //unchecked\n    }\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\n     * @param beneficiary the address to receive the fees\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) public nonReentrant {\n\n        uint256 opasLen = opsPerAggregator.length;\n        uint256 totalOps = 0;\n        for (uint256 i = 0; i < opasLen; i++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[i];\n            UserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n\n            //address(1) is special marker of \"signature error\"\n            require(address(aggregator) != address(1), \"AA96 invalid aggregator\");\n\n            if (address(aggregator) != address(0)) {\n                // solhint-disable-next-line no-empty-blocks\n                try aggregator.validateSignatures(ops, opa.signature) {}\n                catch {\n                    revert SignatureValidationFailed(address(aggregator));\n                }\n            }\n\n            totalOps += ops.length;\n        }\n\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\n\n        emit BeforeExecution();\n\n        uint256 opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            UserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n\n            uint256 opslen = ops.length;\n            for (uint256 i = 0; i < opslen; i++) {\n                UserOpInfo memory opInfo = opInfos[opIndex];\n                (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(opIndex, ops[i], opInfo);\n                _validateAccountAndPaymasterValidationData(i, validationData, paymasterValidationData, address(aggregator));\n                opIndex++;\n            }\n        }\n\n        uint256 collected = 0;\n        opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            emit SignatureAggregatorChanged(address(opa.aggregator));\n            UserOperation[] calldata ops = opa.userOps;\n            uint256 opslen = ops.length;\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\n                opIndex++;\n            }\n        }\n        emit SignatureAggregatorChanged(address(0));\n\n        _compensate(beneficiary, collected);\n    }\n\n    /// @inheritdoc IEntryPoint\n    function simulateHandleOp(UserOperation calldata op, address target, bytes calldata targetCallData) external override {\n\n        UserOpInfo memory opInfo;\n        _simulationOnlyValidations(op);\n        (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(0, op, opInfo);\n        ValidationData memory data = _intersectTimeRange(validationData, paymasterValidationData);\n\n        numberMarker();\n        uint256 paid = _executeUserOp(0, op, opInfo);\n        numberMarker();\n        bool targetSuccess;\n        bytes memory targetResult;\n        if (target != address(0)) {\n            (targetSuccess, targetResult) = target.call(targetCallData);\n        }\n        revert ExecutionResult(opInfo.preOpGas, paid, data.validAfter, data.validUntil, targetSuccess, targetResult);\n    }\n\n\n    // A memory copy of UserOp static fields only.\n    // Excluding: callData, initCode and signature. Replacing paymasterAndData with paymaster.\n    struct MemoryUserOp {\n        address sender;\n        uint256 nonce;\n        uint256 callGasLimit;\n        uint256 verificationGasLimit;\n        uint256 preVerificationGas;\n        address paymaster;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n    }\n\n    struct UserOpInfo {\n        MemoryUserOp mUserOp;\n        bytes32 userOpHash;\n        uint256 prefund;\n        uint256 contextOffset;\n        uint256 preOpGas;\n    }\n\n    /**\n     * inner function to handle a UserOperation.\n     * Must be declared \"external\" to open a call context, but it can only be called by handleOps.\n     */\n    function innerHandleOp(bytes memory callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        require(msg.sender == address(this), \"AA92 internal call only\");\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n        uint callGasLimit = mUserOp.callGasLimit;\n    unchecked {\n        // handleOps was called with gas limit too low. abort entire bundle.\n        if (gasleft() < callGasLimit + mUserOp.verificationGasLimit + 5000) {\n            assembly {\n                mstore(0, INNER_OUT_OF_GAS)\n                revert(0, 32)\n            }\n        }\n    }\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (callData.length > 0) {\n            bool success = Exec.call(mUserOp.sender, 0, callData, callGasLimit);\n            if (!success) {\n                bytes memory result = Exec.getReturnData(REVERT_REASON_MAX_LEN);\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(opInfo.userOpHash, mUserOp.sender, mUserOp.nonce, result);\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n    unchecked {\n        uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n        //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\n        return _handlePostOp(0, mode, opInfo, context, actualGas);\n    }\n    }\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     */\n    function getUserOpHash(UserOperation calldata userOp) public view returns (bytes32) {\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n     * copy general fields from userOp into the memory opInfo structure.\n     */\n    function _copyUserOpToMemory(UserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure {\n        mUserOp.sender = userOp.sender;\n        mUserOp.nonce = userOp.nonce;\n        mUserOp.callGasLimit = userOp.callGasLimit;\n        mUserOp.verificationGasLimit = userOp.verificationGasLimit;\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\n        mUserOp.maxFeePerGas = userOp.maxFeePerGas;\n        mUserOp.maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        if (paymasterAndData.length > 0) {\n            require(paymasterAndData.length >= 20, \"AA93 invalid paymasterAndData\");\n            mUserOp.paymaster = address(bytes20(paymasterAndData[: 20]));\n        } else {\n            mUserOp.paymaster = address(0);\n        }\n    }\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\n     * @param userOp the user operation to validate.\n     */\n    function simulateValidation(UserOperation calldata userOp) external {\n        UserOpInfo memory outOpInfo;\n\n        _simulationOnlyValidations(userOp);\n        (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(0, userOp, outOpInfo);\n        StakeInfo memory paymasterInfo = _getStakeInfo(outOpInfo.mUserOp.paymaster);\n        StakeInfo memory senderInfo = _getStakeInfo(outOpInfo.mUserOp.sender);\n        StakeInfo memory factoryInfo;\n        {\n            bytes calldata initCode = userOp.initCode;\n            address factory = initCode.length >= 20 ? address(bytes20(initCode[0 : 20])) : address(0);\n            factoryInfo = _getStakeInfo(factory);\n        }\n\n        ValidationData memory data = _intersectTimeRange(validationData, paymasterValidationData);\n        address aggregator = data.aggregator;\n        bool sigFailed = aggregator == address(1);\n        ReturnInfo memory returnInfo = ReturnInfo(outOpInfo.preOpGas, outOpInfo.prefund,\n            sigFailed, data.validAfter, data.validUntil, getMemoryBytesFromOffset(outOpInfo.contextOffset));\n\n        if (aggregator != address(0) && aggregator != address(1)) {\n            AggregatorStakeInfo memory aggregatorInfo = AggregatorStakeInfo(aggregator, _getStakeInfo(aggregator));\n            revert ValidationResultWithAggregation(returnInfo, senderInfo, factoryInfo, paymasterInfo, aggregatorInfo);\n        }\n        revert ValidationResult(returnInfo, senderInfo, factoryInfo, paymasterInfo);\n\n    }\n\n    function _getRequiredPrefund(MemoryUserOp memory mUserOp) internal pure returns (uint256 requiredPrefund) {\n    unchecked {\n        //when using a Paymaster, the verificationGasLimit is used also to as a limit for the postOp call.\n        // our security model might call postOp eventually twice\n        uint256 mul = mUserOp.paymaster != address(0) ? 3 : 1;\n        uint256 requiredGas = mUserOp.callGasLimit + mUserOp.verificationGasLimit * mul + mUserOp.preVerificationGas;\n\n        requiredPrefund = requiredGas * mUserOp.maxFeePerGas;\n    }\n    }\n\n    // create the sender's contract if needed.\n    function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {\n        if (initCode.length != 0) {\n            address sender = opInfo.mUserOp.sender;\n            if (sender.code.length != 0) revert FailedOp(opIndex, \"AA10 sender already constructed\");\n            address sender1 = senderCreator.createSender{gas : opInfo.mUserOp.verificationGasLimit}(initCode);\n            if (sender1 == address(0)) revert FailedOp(opIndex, \"AA13 initCode failed or OOG\");\n            if (sender1 != sender) revert FailedOp(opIndex, \"AA14 initCode must return sender\");\n            if (sender1.code.length == 0) revert FailedOp(opIndex, \"AA15 initCode must create sender\");\n            address factory = address(bytes20(initCode[0 : 20]));\n            emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);\n        }\n    }\n\n    /**\n     * Get counterfactual sender address.\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * this method always revert, and returns the address in SenderAddressResult error\n     * @param initCode the constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes calldata initCode) public {\n        address sender = senderCreator.createSender(initCode);\n        revert SenderAddressResult(sender);\n    }\n\n    function _simulationOnlyValidations(UserOperation calldata userOp) internal view {\n        // solhint-disable-next-line no-empty-blocks\n        try this._validateSenderAndPaymaster(userOp.initCode, userOp.sender, userOp.paymasterAndData) {}\n        catch Error(string memory revertReason) {\n            if (bytes(revertReason).length != 0) {\n                revert FailedOp(0, revertReason);\n            }\n        }\n    }\n\n    /**\n    * Called only during simulation.\n    * This function always reverts to prevent warm/cold storage differentiation in simulation vs execution.\n    */\n    function _validateSenderAndPaymaster(bytes calldata initCode, address sender, bytes calldata paymasterAndData) external view {\n        if (initCode.length == 0 && sender.code.length == 0) {\n            // it would revert anyway. but give a meaningful message\n            revert(\"AA20 account not deployed\");\n        }\n        if (paymasterAndData.length >= 20) {\n            address paymaster = address(bytes20(paymasterAndData[0 : 20]));\n            if (paymaster.code.length == 0) {\n                // it would revert anyway. but give a meaningful message\n                revert(\"AA30 paymaster not deployed\");\n            }\n        }\n        // always revert\n        revert(\"\");\n    }\n\n    /**\n     * call account.validateUserOp.\n     * revert (with FailedOp) in case validateUserOp reverts, or account didn't send required prefund.\n     * decrement account's deposit if needed\n     */\n    function _validateAccountPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPrefund)\n    internal returns (uint256 gasUsedByValidateAccountPrepayment, uint256 validationData) {\n    unchecked {\n        uint256 preGas = gasleft();\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n        address sender = mUserOp.sender;\n        _createSenderIfNeeded(opIndex, opInfo, op.initCode);\n        address paymaster = mUserOp.paymaster;\n        numberMarker();\n        uint256 missingAccountFunds = 0;\n        if (paymaster == address(0)) {\n            uint256 bal = balanceOf(sender);\n            missingAccountFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;\n        }\n        try IAccount(sender).validateUserOp{gas : mUserOp.verificationGasLimit}(op, opInfo.userOpHash, missingAccountFunds)\n        returns (uint256 _validationData) {\n            validationData = _validationData;\n        } catch Error(string memory revertReason) {\n            revert FailedOp(opIndex, string.concat(\"AA23 reverted: \", revertReason));\n        } catch {\n            revert FailedOp(opIndex, \"AA23 reverted (or OOG)\");\n        }\n        if (paymaster == address(0)) {\n            DepositInfo storage senderInfo = deposits[sender];\n            uint256 deposit = senderInfo.deposit;\n            if (requiredPrefund > deposit) {\n                revert FailedOp(opIndex, \"AA21 didn't pay prefund\");\n            }\n            senderInfo.deposit = uint112(deposit - requiredPrefund);\n        }\n        gasUsedByValidateAccountPrepayment = preGas - gasleft();\n    }\n    }\n\n    /**\n     * In case the request has a paymaster:\n     * Validate paymaster has enough deposit.\n     * Call paymaster.validatePaymasterUserOp.\n     * Revert with proper FailedOp in case paymaster reverts.\n     * Decrement paymaster's deposit\n     */\n    function _validatePaymasterPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPreFund, uint256 gasUsedByValidateAccountPrepayment)\n    internal returns (bytes memory context, uint256 validationData) {\n    unchecked {\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n        uint256 verificationGasLimit = mUserOp.verificationGasLimit;\n        require(verificationGasLimit > gasUsedByValidateAccountPrepayment, \"AA41 too little verificationGas\");\n        uint256 gas = verificationGasLimit - gasUsedByValidateAccountPrepayment;\n\n        address paymaster = mUserOp.paymaster;\n        DepositInfo storage paymasterInfo = deposits[paymaster];\n        uint256 deposit = paymasterInfo.deposit;\n        if (deposit < requiredPreFund) {\n            revert FailedOp(opIndex, \"AA31 paymaster deposit too low\");\n        }\n        paymasterInfo.deposit = uint112(deposit - requiredPreFund);\n        try IPaymaster(paymaster).validatePaymasterUserOp{gas : gas}(op, opInfo.userOpHash, requiredPreFund) returns (bytes memory _context, uint256 _validationData){\n            context = _context;\n            validationData = _validationData;\n        } catch Error(string memory revertReason) {\n            revert FailedOp(opIndex, string.concat(\"AA33 reverted: \", revertReason));\n        } catch {\n            revert FailedOp(opIndex, \"AA33 reverted (or OOG)\");\n        }\n    }\n    }\n\n    /**\n     * revert if either account validationData or paymaster validationData is expired\n     */\n    function _validateAccountAndPaymasterValidationData(uint256 opIndex, uint256 validationData, uint256 paymasterValidationData, address expectedAggregator) internal view {\n        (address aggregator, bool outOfTimeRange) = _getValidationData(validationData);\n        if (expectedAggregator != aggregator) {\n            revert FailedOp(opIndex, \"AA24 signature error\");\n        }\n        if (outOfTimeRange) {\n            revert FailedOp(opIndex, \"AA22 expired or not due\");\n        }\n        //pmAggregator is not a real signature aggregator: we don't have logic to handle it as address.\n        // non-zero address means that the paymaster fails due to some signature check (which is ok only during estimation)\n        address pmAggregator;\n        (pmAggregator, outOfTimeRange) = _getValidationData(paymasterValidationData);\n        if (pmAggregator != address(0)) {\n            revert FailedOp(opIndex, \"AA34 signature error\");\n        }\n        if (outOfTimeRange) {\n            revert FailedOp(opIndex, \"AA32 paymaster expired or not due\");\n        }\n    }\n\n    function _getValidationData(uint256 validationData) internal view returns (address aggregator, bool outOfTimeRange) {\n        if (validationData == 0) {\n            return (address(0), false);\n        }\n        ValidationData memory data = _parseValidationData(validationData);\n        // solhint-disable-next-line not-rely-on-time\n        outOfTimeRange = block.timestamp > data.validUntil || block.timestamp < data.validAfter;\n        aggregator = data.aggregator;\n    }\n\n    /**\n     * validate account and paymaster (if defined).\n     * also make sure total validation doesn't exceed verificationGasLimit\n     * this method is called off-chain (simulateValidation()) and on-chain (from handleOps)\n     * @param opIndex the index of this userOp into the \"opInfos\" array\n     * @param userOp the userOp to validate\n     */\n    function _validatePrepayment(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory outOpInfo)\n    private returns (uint256 validationData, uint256 paymasterValidationData) {\n\n        uint256 preGas = gasleft();\n        MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\n        _copyUserOpToMemory(userOp, mUserOp);\n        outOpInfo.userOpHash = getUserOpHash(userOp);\n\n        // validate all numeric values in userOp are well below 128 bit, so they can safely be added\n        // and multiplied without causing overflow\n        uint256 maxGasValues = mUserOp.preVerificationGas | mUserOp.verificationGasLimit | mUserOp.callGasLimit |\n        userOp.maxFeePerGas | userOp.maxPriorityFeePerGas;\n        require(maxGasValues <= type(uint120).max, \"AA94 gas values overflow\");\n\n        uint256 gasUsedByValidateAccountPrepayment;\n        (uint256 requiredPreFund) = _getRequiredPrefund(mUserOp);\n        (gasUsedByValidateAccountPrepayment, validationData) = _validateAccountPrepayment(opIndex, userOp, outOpInfo, requiredPreFund);\n\n        if (!_validateAndUpdateNonce(mUserOp.sender, mUserOp.nonce)) {\n            revert FailedOp(opIndex, \"AA25 invalid account nonce\");\n        }\n\n        //a \"marker\" where account opcode validation is done and paymaster opcode validation is about to start\n        // (used only by off-chain simulateValidation)\n        numberMarker();\n\n        bytes memory context;\n        if (mUserOp.paymaster != address(0)) {\n            (context, paymasterValidationData) = _validatePaymasterPrepayment(opIndex, userOp, outOpInfo, requiredPreFund, gasUsedByValidateAccountPrepayment);\n        }\n    unchecked {\n        uint256 gasUsed = preGas - gasleft();\n\n        if (userOp.verificationGasLimit < gasUsed) {\n            revert FailedOp(opIndex, \"AA40 over verificationGasLimit\");\n        }\n        outOpInfo.prefund = requiredPreFund;\n        outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\n        outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n    }\n    }\n\n    /**\n     * process post-operation.\n     * called just after the callData is executed.\n     * if a paymaster is defined and its validation returned a non-empty context, its postOp is called.\n     * the excess amount is refunded to the account (or paymaster - if it was used in the request)\n     * @param opIndex index in the batch\n     * @param mode - whether is called from innerHandleOp, or outside (postOpReverted)\n     * @param opInfo userOp fields and info collected during validation\n     * @param context the context returned in validatePaymasterUserOp\n     * @param actualGas the gas used so far by this user operation\n     */\n    function _handlePostOp(uint256 opIndex, IPaymaster.PostOpMode mode, UserOpInfo memory opInfo, bytes memory context, uint256 actualGas) private returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n    unchecked {\n        address refundAddress;\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n        uint256 gasPrice = getUserOpGasPrice(mUserOp);\n\n        address paymaster = mUserOp.paymaster;\n        if (paymaster == address(0)) {\n            refundAddress = mUserOp.sender;\n        } else {\n            refundAddress = paymaster;\n            if (context.length > 0) {\n                actualGasCost = actualGas * gasPrice;\n                if (mode != IPaymaster.PostOpMode.postOpReverted) {\n                    IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost);\n                } else {\n                    // solhint-disable-next-line no-empty-blocks\n                    try IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost) {}\n                    catch Error(string memory reason) {\n                        revert FailedOp(opIndex, string.concat(\"AA50 postOp reverted: \", reason));\n                    }\n                    catch {\n                        revert FailedOp(opIndex, \"AA50 postOp revert\");\n                    }\n                }\n            }\n        }\n        actualGas += preGas - gasleft();\n        actualGasCost = actualGas * gasPrice;\n        if (opInfo.prefund < actualGasCost) {\n            revert FailedOp(opIndex, \"AA51 prefund below actualGasCost\");\n        }\n        uint256 refund = opInfo.prefund - actualGasCost;\n        _incrementDeposit(refundAddress, refund);\n        bool success = mode == IPaymaster.PostOpMode.opSucceeded;\n        emit UserOperationEvent(opInfo.userOpHash, mUserOp.sender, mUserOp.paymaster, mUserOp.nonce, success, actualGasCost, actualGas);\n    } // unchecked\n    }\n\n    /**\n     * the gas price this UserOp agrees to pay.\n     * relayer/block builder might submit the TX with higher priorityFee, but the user should not\n     */\n    function getUserOpGasPrice(MemoryUserOp memory mUserOp) internal view returns (uint256) {\n    unchecked {\n        uint256 maxFeePerGas = mUserOp.maxFeePerGas;\n        uint256 maxPriorityFeePerGas = mUserOp.maxPriorityFeePerGas;\n        if (maxFeePerGas == maxPriorityFeePerGas) {\n            //legacy mode (for networks that don't support basefee opcode)\n            return maxFeePerGas;\n        }\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n    }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function getOffsetOfMemoryBytes(bytes memory data) internal pure returns (uint256 offset) {\n        assembly {offset := data}\n    }\n\n    function getMemoryBytesFromOffset(uint256 offset) internal pure returns (bytes memory data) {\n        assembly {data := offset}\n    }\n\n    //place the NUMBER opcode in the code.\n    // this is used as a marker during simulation, as this OP is completely banned from the simulated code of the\n    // account and paymaster.\n    function numberMarker() internal view {\n        assembly {mstore(0, number())}\n    }\n}\n\n"
    },
    "@account-abstraction/contracts/core/Helpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable no-inline-assembly */\n\n/**\n * returned data from validateUserOp.\n * validateUserOp returns a uint256, with is created by `_packedValidationData` and parsed by `_parseValidationData`\n * @param aggregator - address(0) - the account validated the signature by itself.\n *              address(1) - the account failed to validate the signature.\n *              otherwise - this is an address of a signature aggregator that must be used to validate the signature.\n * @param validAfter - this UserOp is valid only after this timestamp.\n * @param validaUntil - this UserOp is valid only up to this timestamp.\n */\n    struct ValidationData {\n        address aggregator;\n        uint48 validAfter;\n        uint48 validUntil;\n    }\n\n//extract sigFailed, validAfter, validUntil.\n// also convert zero validUntil to type(uint48).max\n    function _parseValidationData(uint validationData) pure returns (ValidationData memory data) {\n        address aggregator = address(uint160(validationData));\n        uint48 validUntil = uint48(validationData >> 160);\n        if (validUntil == 0) {\n            validUntil = type(uint48).max;\n        }\n        uint48 validAfter = uint48(validationData >> (48 + 160));\n        return ValidationData(aggregator, validAfter, validUntil);\n    }\n\n// intersect account and paymaster ranges.\n    function _intersectTimeRange(uint256 validationData, uint256 paymasterValidationData) pure returns (ValidationData memory) {\n        ValidationData memory accountValidationData = _parseValidationData(validationData);\n        ValidationData memory pmValidationData = _parseValidationData(paymasterValidationData);\n        address aggregator = accountValidationData.aggregator;\n        if (aggregator == address(0)) {\n            aggregator = pmValidationData.aggregator;\n        }\n        uint48 validAfter = accountValidationData.validAfter;\n        uint48 validUntil = accountValidationData.validUntil;\n        uint48 pmValidAfter = pmValidationData.validAfter;\n        uint48 pmValidUntil = pmValidationData.validUntil;\n\n        if (validAfter < pmValidAfter) validAfter = pmValidAfter;\n        if (validUntil > pmValidUntil) validUntil = pmValidUntil;\n        return ValidationData(aggregator, validAfter, validUntil);\n    }\n\n/**\n * helper to pack the return value for validateUserOp\n * @param data - the ValidationData to pack\n */\n    function _packValidationData(ValidationData memory data) pure returns (uint256) {\n        return uint160(data.aggregator) | (uint256(data.validUntil) << 160) | (uint256(data.validAfter) << (160 + 48));\n    }\n\n/**\n * helper to pack the return value for validateUserOp, when not using an aggregator\n * @param sigFailed - true for signature failure, false for success\n * @param validUntil last timestamp this UserOperation is valid (or zero for infinite)\n * @param validAfter first timestamp this UserOperation is valid\n */\n    function _packValidationData(bool sigFailed, uint48 validUntil, uint48 validAfter) pure returns (uint256) {\n        return (sigFailed ? 1 : 0) | (uint256(validUntil) << 160) | (uint256(validAfter) << (160 + 48));\n    }\n\n/**\n * keccak function over calldata.\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\n */\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\n        assembly {\n            let mem := mload(0x40)\n            let len := data.length\n            calldatacopy(mem, data.offset, len)\n            ret := keccak256(mem, len)\n        }\n    }\n\n"
    },
    "@account-abstraction/contracts/core/NonceManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"../interfaces/IEntryPoint.sol\";\n\n/**\n * nonce management functionality\n */\ncontract NonceManager is INonceManager {\n\n    /**\n     * The next valid sequence number for a given nonce key.\n     */\n    mapping(address => mapping(uint192 => uint256)) public nonceSequenceNumber;\n\n    function getNonce(address sender, uint192 key)\n    public view override returns (uint256 nonce) {\n        return nonceSequenceNumber[sender][key] | (uint256(key) << 64);\n    }\n\n    // allow an account to manually increment its own nonce.\n    // (mainly so that during construction nonce can be made non-zero,\n    // to \"absorb\" the gas cost of first nonce increment to 1st transaction (construction),\n    // not to 2nd transaction)\n    function incrementNonce(uint192 key) public override {\n        nonceSequenceNumber[msg.sender][key]++;\n    }\n\n    /**\n     * validate nonce uniqueness for this account.\n     * called just after validateUserOp()\n     */\n    function _validateAndUpdateNonce(address sender, uint256 nonce) internal returns (bool) {\n\n        uint192 key = uint192(nonce >> 64);\n        uint64 seq = uint64(nonce);\n        return nonceSequenceNumber[sender][key]++ == seq;\n    }\n\n}\n"
    },
    "@account-abstraction/contracts/core/SenderCreator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/**\n * helper contract for EntryPoint, to call userOp.initCode from a \"neutral\" address,\n * which is explicitly not the entryPoint itself.\n */\ncontract SenderCreator {\n\n    /**\n     * call the \"initCode\" factory to create and return the sender account address\n     * @param initCode the initCode value from a UserOp. contains 20 bytes of factory address, followed by calldata\n     * @return sender the returned address of the created account, or zero address on failure.\n     */\n    function createSender(bytes calldata initCode) external returns (address sender) {\n        address factory = address(bytes20(initCode[0 : 20]));\n        bytes memory initCallData = initCode[20 :];\n        bool success;\n        /* solhint-disable no-inline-assembly */\n        assembly {\n            success := call(gas(), factory, 0, add(initCallData, 0x20), mload(initCallData), 0, 32)\n            sender := mload(0)\n        }\n        if (!success) {\n            sender = address(0);\n        }\n    }\n}\n"
    },
    "@account-abstraction/contracts/core/StakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\nimport \"../interfaces/IStakeManager.sol\";\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable not-rely-on-time */\n/**\n * manage deposits and stakes.\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\n * stake is value locked for at least \"unstakeDelay\" by a paymaster.\n */\nabstract contract StakeManager is IStakeManager {\n\n    /// maps paymaster to their deposits and stakes\n    mapping(address => DepositInfo) public deposits;\n\n    /// @inheritdoc IStakeManager\n    function getDepositInfo(address account) public view returns (DepositInfo memory info) {\n        return deposits[account];\n    }\n\n    // internal method to return just the stake info\n    function _getStakeInfo(address addr) internal view returns (StakeInfo memory info) {\n        DepositInfo storage depositInfo = deposits[addr];\n        info.stake = depositInfo.stake;\n        info.unstakeDelaySec = depositInfo.unstakeDelaySec;\n    }\n\n    /// return the deposit (for gas payment) of the account\n    function balanceOf(address account) public view returns (uint256) {\n        return deposits[account].deposit;\n    }\n\n    receive() external payable {\n        depositTo(msg.sender);\n    }\n\n    function _incrementDeposit(address account, uint256 amount) internal {\n        DepositInfo storage info = deposits[account];\n        uint256 newAmount = info.deposit + amount;\n        require(newAmount <= type(uint112).max, \"deposit overflow\");\n        info.deposit = uint112(newAmount);\n    }\n\n    /**\n     * add to the deposit of the given account\n     */\n    function depositTo(address account) public payable {\n        _incrementDeposit(account, msg.value);\n        DepositInfo storage info = deposits[account];\n        emit Deposited(account, info.deposit);\n    }\n\n    /**\n     * add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param unstakeDelaySec the new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 unstakeDelaySec) public payable {\n        DepositInfo storage info = deposits[msg.sender];\n        require(unstakeDelaySec > 0, \"must specify unstake delay\");\n        require(unstakeDelaySec >= info.unstakeDelaySec, \"cannot decrease unstake time\");\n        uint256 stake = info.stake + msg.value;\n        require(stake > 0, \"no stake specified\");\n        require(stake <= type(uint112).max, \"stake overflow\");\n        deposits[msg.sender] = DepositInfo(\n            info.deposit,\n            true,\n            uint112(stake),\n            unstakeDelaySec,\n            0\n        );\n        emit StakeLocked(msg.sender, stake, unstakeDelaySec);\n    }\n\n    /**\n     * attempt to unlock the stake.\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(info.unstakeDelaySec != 0, \"not staked\");\n        require(info.staked, \"already unstaking\");\n        uint48 withdrawTime = uint48(block.timestamp) + info.unstakeDelaySec;\n        info.withdrawTime = withdrawTime;\n        info.staked = false;\n        emit StakeUnlocked(msg.sender, withdrawTime);\n    }\n\n\n    /**\n     * withdraw from the (unlocked) stake.\n     * must first call unlockStake and wait for the unstakeDelay to pass\n     * @param withdrawAddress the address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external {\n        DepositInfo storage info = deposits[msg.sender];\n        uint256 stake = info.stake;\n        require(stake > 0, \"No stake to withdraw\");\n        require(info.withdrawTime > 0, \"must call unlockStake() first\");\n        require(info.withdrawTime <= block.timestamp, \"Stake withdrawal is not due\");\n        info.unstakeDelaySec = 0;\n        info.withdrawTime = 0;\n        info.stake = 0;\n        emit StakeWithdrawn(msg.sender, withdrawAddress, stake);\n        (bool success,) = withdrawAddress.call{value : stake}(\"\");\n        require(success, \"failed to withdraw stake\");\n    }\n\n    /**\n     * withdraw from the deposit.\n     * @param withdrawAddress the address to send withdrawn value.\n     * @param withdrawAmount the amount to withdraw.\n     */\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\n        info.deposit = uint112(info.deposit - withdrawAmount);\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n        (bool success,) = withdrawAddress.call{value : withdrawAmount}(\"\");\n        require(success, \"failed to withdraw\");\n    }\n}\n"
    },
    "@account-abstraction/contracts/interfaces/IAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./UserOperation.sol\";\n\ninterface IAccount {\n\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp the operation that is about to be executed.\n     * @param userOpHash hash of the user's request data. can be used as the basis for signature.\n     * @param missingAccountFunds missing funds on the account's deposit in the entrypoint.\n     *      This is the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\n     *      The excess is left as a deposit in the entrypoint, for future calls.\n     *      can be withdrawn anytime using \"entryPoint.withdrawTo()\"\n     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero.\n     * @return validationData packaged ValidationData structure. use `_packValidationData` and `_unpackValidationData` to encode and decode\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *         otherwise, an address of an \"authorizer\" contract.\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <6-byte> validAfter - first timestamp this operation is valid\n     *      If an account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds)\n    external returns (uint256 validationData);\n}\n"
    },
    "@account-abstraction/contracts/interfaces/IAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./UserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n\n    /**\n     * validate aggregated signature.\n     * revert if the aggregated signature does not match the given list of operations.\n     */\n    function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature) external view;\n\n    /**\n     * validate signature of a single userOp\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp the userOperation received from the user.\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\n     *    (usually empty, unless account and aggregator support some kind of \"multisig\"\n     */\n    function validateUserOpSignature(UserOperation calldata userOp)\n    external view returns (bytes memory sigForUserOp);\n\n    /**\n     * aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation\n     * @param userOps array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature the aggregated signature\n     */\n    function aggregateSignatures(UserOperation[] calldata userOps) external view returns (bytes memory aggregatedSignature);\n}\n"
    },
    "@account-abstraction/contracts/interfaces/IEntryPoint.sol": {
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./UserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\nimport \"./INonceManager.sol\";\n\ninterface IEntryPoint is IStakeManager, INonceManager {\n\n    /***\n     * An event emitted after each successful request\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\n     * @param sender - the account that generates this request.\n     * @param paymaster - if non-null, the paymaster that pays for this request.\n     * @param nonce - the nonce value from the request.\n     * @param success - true if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution).\n     */\n    event UserOperationEvent(bytes32 indexed userOpHash, address indexed sender, address indexed paymaster, uint256 nonce, bool success, uint256 actualGasCost, uint256 actualGasUsed);\n\n    /**\n     * account \"sender\" was deployed.\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender the account that is deployed\n     * @param factory the factory used to deploy this account (in the initCode)\n     * @param paymaster the paymaster used by this UserOp\n     */\n    event AccountDeployed(bytes32 indexed userOpHash, address indexed sender, address factory, address paymaster);\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length\n     * @param userOpHash the request unique identifier.\n     * @param sender the sender of this request\n     * @param nonce the nonce used in the request\n     * @param revertReason - the return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason);\n\n    /**\n     * an event emitted by handleOps(), before starting the execution loop.\n     * any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * signature aggregator used by the following UserOperationEvents within this bundle.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * a custom revert error of handleOps, to identify the offending op.\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\n     *  @param reason - revert reason\n     *      The string starts with a unique code \"AAmn\", where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *      so a failure can be attributed to the correct entity.\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    /**\n     * Successful result from simulateValidation.\n     * @param returnInfo gas and time-range returned values\n     * @param senderInfo stake information about the sender\n     * @param factoryInfo stake information about the factory (if any)\n     * @param paymasterInfo stake information about the paymaster (if any)\n     */\n    error ValidationResult(ReturnInfo returnInfo,\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo);\n\n    /**\n     * Successful result from simulateValidation, if the account returns a signature aggregator\n     * @param returnInfo gas and time-range returned values\n     * @param senderInfo stake information about the sender\n     * @param factoryInfo stake information about the factory (if any)\n     * @param paymasterInfo stake information about the paymaster (if any)\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\n     */\n    error ValidationResultWithAggregation(ReturnInfo returnInfo,\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo,\n        AggregatorStakeInfo aggregatorInfo);\n\n    /**\n     * return value of getSenderAddress\n     */\n    error SenderAddressResult(address sender);\n\n    /**\n     * return value of simulateHandleOp\n     */\n    error ExecutionResult(uint256 preOpGas, uint256 paid, uint48 validAfter, uint48 validUntil, bool targetSuccess, bytes targetResult);\n\n    //UserOps handled, per aggregator\n    struct UserOpsPerAggregator {\n        UserOperation[] userOps;\n\n        // aggregator address\n        IAggregator aggregator;\n        // aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperation.\n     * no signature aggregator is used.\n     * if any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\n     * @param beneficiary the address to receive the fees\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     */\n    function getUserOpHash(UserOperation calldata userOp) external view returns (bytes32);\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\n     * @param userOp the user operation to validate.\n     */\n    function simulateValidation(UserOperation calldata userOp) external;\n\n    /**\n     * gas and return values during simulation\n     * @param preOpGas the gas used for validation (including preValidationGas)\n     * @param prefund the required prefund for this operation\n     * @param sigFailed validateUserOp's (or paymaster's) signature check failed\n     * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\n     * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        bool sigFailed;\n        uint48 validAfter;\n        uint48 validUntil;\n        bytes paymasterContext;\n    }\n\n    /**\n     * returned aggregated signature info.\n     * the aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address aggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * this method always revert, and returns the address in SenderAddressResult error\n     * @param initCode the constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n\n    /**\n     * simulate full execution of a UserOperation (including both validation and target execution)\n     * this method will always revert with \"ExecutionResult\".\n     * it performs full validation of the UserOperation, but ignores signature error.\n     * an optional target address is called after the userop succeeds, and its value is returned\n     * (before the entire call is reverted)\n     * Note that in order to collect the the success/failure of the target call, it must be executed\n     * with trace enabled to track the emitted events.\n     * @param op the UserOperation to simulate\n     * @param target if nonzero, a target address to call after userop simulation. If called, the targetSuccess and targetResult\n     *        are set to the return from that call.\n     * @param targetCallData callData to pass to target address\n     */\n    function simulateHandleOp(UserOperation calldata op, address target, bytes calldata targetCallData) external;\n}\n\n"
    },
    "@account-abstraction/contracts/interfaces/INonceManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\ninterface INonceManager {\n\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(address sender, uint192 key)\n    external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"
    },
    "@account-abstraction/contracts/interfaces/IPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./UserOperation.sol\";\n\n/**\n * the interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\n * a paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\n */\ninterface IPaymaster {\n\n    enum PostOpMode {\n        opSucceeded, // user op succeeded\n        opReverted, // user op reverted. still has to pay for gas.\n        postOpReverted //user op succeeded, but caused postOp to revert. Now it's a 2nd call, after user's op was deliberately reverted.\n    }\n\n    /**\n     * payment validation: check if paymaster agrees to pay.\n     * Must verify sender is the entryPoint.\n     * Revert to reject this request.\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted)\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\n     * @param userOp the user operation\n     * @param userOpHash hash of the user's request data.\n     * @param maxCost the maximum cost of this transaction (based on maximum gas and gas price from userOp)\n     * @return context value to send to a postOp\n     *      zero length to signify postOp is not required.\n     * @return validationData signature and time-range of this operation, encoded the same as the return value of validateUserOperation\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *         otherwise, an address of an \"authorizer\" contract.\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <6-byte> validAfter - first timestamp this operation is valid\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\n    external returns (bytes memory context, uint256 validationData);\n\n    /**\n     * post-operation handler.\n     * Must verify sender is the entryPoint\n     * @param mode enum with the following options:\n     *      opSucceeded - user operation succeeded.\n     *      opReverted  - user op reverted. still has to pay for gas.\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\n     * @param context - the context value returned by validatePaymasterUserOp\n     * @param actualGasCost - actual gas used so far (without this postOp call).\n     */\n    function postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external;\n}\n"
    },
    "@account-abstraction/contracts/interfaces/IStakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\n/**\n * manage deposits and stakes.\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\n * stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager {\n\n    event Deposited(\n        address indexed account,\n        uint256 totalDeposit\n    );\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /// Emitted when stake or unstake delay are modified\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    /// Emitted once a stake is scheduled for withdrawal\n    event StakeUnlocked(\n        address indexed account,\n        uint256 withdrawTime\n    );\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit the entity's deposit\n     * @param staked true if this entity is staked.\n     * @param stake actual amount of ether staked for this entity.\n     * @param unstakeDelaySec minimum delay to withdraw the stake.\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\n     * @dev sizes were chosen so that (deposit,staked, stake) fit into one cell (used during handleOps)\n     *    and the rest fit into a 2nd cell.\n     *    112 bit allows for 10^15 eth\n     *    48 bit for full timestamp\n     *    32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint112 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    //API struct used by getStakeInfo and simulateValidation\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /// @return info - full deposit information of given account\n    function getDepositInfo(address account) external view returns (DepositInfo memory info);\n\n    /// @return the deposit (for gas payment) of the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * add to the deposit of the given account\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) external payable;\n\n    /**\n     * attempt to unlock the stake.\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * withdraw from the (unlocked) stake.\n     * must first call unlockStake and wait for the unstakeDelay to pass\n     * @param withdrawAddress the address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * withdraw from the deposit.\n     * @param withdrawAddress the address to send withdrawn value.\n     * @param withdrawAmount the amount to withdraw.\n     */\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external;\n}\n"
    },
    "@account-abstraction/contracts/interfaces/UserOperation.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable no-inline-assembly */\n\nimport {calldataKeccak} from \"../core/Helpers.sol\";\n\n/**\n * User Operation struct\n * @param sender the sender account of this request.\n     * @param nonce unique value the sender uses to verify it is not a replay.\n     * @param initCode if set, the account contract will be created by this constructor/\n     * @param callData the method call to execute on this account.\n     * @param callGasLimit the gas limit passed to the callData method call.\n     * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\n     * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\n     * @param maxFeePerGas same as EIP-1559 gas parameter.\n     * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\n     * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\n     * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n     */\n    struct UserOperation {\n\n        address sender;\n        uint256 nonce;\n        bytes initCode;\n        bytes callData;\n        uint256 callGasLimit;\n        uint256 verificationGasLimit;\n        uint256 preVerificationGas;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n        bytes paymasterAndData;\n        bytes signature;\n    }\n\n/**\n * Utility functions helpful when working with UserOperation structs.\n */\nlibrary UserOperationLib {\n\n    function getSender(UserOperation calldata userOp) internal pure returns (address) {\n        address data;\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\n        assembly {data := calldataload(userOp)}\n        return address(uint160(data));\n    }\n\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\n    // pay above what he signed for.\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint256) {\n    unchecked {\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        if (maxFeePerGas == maxPriorityFeePerGas) {\n            //legacy mode (for networks that don't support basefee opcode)\n            return maxFeePerGas;\n        }\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n    }\n    }\n\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\n        address sender = getSender(userOp);\n        uint256 nonce = userOp.nonce;\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\n        uint256 callGasLimit = userOp.callGasLimit;\n        uint256 verificationGasLimit = userOp.verificationGasLimit;\n        uint256 preVerificationGas = userOp.preVerificationGas;\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\n\n        return abi.encode(\n            sender, nonce,\n            hashInitCode, hashCallData,\n            callGasLimit, verificationGasLimit, preVerificationGas,\n            maxFeePerGas, maxPriorityFeePerGas,\n            hashPaymasterAndData\n        );\n    }\n\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\n        return keccak256(pack(userOp));\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "@account-abstraction/contracts/utils/Exec.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.5 <0.9.0;\n\n// solhint-disable no-inline-assembly\n\n/**\n * Utility functions helpful when making different kinds of contract calls in Solidity.\n */\nlibrary Exec {\n\n    function call(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    function staticcall(\n        address to,\n        bytes memory data,\n        uint256 txGas\n    ) internal view returns (bool success) {\n        assembly {\n            success := staticcall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    function delegateCall(\n        address to,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly {\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    // get returned data from last call or calldelegate\n    function getReturnData(uint256 maxLen) internal pure returns (bytes memory returnData) {\n        assembly {\n            let len := returndatasize()\n            if gt(len, maxLen) {\n                len := maxLen\n            }\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, add(len, 0x20)))\n            mstore(ptr, len)\n            returndatacopy(add(ptr, 0x20), 0, len)\n            returnData := ptr\n        }\n    }\n\n    // revert with explicit byte array (probably reverted info from call)\n    function revertWithData(bytes memory returnData) internal pure {\n        assembly {\n            revert(add(returnData, 32), mload(returnData))\n        }\n    }\n\n    function callAndRevert(address to, bytes memory data, uint256 maxLen) internal {\n        bool success = call(to,0,data,gasleft());\n        if (!success) {\n            revertWithData(getReturnData(maxLen));\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.6) (utils/Base64.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 0x20)\n            let dataPtr := data\n            let endPtr := add(data, mload(data))\n\n            // In some cases, the last iteration will read bytes after the end of the data. We cache the value, and\n            // set it to zero to make sure no dirty bytes are read in that section.\n            let afterPtr := add(endPtr, 0x20)\n            let afterCache := mload(afterPtr)\n            mstore(afterPtr, 0x00)\n\n            // Run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 byte (24 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F to bitmask the least significant 6 bits.\n                // Use this as an index into the lookup table, mload an entire word\n                // so the desired character is in the least significant byte, and\n                // mstore8 this least significant byte into the result and continue.\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // Reset the value that was cached\n            mstore(afterPtr, afterCache)\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/base/Executor.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Enum} from \"../common/Enum.sol\";\n\n/// @title Executor - A contract that can execute transactions\nabstract contract Executor {\n    // Could add a flag fromEntryPoint for AA txn\n    event ExecutionFailure(\n        address indexed to,\n        uint256 indexed value,\n        bytes indexed data,\n        Enum.Operation operation,\n        uint256 txGas\n    );\n    event ExecutionSuccess(\n        address indexed to,\n        uint256 indexed value,\n        bytes indexed data,\n        Enum.Operation operation,\n        uint256 txGas\n    );\n\n    function _execute(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 txGas\n    ) internal returns (bool success) {\n        if (operation == Enum.Operation.DelegateCall) {\n            assembly {\n                success := delegatecall(\n                    txGas,\n                    to,\n                    add(data, 0x20),\n                    mload(data),\n                    0,\n                    0\n                )\n            }\n        } else {\n            assembly {\n                success := call(\n                    txGas,\n                    to,\n                    value,\n                    add(data, 0x20),\n                    mload(data),\n                    0,\n                    0\n                )\n            }\n        }\n        if (success) emit ExecutionSuccess(to, value, data, operation, txGas);\n        else emit ExecutionFailure(to, value, data, operation, txGas);\n    }\n}\n"
    },
    "contracts/base/FallbackManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {SelfAuthorized} from \"../common/SelfAuthorized.sol\";\nimport {FallbackManagerErrors} from \"../common/Errors.sol\";\n\n/**\n *   @title Fallback Manager - A contract that manages fallback calls made to the Smart Account\n *   @dev Fallback calls are handled by a `handler` contract that is stored at FALLBACK_HANDLER_STORAGE_SLOT\n *        fallback calls are not delegated to the `handler` so they can not directly change Smart Account storage\n */\nabstract contract FallbackManager is SelfAuthorized, FallbackManagerErrors {\n    // keccak-256 hash of \"fallback_manager.handler.address\" subtracted by 1\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT =\n        0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d4;\n\n    uint256[24] private __gap;\n\n    event ChangedFallbackHandler(\n        address indexed previousHandler,\n        address indexed handler\n    );\n\n    fallback() external {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n\n        assembly {\n            let handler := sload(slot)\n            if iszero(handler) {\n                return(0, 0)\n            }\n            calldatacopy(0, 0, calldatasize())\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            mstore(calldatasize(), shl(96, caller()))\n            // Add 20 bytes for the address appended add the end\n            let success := call(\n                gas(),\n                handler,\n                0,\n                0,\n                add(calldatasize(), 20),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n            if iszero(success) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n\n    /// @dev Allows to add a contract to handle fallback calls.\n    ///      Only fallback calls without value and with data will be forwarded\n    /// @param handler contract to handle fallback calls.\n    function setFallbackHandler(address handler) external virtual;\n\n    function getFallbackHandler() public view returns (address _handler) {\n        assembly {\n            _handler := sload(FALLBACK_HANDLER_STORAGE_SLOT)\n        }\n    }\n\n    function _setFallbackHandler(address handler) internal {\n        if (handler == address(0)) revert HandlerCannotBeZero();\n        address previousHandler;\n\n        assembly {\n            previousHandler := sload(FALLBACK_HANDLER_STORAGE_SLOT)\n            //}\n            //bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n\n            //assembly {\n            sstore(FALLBACK_HANDLER_STORAGE_SLOT, handler)\n        }\n        emit ChangedFallbackHandler(previousHandler, handler);\n    }\n}\n"
    },
    "contracts/base/ModuleManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {SelfAuthorized} from \"../common/SelfAuthorized.sol\";\nimport {Executor, Enum} from \"./Executor.sol\";\nimport {ModuleManagerErrors} from \"../common/Errors.sol\";\n\n/**\n * @title Module Manager - A contract that manages modules that can execute transactions\n *        on behalf of the Smart Account via this contract.\n */\nabstract contract ModuleManager is\n    SelfAuthorized,\n    Executor,\n    ModuleManagerErrors\n{\n    address internal constant SENTINEL_MODULES = address(0x1);\n    mapping(address => address) internal _modules;\n    uint256[24] private __gap;\n\n    // Events\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n    event ModuleTransaction(\n        address module,\n        address to,\n        uint256 value,\n        bytes data,\n        Enum.Operation operation\n    );\n\n    /**\n     * @dev Adds a module to the allowlist.\n     * @notice This SHOULD only be done via userOp or a selfcall.\n     */\n    function enableModule(address module) external virtual;\n\n    /**\n     * @dev Setups module for this Smart Account and enables it.\n     * @notice This SHOULD only be done via userOp or a selfcall.\n     */\n    function setupAndEnableModule(\n        address setupContract,\n        bytes memory setupData\n    ) external virtual returns (address);\n\n    /**\n     * @dev Returns array of modules. Useful for a widget\n     * @param start Start of the page.\n     * @param pageSize Maximum number of modules that should be returned.\n     * @return array Array of modules.\n     * @return next Start of the next page.\n     */\n    function getModulesPaginated(\n        address start,\n        uint256 pageSize\n    ) external view returns (address[] memory array, address next) {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount;\n        address currentModule = _modules[start];\n        while (\n            currentModule != address(0x0) &&\n            currentModule != SENTINEL_MODULES &&\n            moduleCount < pageSize\n        ) {\n            array[moduleCount] = currentModule;\n            currentModule = _modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n\n    /**\n     * @dev Allows a Module to execute a Smart Account transaction without any further confirmations.\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     */\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 txGas\n    ) public virtual returns (bool success) {\n        // Only whitelisted modules are allowed.\n        if (\n            msg.sender == SENTINEL_MODULES || _modules[msg.sender] == address(0)\n        ) revert ModuleNotEnabled(msg.sender);\n        // Execute transaction without further confirmations.\n        // Can add guards here to allow delegatecalls for selected modules (msg.senders) only\n        success = _execute(\n            to,\n            value,\n            data,\n            operation,\n            txGas == 0 ? gasleft() : txGas\n        );\n    }\n\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual returns (bool) {\n        return execTransactionFromModule(to, value, data, operation, 0);\n    }\n\n    /**\n     * @dev Allows a Module to execute a wallet transaction without any further confirmations and returns data\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     */\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public returns (bool success, bytes memory returnData) {\n        success = execTransactionFromModule(to, value, data, operation);\n\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    /**\n     * @dev Allows a Module to execute a batch of Smart Account transactions without any further confirmations.\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operations Operation type of module transaction.\n     */\n    function execBatchTransactionFromModule(\n        address[] calldata to,\n        uint256[] calldata value,\n        bytes[] calldata data,\n        Enum.Operation[] calldata operations\n    ) public virtual returns (bool success) {\n        if (\n            to.length == 0 ||\n            to.length != value.length ||\n            value.length != data.length ||\n            data.length != operations.length\n        )\n            revert WrongBatchProvided(\n                to.length,\n                value.length,\n                data.length,\n                operations.length\n            );\n\n        // Only whitelisted modules are allowed.\n        if (\n            msg.sender == SENTINEL_MODULES || _modules[msg.sender] == address(0)\n        ) revert ModuleNotEnabled(msg.sender);\n\n        for (uint256 i; i < to.length; ) {\n            // Execute transaction without further confirmations.\n            success = _executeFromModule(\n                to[i],\n                value[i],\n                data[i],\n                operations[i]\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns if a module is enabled\n     * @return True if the module is enabled\n     */\n    function isModuleEnabled(address module) public view returns (bool) {\n        return SENTINEL_MODULES != module && _modules[module] != address(0);\n    }\n\n    /**\n     * @dev Adds a module to the allowlist.\n     * @notice This can only be done via a userOp or a selfcall.\n     * @notice Enables the module `module` for the wallet.\n     * @param module Module to be allow-listed.\n     */\n    function _enableModule(address module) internal virtual {\n        // Module address cannot be null or sentinel.\n        if (module == address(0) || module == SENTINEL_MODULES)\n            revert ModuleCannotBeZeroOrSentinel(module);\n        // Module cannot be added twice.\n        if (_modules[module] != address(0)) revert ModuleAlreadyEnabled(module);\n\n        _modules[module] = _modules[SENTINEL_MODULES];\n        _modules[SENTINEL_MODULES] = module;\n\n        emit EnabledModule(module);\n    }\n\n    /**\n     * @dev Setups module for this Smart Account and enables it.\n     * @notice This can only be done via userOp or a selfcall.\n     */\n    function _setupAndEnableModule(\n        address setupContract,\n        bytes memory setupData\n    ) internal virtual returns (address) {\n        address module = _setupModule(setupContract, setupData);\n        _enableModule(module);\n        return module;\n    }\n\n    /**\n     * @dev Removes a module from the allowlist.\n     * @notice This can only be done via a wallet transaction.\n     * @notice Disables the module `module` for the wallet.\n     * @param prevModule Module that pointed to the module to be removed in the linked list\n     * @param module Module to be removed.\n     */\n    function _disableModule(\n        address prevModule,\n        address module\n    ) internal virtual {\n        // Validate module address and check that it corresponds to module index.\n        if (module == address(0) || module == SENTINEL_MODULES)\n            revert ModuleCannotBeZeroOrSentinel(module);\n        if (_modules[prevModule] != module)\n            revert ModuleAndPrevModuleMismatch(\n                module,\n                _modules[prevModule],\n                prevModule\n            );\n        _modules[prevModule] = _modules[module];\n        delete _modules[module];\n        emit DisabledModule(module);\n    }\n\n    // TODO: can use not executor.execute, but SmartAccount._call for the unification\n\n    function _executeFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) internal returns (bool success) {\n        success = _execute(to, value, data, operation, gasleft());\n        if (success) {\n            emit ModuleTransaction(msg.sender, to, value, data, operation);\n            emit ExecutionFromModuleSuccess(msg.sender);\n        } else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /**\n     * @notice Setup function sets the initial storage of the contract.\n     * @param setupContract initializing the auth module; can be a module factory or a registry for multiple accounts.\n     * @param setupData modules setup data (a standard calldata for the module setup contract)\n     */\n    function _initialSetupModules(\n        address setupContract,\n        bytes memory setupData\n    ) internal virtual returns (address) {\n        address initialAuthorizationModule = _setupModule(\n            setupContract,\n            setupData\n        );\n\n        // Module address cannot be null or sentinel.\n        if (\n            initialAuthorizationModule == address(0) ||\n            initialAuthorizationModule == SENTINEL_MODULES\n        ) revert ModuleCannotBeZeroOrSentinel(initialAuthorizationModule);\n\n        _modules[initialAuthorizationModule] = SENTINEL_MODULES;\n        _modules[SENTINEL_MODULES] = initialAuthorizationModule;\n        return initialAuthorizationModule;\n    }\n\n    function _setupModule(\n        address setupContract,\n        bytes memory setupData\n    ) internal returns (address module) {\n        if (setupContract == address(0)) revert(\"Wrong Module Setup Address\");\n        assembly {\n            let success := call(\n                gas(),\n                setupContract,\n                0,\n                add(setupData, 0x20),\n                mload(setupData),\n                0,\n                0\n            )\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, returndatasize())\n            if iszero(success) {\n                revert(ptr, returndatasize())\n            }\n            module := mload(ptr)\n        }\n    }\n}\n"
    },
    "contracts/BaseSmartAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {IAccount} from \"@account-abstraction/contracts/interfaces/IAccount.sol\";\nimport {IEntryPoint} from \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport {UserOperationLib, UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\nimport {BaseSmartAccountErrors} from \"./common/Errors.sol\";\nimport \"@account-abstraction/contracts/core/Helpers.sol\";\n\n/**\n * Basic account implementation.\n * This contract provides the basic logic for implementing the IAccount interface: validateUserOp function\n * Specific account implementation should inherit it and provide the account-specific logic\n */\nabstract contract BaseSmartAccount is IAccount, BaseSmartAccountErrors {\n    using UserOperationLib for UserOperation;\n\n    // Return value in case of signature failure, with no time-range.\n    // equivalent to _packValidationData(true,0,0);\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n    /**\n     * @dev Initialize the Smart Account with required states.\n     * @param handler Default fallback handler for the Smart Account.\n     * @param sessionKeyModuleContract Initializes the session key module\n     * @param authModuleSetupContract Initializes the auth module; can be a factory or registry for multiple accounts.\n     * @param authModuleSetupData Contains address of the Setup Contract and setup data.\n     * @notice Ensure this is callable only once (use initializer modifier or state checks).\n     */\n    function init(\n        address handler,\n        address sessionKeyModuleContract,\n        address authModuleSetupContract,\n        bytes calldata authModuleSetupData\n    ) external virtual returns (address);\n\n    /**\n     * Validates the userOp.\n     * @param userOp validate the userOp.signature field\n     * @param userOpHash convenient field: the hash of the request, to check the signature against\n     *          (also hashes the entrypoint and chain id)\n     * @param missingAccountFunds the amount of funds required to pay to EntryPoint to pay for the userOp execution.\n     * @return validationData signature and time-range of this operation\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *         otherwise, an address of an \"authorizer\" contract.\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <6-byte> validAfter - first timestamp this operation is valid\n     *      If no time-range in account, return SIG_VALIDATION_FAILED (1) for signature failure.\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external virtual override returns (uint256);\n\n    /**\n     * @return nonce the account nonce.\n     * @dev This method returns the next sequential nonce.\n     * @notice Provides 2D nonce functionality by allowing to use a nonce of a specific key.\n     */\n    function nonce(uint192 _key) public view virtual returns (uint256) {\n        return entryPoint().getNonce(address(this), _key);\n    }\n\n    /**\n     * return the entryPoint used by this account.\n     * subclass should return the current entryPoint used by this account.\n     */\n    function entryPoint() public view virtual returns (IEntryPoint);\n\n    /**\n     * sends to the entrypoint (msg.sender) the missing funds for this transaction.\n     * subclass MAY override this method for better funds management\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\n     * it will not be required to send again)\n     * @param missingAccountFunds the minimum value this method should send the entrypoint.\n     *  this value MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n     */\n    function _payPrefund(uint256 missingAccountFunds) internal virtual {\n        if (missingAccountFunds != 0) {\n            payable(msg.sender).call{\n                value: missingAccountFunds,\n                gas: type(uint256).max\n            }(\"\");\n            //ignore failure (its EntryPoint's job to verify, not account.)\n        }\n    }\n}\n"
    },
    "contracts/common/Enum.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\n/// @title Enum - Collection of enums\nabstract contract Enum {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n}\n"
    },
    "contracts/common/Errors.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\ncontract BaseSmartAccountErrors {\n    /**\n     * @notice Throws at onlyEntryPoint when msg.sender is not an EntryPoint set for this Smart Account\n     * @param caller address that tried to call onlyEntryPoint-protected method\n     */\n    error CallerIsNotAnEntryPoint(address caller);\n}\n\ncontract FallbackManagerErrors {\n    /**\n     * @notice Throws if zero address has been provided as Fallback Handler address\n     */\n    error HandlerCannotBeZero();\n}\n\ncontract ModuleManagerErrors {\n    /**\n     * @notice Throws when trying to initialize module manager that already been initialized\n     */\n    error ModulesAlreadyInitialized();\n\n    /**\n     * @notice Throws when a delegatecall in course of module manager initialization has failed\n     */\n    error ModulesSetupExecutionFailed();\n\n    /**\n     * @notice Throws when address(0) or SENTINEL_MODULES constant has been provided as a module address\n     * @param module Module address provided\n     */\n    error ModuleCannotBeZeroOrSentinel(address module);\n\n    /**\n     * @notice Throws when trying to enable module that has already been enabled\n     * @param module Module address provided\n     */\n    error ModuleAlreadyEnabled(address module);\n\n    /**\n     * @notice Throws when module and previous module mismatch\n     * @param expectedModule expected module at modules[prevModule]\n     * @param returnedModule the module that has been found at modules[prevModule]\n     * @param prevModule previous module address provided at call\n     */\n    error ModuleAndPrevModuleMismatch(\n        address expectedModule,\n        address returnedModule,\n        address prevModule\n    );\n\n    /**\n     * @notice Throws when trying to execute transaction from module that is not enabled\n     * @param module Module address provided\n     */\n    error ModuleNotEnabled(address module);\n\n    /**\n     * @notice Throws when data for executeBatchCall provided in wrong format (i.e. empty array or lengths mismatch)\n     * @param destLength length of destination contracts array\n     * @param valueLength length of txn values array\n     * @param funcLength length of function signatures array\n     * @param operationLength length of operation types array. 0 if there's no operations\n     */\n    error WrongBatchProvided(\n        uint256 destLength,\n        uint256 valueLength,\n        uint256 funcLength,\n        uint256 operationLength\n    );\n}\n\ncontract SmartAccountErrors is BaseSmartAccountErrors, ModuleManagerErrors {\n    /**\n     * @notice Throws if zero address has been provided as Entry Point address\n     */\n    error EntryPointCannotBeZero();\n\n    /**\n     * @notice Throws at mixedAuth when msg.sender is not an owner neither _self\n     * @param caller address that tried to call mixedAuth-protected method\n     */\n    error MixedAuthFail(address caller);\n\n    /**\n     * @notice Throws if trying to change an owner of a SmartAccount to the zero address\n     */\n    error OwnerCannotBeZero();\n\n    /**\n     * @notice Throws if zero address has been provided as Base Implementation address\n     */\n    error BaseImplementationCannotBeZero();\n\n    /**\n     * @notice Throws if there is no code at implementationAddress\n     * @param implementationAddress implementation address provided\n     */\n    error InvalidImplementation(address implementationAddress);\n\n    /**\n     * @notice Throws at onlyOwner when msg.sender is not an owner\n     * @param caller address that tried to call onlyOwner method\n     */\n    error CallerIsNotOwner(address caller);\n\n    /**\n     * @notice Throws at _requireFromEntryPointOrOwner when msg.sender is not an EntryPoint neither an owner\n     * @param caller address that tried to call _requireFromEntryPointOrOwner-protected method\n     */\n    error CallerIsNotEntryPointOrOwner(address caller);\n\n    /**\n     * @notice Throws at _requireFromEntryPointOrSelf when msg.sender is not an EntryPoint neither self\n     * @param caller address that tried to call _requireFromEntryPointOrSelf-protected method\n     */\n    error CallerIsNotEntryPointOrSelf(address caller);\n\n    /**\n     * @notice Throws at _requireFromEntryPoint when msg.sender is not an EntryPoint\n     * @param caller address that tried to call _requireFromEntryPoint-protected method\n     */\n    error CallerIsNotEntryPoint(address caller);\n\n    /**\n     * @notice Throws if trying to initialize a Smart Account that has already been initialized\n     */\n    error AlreadyInitialized();\n\n    /**\n     * @notice Throws if contract signature is provided in frong format\n     * @param uintS s converted to uint256\n     * @param contractSignatureLength length of a contract signature\n     * @param signatureLength the whole signature length\n     */\n    error WrongContractSignatureFormat(\n        uint256 uintS,\n        uint256 contractSignatureLength,\n        uint256 signatureLength\n    );\n\n    /**\n     * @notice Throws if isValidSignature for the conrtact signature and data hash differs from EIP1271 Magic Value\n     * @param contractSignature the contract signature that has been verified\n     */\n    error WrongContractSignature(bytes contractSignature);\n\n    /**\n     * @notice Throws when if trying to transfer to zero address\n     */\n    error TransferToZeroAddressAttempt();\n\n    /**\n     * @notice Throws when module address taken from signature is not enabled\n     * @param moduleAddressProvided module address taken from signature\n     */\n    error WrongValidationModule(address moduleAddressProvided);\n\n    /**\n     * @notice Thrown when the function that must be called only via delegatecall is called directly\n     */\n    error DelegateCallsOnly();\n\n    /**\n     * @notice Thrown when trying to use address of the Smart Account as an owner for itself\n     */\n    error OwnerCanNotBeSelf();\n\n    /**\n     * @notice Thrown when trying to use current owner as a new owner in a _setOwner() call\n     */\n    error OwnerProvidedIsSame();\n}\n\ncontract SmartAccountFactoryErrors is SmartAccountErrors {\n    /**\n     * @notice Throws when the new Proxy deployment fails\n     * @param owner Owner of a Proxy (Smart Account)\n     * @param index Deployment index\n     */\n    error ProxyDeploymentFailed(address owner, uint256 index);\n}\n\ncontract SelfAuthorizedErrors {\n    /**\n     * @notice Throws when the caller is not address(this)\n     * @param caller Caller address\n     */\n    error CallerIsNotSelf(address caller);\n}\n\ncontract SingletonPaymasterErrors {\n    /**\n     * @notice Throws when the Entrypoint address provided is address(0)\n     */\n    error EntryPointCannotBeZero();\n\n    /**\n     * @notice Throws when the verifiying signer address provided is address(0)\n     */\n    error VerifyingSignerCannotBeZero();\n\n    /**\n     * @notice Throws when the paymaster address provided is address(0)\n     */\n    error PaymasterIdCannotBeZero();\n\n    /**\n     * @notice Throws when the 0 has been provided as deposit\n     */\n    error DepositCanNotBeZero();\n\n    /**\n     * @notice Throws when trying to withdraw to address(0)\n     */\n    error CanNotWithdrawToZeroAddress();\n\n    /**\n     * @notice Throws when trying to withdraw more than balance available\n     * @param amountRequired required balance\n     * @param currentBalance available balance\n     */\n    error InsufficientBalance(uint256 amountRequired, uint256 currentBalance);\n\n    /**\n     * @notice Throws when signature provided has invalid length\n     * @param sigLength length oif the signature provided\n     */\n    error InvalidPaymasterSignatureLength(uint256 sigLength);\n}\n\n//\n"
    },
    "contracts/common/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\n/// @title Reentrancy Guard - reentrancy protection\nabstract contract ReentrancyGuard {\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _reentrancyStatus;\n\n    error ReentrancyProtectionActivated();\n\n    modifier nonReentrant() {\n        if (_reentrancyStatus == ENTERED)\n            revert ReentrancyProtectionActivated();\n        _reentrancyStatus = ENTERED;\n        _;\n        _reentrancyStatus = NOT_ENTERED;\n    }\n\n    constructor() {\n        _reentrancyStatus = NOT_ENTERED;\n    }\n\n    function _isReentrancyGuardEntered() internal view returns (bool) {\n        return _reentrancyStatus == ENTERED;\n    }\n}\n"
    },
    "contracts/common/SecuredTokenTransfer.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\n/// @title SecuredTokenTransfer - Secure token transfer\nabstract contract SecuredTokenTransfer {\n    /// @dev Transfers a token and returns if it was a success\n    /// @param token Token that should be transferred\n    /// @param receiver Receiver to whom the token should be transferred\n    /// @param amount The amount of tokens that should be transferred\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal returns (bool transferred) {\n        require(token != address(0), \"token can not be zero address\");\n        require(token.code.length > 0, \"token contract doesn't exist\");\n        // 0xa9059cbb - keccack(\"transfer(address,uint256)\")\n        bytes memory data = abi.encodeWithSelector(\n            0xa9059cbb,\n            receiver,\n            amount\n        );\n\n        assembly {\n            // We write the return value to scratch space.\n            // See https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_memory.html#layout-in-memory\n            let success := call(\n                sub(gas(), 10000),\n                token,\n                0,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0x20\n            )\n            switch returndatasize()\n            case 0 {\n                transferred := success\n            }\n            case 0x20 {\n                transferred := iszero(or(iszero(success), iszero(mload(0))))\n            }\n            default {\n                transferred := 0\n            }\n        }\n    }\n}\n"
    },
    "contracts/common/SelfAuthorized.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {SelfAuthorizedErrors} from \"../common/Errors.sol\";\n\n/// @title SelfAuthorized - authorizes current contract to perform actions\ncontract SelfAuthorized is SelfAuthorizedErrors {\n    modifier authorized() {\n        // This is a function call as it minimized the bytecode size\n        _requireSelfCall();\n        _;\n    }\n\n    function _requireSelfCall() private view {\n        if (msg.sender != address(this)) revert CallerIsNotSelf(msg.sender);\n    }\n}\n"
    },
    "contracts/common/SignatureDecoder.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\nabstract contract SignatureDecoder {\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\n    /// @param signature concatenated rsv signatures\n    function _signatureSplit(\n        bytes memory signature\n    ) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so let's\n            // use the second best option, 'and'\n            v := and(mload(add(signature, 0x41)), 0xff)\n        }\n    }\n}\n"
    },
    "contracts/common/Stakeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IEntryPoint} from \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\n\n/**\n * @title Stakeable Entity\n * @author Fil Makarov - <filipp.makarov@biconomy.io>\n */\ncontract Stakeable is Ownable {\n    constructor(address _newOwner) {\n        _transferOwnership(_newOwner);\n    }\n\n    function addStake(\n        address epAddress,\n        uint32 unstakeDelaySec\n    ) external payable onlyOwner {\n        require(epAddress != address(0), \"Invalid EP address\");\n        IEntryPoint(epAddress).addStake{value: msg.value}(unstakeDelaySec);\n    }\n\n    function unlockStake(address epAddress) external onlyOwner {\n        require(epAddress != address(0), \"Invalid EP address\");\n        IEntryPoint(epAddress).unlockStake();\n    }\n\n    function withdrawStake(\n        address epAddress,\n        address payable withdrawAddress\n    ) external onlyOwner {\n        require(epAddress != address(0), \"Invalid EP address\");\n        IEntryPoint(epAddress).withdrawStake(withdrawAddress);\n    }\n}\n"
    },
    "contracts/deployer/Create3.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.17;\n\n/**\n  @title A library for deploying contracts EIP-3171 style.\n  @author Agustin Aguilar <aa@horizon.io>\n*/\nlibrary Create3 {\n    /**\n    @notice The bytecode for a contract that proxies the creation of another contract\n    @dev If deployed via CREATE2, decouple creationCode from child contract address.\n  \n  0x67363d3d37363d34f03d5260086018f3:\n      0x00  0x67  0x67XXXXXXXXXXXXXXXX  PUSH8 bytecode  0x363d3d37363d34f0\n      0x01  0x3d  0x3d                  RETURNDATASIZE  0 0x363d3d37363d34f0\n      0x02  0x52  0x52                  MSTORE\n      0x03  0x60  0x6008                PUSH1 08        8\n      0x04  0x60  0x6018                PUSH1 18        24 8\n      0x05  0xf3  0xf3                  RETURN\n\n  0x363d3d37363d34f0:\n      0x00  0x36  0x36                  CALLDATASIZE    cds\n      0x01  0x3d  0x3d                  RETURNDATASIZE  0 cds\n      0x02  0x3d  0x3d                  RETURNDATASIZE  0 0 cds\n      0x03  0x37  0x37                  CALLDATACOPY\n      0x04  0x36  0x36                  CALLDATASIZE    cds\n      0x05  0x3d  0x3d                  RETURNDATASIZE  0 cds\n      0x06  0x34  0x34                  CALLVALUE       val 0 cds\n      0x07  0xf0  0xf0                  CREATE          addr\n  */\n\n    bytes internal constant PROXY_CHILD_BYTECODE =\n        hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n\n    //                        KECCAK256_PROXY_CHILD_BYTECODE = keccak256(PROXY_CHILD_BYTECODE);\n    bytes32 internal constant KECCAK256_PROXY_CHILD_BYTECODE =\n        0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f;\n\n    error ErrorCreatingProxy();\n    error ErrorCreatingContract();\n    error TargetAlreadyExists();\n\n    /**\n    @notice Creates a new contract with given `_creationCode` and `_salt`\n    @param _salt Salt of the contract creation, resulting address will be derivated from this value only\n@param _creationCode Constructor code for contract to be deployed; it doesn't affect the resulting address.\n    @return addr of the deployed contract, reverts on error\n  */\n    function create3(\n        bytes32 _salt,\n        bytes memory _creationCode\n    ) internal returns (address addr) {\n        return create3(_salt, _creationCode, 0);\n    }\n\n    /**\n    @notice Creates a new contract with given `_creationCode` and `_salt`\n    @param _salt Salt of the contract creation, resulting address will be derivated from this value only\n    @param _creationCode Constructor code for contract to be deployed; it doesn't affect the resulting address.\n    @param _value In WEI of ETH to be forwarded to child contract\n    @return addr of the deployed contract, reverts on error\n  */\n    function create3(\n        bytes32 _salt,\n        bytes memory _creationCode,\n        uint256 _value\n    ) internal returns (address addr) {\n        // Creation code\n        bytes memory creationCode = PROXY_CHILD_BYTECODE;\n\n        // Get target final address\n        addr = addressOf(_salt);\n        if (codeSize(addr) != 0) revert TargetAlreadyExists();\n\n        // Create CREATE2 proxy\n        address proxy;\n        assembly {\n            proxy := create2(\n                0,\n                add(creationCode, 32),\n                mload(creationCode),\n                _salt\n            )\n        }\n        if (proxy == address(0)) revert ErrorCreatingProxy();\n\n        // Call proxy with final init code\n        (bool success, ) = proxy.call{value: _value}(_creationCode);\n        if (!success || codeSize(addr) == 0) revert ErrorCreatingContract();\n    }\n\n    function addressOfProxy(bytes32 _salt) internal view returns (address) {\n        return\n            address(\n                uint160(\n                    uint256(\n                        keccak256(\n                            abi.encodePacked(\n                                hex\"ff\",\n                                address(this),\n                                _salt,\n                                KECCAK256_PROXY_CHILD_BYTECODE\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    /**\n     * @notice Computes the resulting address of a contract deployed using address(this) and the given `_salt`\n     *\n     * @dev Address creation formula:\n     * keccak256(rlp([keccak256(0xff+address(this)+_salt+keccak256(childBytecode))[12:],0x01]))\n     *\n     * @param _salt Salt of the contract creation, resulting address will be derived from this value only\n     * @return addr of the deployed contract, reverts on error\n     */\n    function addressOf(bytes32 _salt) internal view returns (address) {\n        address proxy = addressOfProxy(_salt);\n        return\n            address(\n                uint160(\n                    uint256(\n                        keccak256(abi.encodePacked(hex\"d6_94\", proxy, hex\"01\"))\n                    )\n                )\n            );\n    }\n\n    /**\n    @notice Returns the size of the code on a given address\n    @param _addr Address that may or may not contain code\n    @return size of the code on the given `_addr`\n  */\n    function codeSize(address _addr) internal view returns (uint256 size) {\n        assembly {\n            size := extcodesize(_addr)\n        }\n    }\n}\n"
    },
    "contracts/deployer/Deployer.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.17;\n\nimport \"./Create3.sol\";\n\ncontract Deployer {\n    event ContractDeployed(address indexed contractAddress);\n\n    function deploy(bytes32 _salt, bytes calldata _creationCode) external {\n        address deployedContract = Create3.create3(_salt, _creationCode);\n        emit ContractDeployed(deployedContract);\n    }\n\n    function addressOf(bytes32 _salt) external view returns (address) {\n        return Create3.addressOf(_salt);\n    }\n}\n"
    },
    "contracts/estimation/SmartAccountNoAuth.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {BaseSmartAccount, IEntryPoint, UserOperation} from \"../BaseSmartAccount.sol\";\nimport {ModuleManager} from \"../base/ModuleManager.sol\";\nimport {FallbackManager} from \"../base/FallbackManager.sol\";\nimport {SignatureDecoder} from \"../common/SignatureDecoder.sol\";\nimport {SecuredTokenTransfer} from \"../common/SecuredTokenTransfer.sol\";\nimport {LibAddress} from \"../libs/LibAddress.sol\";\nimport {ISignatureValidator} from \"../interfaces/ISignatureValidator.sol\";\nimport {IERC165} from \"../interfaces/IERC165.sol\";\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\nimport {SmartAccountErrors} from \"../common/Errors.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {IAuthorizationModule} from \"../interfaces/IAuthorizationModule.sol\";\n\n/**\n * @title SmartAccount - EIP-4337 compatible smart contract wallet.\n * @dev This contract is the base for the Smart Account functionality.\n *         - It provides the functionality to execute both gnosis-style txns and AA (EIP-4337) userOps\n *         - It allows to receive and manage assets.\n *         - It is responsible for managing the modules and fallbacks.\n *         - The Smart Account can be extended with smodules, such as Social Recovery, Session Key and others.\n * @author Chirag Titiya - <chirag@biconomy.io>\n */\ncontract SmartAccountNoAuth is\n    BaseSmartAccount,\n    ModuleManager,\n    FallbackManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    IERC165,\n    ReentrancyGuard,\n    SmartAccountErrors,\n    ISignatureValidator\n{\n    using ECDSA for bytes32;\n    using LibAddress for address;\n\n    // Storage Version\n    string public constant VERSION = \"1.0.0\";\n\n    // Domain Seperators keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // solhint-disable-next-line\n    // keccak256(\"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,uint256 tokenGasPriceFactor,address gasToken,address refundReceiver,uint256 nonce)\");\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH =\n        0xda033865d68bf4a40a5a7cb4159a99e33dba8569e65ea3e38222eb12d9e66eee;\n\n    // /!\\ Owner storage. Deprecated. Left for storage layout compatibility /!\\\n    address public ownerDeprecated;\n\n    // changed to 2D nonce below\n    // @notice there is no _nonce\n    mapping(uint256 => uint256) public nonces;\n\n    // AA immutable storage\n    IEntryPoint private immutable ENTRY_POINT;\n    uint256 private immutable CHAIN_ID;\n    address private immutable SELF;\n\n    // Events\n\n    event ImplementationUpdated(\n        address indexed oldImplementation,\n        address indexed newImplementation\n    );\n    event AccountHandlePayment(bytes32 indexed txHash, uint256 indexed payment);\n    event SmartAccountReceivedNativeToken(\n        address indexed sender,\n        uint256 indexed value\n    );\n\n    /**\n     * @dev Constructor that sets the owner of the contract and the entry point contract.\n     *      _modules[SENTINEL_MODULES] = SENTINEL_MODULES protects implementation from initialization\n     * @param anEntryPoint The address of the entry point contract.\n     */\n    constructor(IEntryPoint anEntryPoint) {\n        _modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        SELF = address(this);\n        if (address(anEntryPoint) == address(0))\n            revert EntryPointCannotBeZero();\n        ENTRY_POINT = anEntryPoint;\n        CHAIN_ID = block.chainid;\n    }\n\n    /**\n     * @dev This function is a special fallback function that is triggered when the contract receives Ether.\n     * It logs an event indicating the amount of Ether received and the sender's address.\n     * @notice This function is marked as external and payable, meaning it can be called from external\n     * sources and accepts Ether as payment.\n     */\n    receive() external payable {\n        if (address(this) == SELF) revert DelegateCallsOnly();\n        emit SmartAccountReceivedNativeToken(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Initialize the Smart Account with required states.\n     * @param handler Default fallback handler for the Smart Account.\n     * @param sessionKeyModuleContract Initializes the session key module\n     * @param authModuleSetupContract Initializes the auth module; can be a factory or registry for multiple accounts.\n     * @param authModuleSetupData Contains address of the Setup Contract and setup data.\n     * @notice Ensure this is callable only once (use initializer modifier or state checks).\n     */\n    function init(\n        address handler,\n        address sessionKeyModuleContract,\n        address authModuleSetupContract,\n        bytes calldata authModuleSetupData\n    ) external virtual override returns (address) {\n        _setFallbackHandler(handler);\n        _enableModule(sessionKeyModuleContract);\n        return\n            _initialSetupModules(authModuleSetupContract, authModuleSetupData);\n    }\n\n    /**\n     * @dev Interface function with the standard name for execute_ncC\n     * @param dest Address of the contract to call\n     * @param value Amount of native tokens to send along with the transaction\n     * @param func Data of the transaction\n     */\n    function execute(\n        address dest,\n        uint256 value,\n        bytes calldata func\n    ) external {\n        execute_ncC(dest, value, func);\n    }\n\n    /**\n     * @dev Interface function with the standard name for executeBatch_y6U\n     * @param dest Addresses of the contracts to call\n     * @param value Amounts of native tokens to send along with the transactions\n     * @param func Data of the transactions\n     */\n    function executeBatch(\n        address[] calldata dest,\n        uint256[] calldata value,\n        bytes[] calldata func\n    ) external {\n        executeBatch_y6U(dest, value, func);\n    }\n\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external virtual override returns (uint256 validationData) {\n        if (msg.sender != address(entryPoint()))\n            revert CallerIsNotAnEntryPoint(msg.sender);\n\n        (, address validationModule) = abi.decode(\n            userOp.signature,\n            (bytes, address)\n        );\n        if (address(_modules[validationModule]) != address(0)) {\n            validationData = IAuthorizationModule(validationModule)\n                .validateUserOp(userOp, userOpHash);\n        } else {\n            revert WrongValidationModule(validationModule);\n        }\n        _payPrefund(missingAccountFunds);\n    }\n\n    /**\n     * @dev Adds a module to the allowlist.\n     * @notice This can only be done via a userOp or a selfcall.\n     * @notice Enables the module `module` for the wallet.\n     * @param module Module to be allow-listed.\n     */\n    function enableModule(address module) external virtual override {\n        _requireFromEntryPointOrSelf();\n        _enableModule(module);\n    }\n\n    /**\n     * @dev Setups module for this Smart Account and enables it.\n     * @notice This can only be done via userOp or a selfcall.\n     * @notice Enables the module `module` for the wallet.\n     */\n    function setupAndEnableModule(\n        address setupContract,\n        bytes memory setupData\n    ) external virtual override returns (address) {\n        _requireFromEntryPointOrSelf();\n        return _setupAndEnableModule(setupContract, setupData);\n    }\n\n    function setFallbackHandler(address handler) external virtual override {\n        _requireFromEntryPoint();\n        _setFallbackHandler(handler);\n    }\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @param _interfaceId The interface identifier, as specified in ERC165\n     * @return `true` if the contract implements `_interfaceID`\n     */\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) external view virtual override returns (bool) {\n        return _interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n\n    /**\n     * @dev Returns the address of the implementation contract associated with this contract.\n     * @notice The implementation address is stored in the contract's storage slot with index 0.\n     */\n    function getImplementation()\n        external\n        view\n        returns (address _implementation)\n    {\n        assembly {\n            _implementation := sload(address())\n        }\n    }\n\n    /**\n     * @notice All the new implementations MUST have this method!\n     * @notice Updates the implementation of the base wallet\n     * @param _implementation New wallet implementation\n     */\n    function updateImplementation(address _implementation) public virtual {\n        _requireFromEntryPointOrSelf();\n        require(_implementation != address(0), \"Address cannot be zero\");\n        if (!_implementation.isContract())\n            revert InvalidImplementation(_implementation);\n        address oldImplementation;\n\n        assembly {\n            oldImplementation := sload(address())\n            sstore(address(), _implementation)\n        }\n        emit ImplementationUpdated(oldImplementation, _implementation);\n    }\n\n    /* solhint-disable func-name-mixedcase */\n\n    /**\n     * @dev Execute a transaction (called directly from owner, or by entryPoint)\n     * @notice Name is optimized for this method to be cheaper to be called\n     * @param dest Address of the contract to call\n     * @param value Amount of native tokens to send along with the transaction\n     * @param func Data of the transaction\n     */\n    function execute_ncC(\n        address dest,\n        uint256 value,\n        bytes calldata func\n    ) public {\n        _requireFromEntryPoint();\n        _call(dest, value, func);\n    }\n\n    /**\n     * @dev Execute a sequence of transactions\n     * @notice Name is optimized for this method to be cheaper to be called\n     * @param dest Addresses of the contracts to call\n     * @param value Amounts of native tokens to send along with the transactions\n     * @param func Data of the transactions\n     */\n    function executeBatch_y6U(\n        address[] calldata dest,\n        uint256[] calldata value,\n        bytes[] calldata func\n    ) public {\n        _requireFromEntryPoint();\n        if (\n            dest.length == 0 ||\n            dest.length != value.length ||\n            value.length != func.length\n        ) revert WrongBatchProvided(dest.length, value.length, func.length, 0);\n        for (uint256 i; i < dest.length; ) {\n            _call(dest[i], value[i], func[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /* solhint-enable func-name-mixedcase */\n\n    /**\n     * @dev Deposit more funds for this account in the entryPoint\n     */\n    function addDeposit() public payable {\n        entryPoint().depositTo{value: msg.value}(address(this));\n    }\n\n    /**\n     * @dev Withdraw value from the account's deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawDepositTo(\n        address payable withdrawAddress,\n        uint256 amount\n    ) public payable {\n        _requireFromEntryPointOrSelf();\n        entryPoint().withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * @dev Removes a module from the allowlist.\n     * @notice This can only be done via a wallet transaction.\n     * @notice Disables the module `module` for the wallet.\n     * @param prevModule Module that pointed to the module to be removed in the linked list\n     * @param module Module to be removed.\n     */\n    function disableModule(address prevModule, address module) public virtual {\n        _requireFromEntryPointOrSelf();\n        _disableModule(prevModule, module);\n    }\n\n    /**\n     * @dev Returns the current entry point used by this account.\n     * @return EntryPoint as an `IEntryPoint` interface.\n     * @dev This function should be implemented by the subclass to return the current entry point used by this account.\n     */\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return ENTRY_POINT;\n    }\n\n    /**\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\n     * @return bytes32 The domain separator hash.\n     */\n    function domainSeparator() public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    DOMAIN_SEPARATOR_TYPEHASH,\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n     * @notice Returns the ID of the chain the contract is currently deployed on.\n     * @return CHAIN_ID The ID of the current chain as a uint256.\n     */\n    function getChainId() public view returns (uint256) {\n        return CHAIN_ID;\n    }\n\n    /**\n     * @dev returns a value from the nonces 2d mapping\n     * @param batchId : the key of the user's batch being queried\n     * @return nonce : the number of transactions made within said batch\n     */\n    function getNonce(uint256 batchId) public view virtual returns (uint256) {\n        return nonces[batchId];\n    }\n\n    /**\n     * Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)\n     * @dev If owner is a smart-contract (other smart contract wallet or module, that controls\n     *      signature verifications - like multisig), forward isValidSignature request to it.\n     *      In case of multisig, _signature can be several concatenated signatures\n     *      If owner is EOA, perform a regular ecrecover.\n     * @param ethSignedDataHash 32 bytes hash of the data signed on the behalf of address(msg.sender)\n     *                          prepended with '\\x19Ethereum Signed Message:\\n'\n     * @param signature Signature byte array associated with ethSignedDataHash\n     * @return bytes4 value.\n     */\n    function isValidSignature(\n        bytes32 ethSignedDataHash,\n        bytes memory signature\n    ) public view override returns (bytes4) {\n        (bytes memory moduleSignature, address validationModule) = abi.decode(\n            signature,\n            (bytes, address)\n        );\n        if (address(_modules[validationModule]) != address(0)) {\n            return\n                ISignatureValidator(validationModule).isValidSignature(\n                    ethSignedDataHash,\n                    moduleSignature\n                );\n        } else {\n            revert WrongValidationModule(validationModule);\n        }\n    }\n\n    /**\n     * @dev Check current account deposit in the entryPoint\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint().balanceOf(address(this));\n    }\n\n    /**\n     * @dev internal method that fecilitates the extenral calls from SmartAccount\n     * @dev similar to execute() of Executor.sol\n     * @param target destination address contract/non-contract\n     * @param value amount of native tokens\n     * @param data function singature of destination\n     */\n    function _call(address target, uint256 value, bytes memory data) internal {\n        assembly {\n            let success := call(\n                gas(),\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, returndatasize())\n            if iszero(success) {\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This function allows the owner or entry point to execute certain actions.\n     * If the caller is not authorized, the function will revert with an error message.\n     * @notice This modifier is marked as internal and can only be called within the contract itself.\n     */\n    function _requireFromEntryPointOrSelf() internal view {\n        if (msg.sender != address(entryPoint()) && msg.sender != address(this))\n            revert CallerIsNotEntryPointOrSelf(msg.sender);\n    }\n\n    /**\n     * @dev This function allows the owner or entry point to execute certain actions.\n     * If the caller is not authorized, the function will revert with an error message.\n     * @notice This modifier is marked as internal and can only be called within the contract itself.\n     */\n    function _requireFromEntryPoint() internal view {\n        if (msg.sender != address(entryPoint()))\n            revert CallerIsNotEntryPoint(msg.sender);\n    }\n}\n"
    },
    "contracts/factory/SmartAccountFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../Proxy.sol\";\nimport \"../BaseSmartAccount.sol\";\nimport {DefaultCallbackHandler} from \"../handler/DefaultCallbackHandler.sol\";\nimport {Stakeable} from \"../common/Stakeable.sol\";\n\n/**\n * @title Smart Account Factory - factory responsible for deploying Smart Accounts using CREATE2 and CREATE\n * @dev It deploys Smart Accounts as proxies pointing to `basicImplementation` that is immutable.\n *      This allows keeping the same address for the same Smart Account owner on various chains via CREATE2\n * @author Chirag Titiya - <chirag@biconomy.io>\n */\ncontract SmartAccountFactory is Stakeable {\n    address public immutable basicImplementation;\n    DefaultCallbackHandler public immutable minimalHandler;\n\n    event AccountCreation(\n        address indexed account,\n        address indexed initialAuthModule,\n        uint256 indexed index\n    );\n    event AccountCreationWithoutIndex(\n        address indexed account,\n        address indexed initialAuthModule\n    );\n\n    constructor(\n        address _basicImplementation,\n        address _newOwner\n    ) Stakeable(_newOwner) {\n        require(\n            _basicImplementation != address(0),\n            \"implementation cannot be zero\"\n        );\n        basicImplementation = _basicImplementation;\n        minimalHandler = new DefaultCallbackHandler();\n    }\n\n    /**\n     * @notice Allows to find out account address prior to deployment\n     * @param index extra salt that allows to deploy more accounts if needed for same EOA (default 0)\n     */\n    function getAddressForCounterFactualAccount(\n        address sessionKeyModuleContract,\n        address authModuleSetupContract,\n        bytes calldata authModuleSetupData,\n        uint256 index\n    ) external view returns (address _account) {\n        // create initializer data based on init method, _owner and minimalHandler\n        bytes memory initializer = _getInitializer(\n            sessionKeyModuleContract,\n            authModuleSetupContract,\n            authModuleSetupData\n        );\n        bytes memory code = abi.encodePacked(\n            type(Proxy).creationCode,\n            uint256(uint160(basicImplementation))\n        );\n        bytes32 salt = keccak256(\n            abi.encodePacked(keccak256(initializer), index)\n        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code))\n        );\n        _account = address(uint160(uint256(hash)));\n    }\n\n    /**\n     * @notice Deploys multiple accounts using create2 and points it to basicImplementation\n     *\n     * @param indexes extra salt that allows to deploy more account if needed for same EOA (default 0)\n     */\n    function deployMultipleCounterFactualAccounts(\n        address sessionKeyModuleContract,\n        address authModuleSetupContract,\n        bytes calldata authModuleSetupData,\n        uint256[] calldata indexes\n    ) public {\n        // create initializer data based on init method and parameters\n        bytes memory initializer = _getInitializer(\n            sessionKeyModuleContract,\n            authModuleSetupContract,\n            authModuleSetupData\n        );\n\n        bytes memory deploymentData = abi.encodePacked(\n            type(Proxy).creationCode,\n            uint256(uint160(basicImplementation))\n        );\n        for (uint256 i = 0; i < indexes.length; i++) {\n            uint256 index = indexes[i];\n            bytes32 salt = keccak256(\n                abi.encodePacked(keccak256(initializer), index)\n            );\n            address proxy;\n\n            assembly {\n                proxy := create2(\n                    0x0,\n                    add(0x20, deploymentData),\n                    mload(deploymentData),\n                    salt\n                )\n            }\n            require(address(proxy) != address(0), \"Create2 call failed\");\n\n            address initialAuthorizationModule;\n\n            if (initializer.length > 0) {\n                assembly {\n                    let success := call(\n                        gas(),\n                        proxy,\n                        0,\n                        add(initializer, 0x20),\n                        mload(initializer),\n                        0,\n                        0\n                    )\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0, returndatasize())\n                    if iszero(success) {\n                        revert(ptr, returndatasize())\n                    }\n                    initialAuthorizationModule := mload(ptr)\n                }\n            }\n            emit AccountCreation(proxy, initialAuthorizationModule, index);\n        }\n    }\n\n    /**\n     * @notice Deploys account using create2 and points it to basicImplementation\n     *\n     * @param index extra salt that allows to deploy more account if needed for same EOA (default 0)\n     */\n    function deployCounterFactualAccount(\n        address sessionKeyModuleContract,\n        address authModuleSetupContract,\n        bytes calldata authModuleSetupData,\n        uint256 index\n    ) public returns (address proxy) {\n        // create initializer data based on init method and parameters\n        bytes memory initializer = _getInitializer(\n            sessionKeyModuleContract,\n            authModuleSetupContract,\n            authModuleSetupData\n        );\n        bytes32 salt = keccak256(\n            abi.encodePacked(keccak256(initializer), index)\n        );\n\n        bytes memory deploymentData = abi.encodePacked(\n            type(Proxy).creationCode,\n            uint256(uint160(basicImplementation))\n        );\n\n        assembly {\n            proxy := create2(\n                0x0,\n                add(0x20, deploymentData),\n                mload(deploymentData),\n                salt\n            )\n        }\n        require(address(proxy) != address(0), \"Create2 call failed\");\n\n        address initialAuthorizationModule;\n\n        if (initializer.length > 0) {\n            assembly {\n                let success := call(\n                    gas(),\n                    proxy,\n                    0,\n                    add(initializer, 0x20),\n                    mload(initializer),\n                    0,\n                    0\n                )\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                if iszero(success) {\n                    revert(ptr, returndatasize())\n                }\n                initialAuthorizationModule := mload(ptr)\n            }\n        }\n        emit AccountCreation(proxy, initialAuthorizationModule, index);\n    }\n\n    /**\n     * @notice Deploys account using create and points it to _implementation\n     \n     * @return proxy address of the deployed account\n     */\n    function deployAccount(\n        address sessionKeyModuleContract,\n        address authModuleSetupContract,\n        bytes calldata authModuleSetupData\n    ) public returns (address proxy) {\n        bytes memory deploymentData = abi.encodePacked(\n            type(Proxy).creationCode,\n            uint256(uint160(basicImplementation))\n        );\n\n        assembly {\n            proxy := create(\n                0x0,\n                add(0x20, deploymentData),\n                mload(deploymentData)\n            )\n        }\n        require(address(proxy) != address(0), \"Create call failed\");\n\n        bytes memory initializer = _getInitializer(\n            sessionKeyModuleContract,\n            authModuleSetupContract,\n            authModuleSetupData\n        );\n        address initialAuthorizationModule;\n\n        if (initializer.length > 0) {\n            assembly {\n                let success := call(\n                    gas(),\n                    proxy,\n                    0,\n                    add(initializer, 0x20),\n                    mload(initializer),\n                    0,\n                    0\n                )\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                if iszero(success) {\n                    revert(ptr, returndatasize())\n                }\n                initialAuthorizationModule := mload(ptr)\n            }\n        }\n        emit AccountCreationWithoutIndex(proxy, initialAuthorizationModule);\n    }\n\n    /**\n     * @dev Allows to retrieve the creation code used for the Proxy deployment.\n     * @return The creation code for the Proxy.\n     */\n    function accountCreationCode() public pure returns (bytes memory) {\n        return type(Proxy).creationCode;\n    }\n\n    /**\n     * @dev Allows to retrieve the initializer data for the account.\n     * @param sessionKeyModuleContract enables session key module\n     * @param authModuleSetupContract Initializes the auth module; can be a factory or registry for multiple accounts.\n     * @param authModuleSetupData modules setup data (a standard calldata for the module setup contract)\n     * @return initializer bytes for init method\n     */\n    function _getInitializer(\n        address sessionKeyModuleContract,\n        address authModuleSetupContract,\n        bytes calldata authModuleSetupData\n    ) internal view returns (bytes memory) {\n        return\n            abi.encodeCall(\n                BaseSmartAccount.init,\n                (\n                    address(minimalHandler),\n                    sessionKeyModuleContract,\n                    authModuleSetupContract,\n                    authModuleSetupData\n                )\n            );\n    }\n}\n"
    },
    "contracts/handler/DefaultCallbackHandler.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\n/* solhint-disable no-empty-blocks */\n\nimport {IERC1155TokenReceiver} from \"../interfaces/IERC1155TokenReceiver.sol\";\nimport {IERC721TokenReceiver} from \"../interfaces/IERC721TokenReceiver.sol\";\nimport {IERC777TokensRecipient} from \"../interfaces/IERC777TokensRecipient.sol\";\nimport {IERC165} from \"../interfaces/IERC165.sol\";\n\n/** @title Default Callback Handler - returns true for known token callbacks\n *   @dev Handles EIP-1271 compliant isValidSignature requests.\n *  @notice inspired by Richard Meissner's <richard@gnosis.pm> implementation\n */\ncontract DefaultCallbackHandler is\n    IERC1155TokenReceiver,\n    IERC777TokensRecipient,\n    IERC721TokenReceiver,\n    IERC165\n{\n    string public constant NAME = \"Default Callback Handler\";\n    string public constant VERSION = \"1.0.0\";\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) external view virtual override returns (bool) {\n        return\n            interfaceId == type(IERC1155TokenReceiver).interfaceId ||\n            interfaceId == type(IERC721TokenReceiver).interfaceId ||\n            interfaceId == type(IERC777TokensRecipient).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return IERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return IERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return IERC721TokenReceiver.onERC721Received.selector;\n    }\n\n    function tokensReceived(\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata,\n        bytes calldata\n    ) external pure override {\n        // We implement this for completeness, doesn't really have any value\n    }\n}\n"
    },
    "contracts/interfaces/IAuthorizationModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\n\n// interface for modules to verify singatures signed over userOpHash\ninterface IAuthorizationModule {\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external returns (uint256 validationData);\n}\n"
    },
    "contracts/interfaces/IERC1155TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\n/**\n    Note: The ERC-165 identifier for this interface is 0x4e2312e0.\n*/\ninterface IERC1155TokenReceiver {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param _operator The address which initiated the transfer (i.e. msg.sender)\n     * @param _from The address which previously owned the token\n     * @param _id The ID of the token being transferred\n     * @param _value The amount of tokens being transferred\n     * @param _data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param _operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param _from The address which previously owned the token\n     * @param _ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param _values An array containing amounts of each token transferred (order and length must match ids array)\n     * @param _data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if allowed\n     */\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface IERC721TokenReceiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    ///  after a `transfer`. This function MAY throw to revert and reject the\n    ///  transfer. Return of other than the magic value MUST result in the\n    ///  transaction being reverted.\n    ///  Note: the contract address is always the message sender.\n    /// @param _operator The address which called `safeTransferFrom` function\n    /// @param _from The address which previously owned the token\n    /// @param _tokenId The NFT identifier which is being transferred\n    /// @param _data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IERC777TokensRecipient.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\ninterface IERC777TokensRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "contracts/interfaces/ISessionKeyManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ISessionKeyManager {\n    /**\n     * @dev validates that Session Key + parameters are enabled\n     * by being included into the merkle tree\n     * @param userOpSender smartAccount for which session key is being validated\n     * @param validUntil timestamp when the session key expires\n     * @param validAfter timestamp when the session key becomes valid\n     * @param sessionValidationModule address of the Session Validation Module\n     * @param sessionKeyData session parameters (limitations/permissions)\n     * @param merkleProof merkle proof for the leaf which represents this session key + params\n     * @dev if doesn't revert, session key is considered valid\n     */\n    function validateSessionKey(\n        address userOpSender,\n        uint48 validUntil,\n        uint48 validAfter,\n        address sessionValidationModule,\n        bytes calldata sessionKeyData,\n        bytes32[] calldata merkleProof\n    ) external;\n}\n"
    },
    "contracts/interfaces/ISignatureValidator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\ncontract ISignatureValidatorConstants {\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n}\n\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _dataHash Arbitrary length data signed on behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(\n        bytes32 _dataHash,\n        bytes memory _signature\n    ) public view virtual returns (bytes4);\n}\n"
    },
    "contracts/libs/LibAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary LibAddress {\n    /**\n     * @notice Will return true if provided address is a contract\n     * @param account Address to verify if contract or not\n     * @dev This contract will return false if called within the constructor of\n     *      a contract's deployment, as the code is not yet stored on-chain.\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 csize;\n\n        assembly {\n            csize := extcodesize(account)\n        }\n        return csize != 0;\n    }\n}\n"
    },
    "contracts/libs/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(\n        uint256 a,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return\n                result +\n                (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(\n        uint256 value,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return\n                result +\n                (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(\n        uint256 value,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return\n                result +\n                (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(\n        uint256 value,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return\n                result +\n                (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/libs/MultiSend.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\n/// @title Multi Send - Allows to batch multiple transactions into one.\n/// @author Nick Dodson - <nick.dodson@consensys.net>\n/// @author Gonçalo Sá - <goncalo.sa@consensys.net>\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract MultiSend {\n    address private immutable _multisendSingleton;\n\n    constructor() {\n        _multisendSingleton = address(this);\n    }\n\n    /// @dev Sends multiple transactions and reverts all if one fails.\n    /// @param transactions Encoded transactions. Each transaction is encoded as a packed bytes of\n    ///                     operation as a uint8 with 0 for a call or 1 for a delegatecall (=> 1 byte),\n    ///                     to as a address (=> 20 bytes),\n    ///                     value as a uint256 (=> 32 bytes),\n    ///                     data length as a uint256 (=> 32 bytes),\n    ///                     data as bytes.\n    ///                     see abi.encodePacked for more information on packed encoding\n    /// @notice This method is payable as delegatecalls keep the msg.value from the previous call\n    ///         If the calling method (e.g. execTransaction) received ETH this would revert otherwise\n    function multiSend(bytes memory transactions) external {\n        require(\n            address(this) != _multisendSingleton,\n            \"should be called via delegatecall\"\n        );\n\n        assembly {\n            let length := mload(transactions)\n            let i := 0x20\n            for {\n                // Pre block is not used in \"while mode\"\n            } lt(i, length) {\n                // Post block is not used in \"while mode\"\n            } {\n                // First byte of the data is the operation.\n                // We shift by 248 bits (256 - 8 [operation byte]) it right since mload will always load 32 bytes (a word).\n                // This will also zero out unused data.\n                let operation := shr(0xf8, mload(add(transactions, i)))\n                // We offset the load address by 1 byte (operation byte)\n                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\n                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\n                let value := mload(add(transactions, add(i, 0x15)))\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\n                let dataLength := mload(add(transactions, add(i, 0x35)))\n                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\n                let data := add(transactions, add(i, 0x55))\n                let success := 0\n                switch operation\n                case 0 {\n                    success := call(gas(), to, value, data, dataLength, 0, 0)\n                }\n                case 1 {\n                    success := delegatecall(gas(), to, data, dataLength, 0, 0)\n                }\n                if eq(success, 0) {\n                    revert(0, 0)\n                }\n                // Next entry starts at 85 byte + data length\n                i := add(i, add(0x55, dataLength))\n            }\n        }\n    }\n}\n"
    },
    "contracts/libs/MultiSendCallOnly.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\n/// @title Multi Send Call Only - Allows to batch multiple transactions into one, but only calls\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\n/// @notice The guard logic is not required here as this contract doesn't support nested delegate calls\ncontract MultiSendCallOnly {\n    /// @dev Sends multiple transactions and reverts all if one fails.\n    /// @param transactions Encoded transactions. Each transaction is encoded as a packed bytes of\n    ///                     operation has to be uint8(0) in this version (=> 1 byte),\n    ///                     to as a address (=> 20 bytes),\n    ///                     value as a uint256 (=> 32 bytes),\n    ///                     data length as a uint256 (=> 32 bytes),\n    ///                     data as bytes.\n    ///                     see abi.encodePacked for more information on packed encoding\n    /// @notice The code is for most part the same as the normal MultiSend (to keep compatibility),\n    ///         but reverts if a transaction tries to use a delegatecall.\n    /// @notice This method is payable as delegatecalls keep the msg.value from the previous call\n    ///         If the calling method (e.g. execTransaction) received ETH this would revert otherwise\n    function multiSend(bytes memory transactions) external {\n        assembly {\n            let length := mload(transactions)\n            let i := 0x20\n            for {\n                // Pre block is not used in \"while mode\"\n            } lt(i, length) {\n                // Post block is not used in \"while mode\"\n            } {\n                // First byte of the data is the operation.\n                // We shift by 248 bits (256 - 8 [operation byte]) it right since mload will always load 32 bytes (a word).\n                // This will also zero out unused data.\n                let operation := shr(0xf8, mload(add(transactions, i)))\n                // We offset the load address by 1 byte (operation byte)\n                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\n                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\n                let value := mload(add(transactions, add(i, 0x15)))\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\n                let dataLength := mload(add(transactions, add(i, 0x35)))\n                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\n                let data := add(transactions, add(i, 0x55))\n                let success := 0\n                switch operation\n                case 0 {\n                    success := call(gas(), to, value, data, dataLength, 0, 0)\n                }\n                // This version does not allow delegatecalls\n                case 1 {\n                    revert(0, 0)\n                }\n                if eq(success, 0) {\n                    revert(0, 0)\n                }\n                // Next entry starts at 85 byte + data length\n                i := add(i, add(0x55, dataLength))\n            }\n        }\n    }\n}\n"
    },
    "contracts/libs/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity 0.8.17;\n\nimport \"./Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/modules/BaseAuthorizationModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/* solhint-disable no-empty-blocks */\n\nimport {IAuthorizationModule} from \"../interfaces/IAuthorizationModule.sol\";\nimport {ISignatureValidator} from \"../interfaces/ISignatureValidator.sol\";\n\ncontract AuthorizationModulesConstants {\n    uint256 internal constant VALIDATION_SUCCESS = 0;\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\n}\n\nabstract contract BaseAuthorizationModule is\n    IAuthorizationModule,\n    ISignatureValidator,\n    AuthorizationModulesConstants\n{}\n"
    },
    "contracts/modules/EcdsaOwnershipRegistryModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {BaseAuthorizationModule} from \"./BaseAuthorizationModule.sol\";\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/**\n * @title ECDSA ownership Authorization module for Biconomy Smart Accounts.\n * @dev Compatible with Biconomy Modular Interface v 0.1\n *         - It allows to validate user operations signed by EOA private key.\n *         - EIP-1271 compatible (ensures Smart Account can validate signed messages).\n *         - One owner per Smart Account.\n *         - Does not support outdated eth_sign flow for cheaper validations\n *         (see https://support.metamask.io/hc/en-us/articles/14764161421467-What-is-eth-sign-and-why-is-it-a-risk-)\n * !!!!!!! Only EOA owners supported, no Smart Account Owners\n *         For Smart Contract Owners check SmartContractOwnership module instead\n * @author Fil Makarov - <filipp.makarov@biconomy.io>\n */\n\ncontract EcdsaOwnershipRegistryModule is BaseAuthorizationModule {\n    using ECDSA for bytes32;\n\n    string public constant NAME = \"ECDSA Ownership Registry Module\";\n    string public constant VERSION = \"0.2.0\";\n    mapping(address => address) internal _smartAccountOwners;\n\n    event OwnershipTransferred(\n        address indexed smartAccount,\n        address indexed oldOwner,\n        address indexed newOwner\n    );\n\n    error NoOwnerRegisteredForSmartAccount(address smartAccount);\n    error AlreadyInitedForSmartAccount(address smartAccount);\n    error WrongSignatureLength();\n    error NotEOA(address account);\n    error ZeroAddressNotAllowedAsOwner();\n\n    /**\n     * @dev Initializes the module for a Smart Account.\n     * Should be used at a time of first enabling the module for a Smart Account.\n     * @param eoaOwner The owner of the Smart Account. Should be EOA!\n     */\n    function initForSmartAccount(address eoaOwner) external returns (address) {\n        if (_smartAccountOwners[msg.sender] != address(0))\n            revert AlreadyInitedForSmartAccount(msg.sender);\n        if (eoaOwner == address(0)) revert ZeroAddressNotAllowedAsOwner();\n        _smartAccountOwners[msg.sender] = eoaOwner;\n        return address(this);\n    }\n\n    /**\n     * @dev Sets/changes an for a Smart Account.\n     * Should be called by Smart Account itself.\n     * @param owner The owner of the Smart Account.\n     */\n    function transferOwnership(address owner) external {\n        if (_isSmartContract(owner)) revert NotEOA(owner);\n        if (owner == address(0)) revert ZeroAddressNotAllowedAsOwner();\n        _transferOwnership(msg.sender, owner);\n    }\n\n    /**\n     * @dev Renounces ownership\n     * should be called by Smart Account.\n     */\n    function renounceOwnership() external {\n        _transferOwnership(msg.sender, address(0));\n    }\n\n    /**\n     * @dev Returns the owner of the Smart Account. Reverts for Smart Accounts without owners.\n     * @param smartAccount Smart Account address.\n     * @return owner The owner of the Smart Account.\n     */\n    function getOwner(address smartAccount) external view returns (address) {\n        address owner = _smartAccountOwners[smartAccount];\n        if (owner == address(0))\n            revert NoOwnerRegisteredForSmartAccount(smartAccount);\n        return owner;\n    }\n\n    /**\n     * @dev validates userOperation\n     * @param userOp User Operation to be validated.\n     * @param userOpHash Hash of the User Operation to be validated.\n     * @return sigValidationResult 0 if signature is valid, SIG_VALIDATION_FAILED otherwise.\n     */\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external view virtual returns (uint256) {\n        (bytes memory cleanEcdsaSignature, ) = abi.decode(\n            userOp.signature,\n            (bytes, address)\n        );\n        if (_verifySignature(userOpHash, cleanEcdsaSignature, userOp.sender)) {\n            return VALIDATION_SUCCESS;\n        }\n        return SIG_VALIDATION_FAILED;\n    }\n\n    /**\n     * @dev Validates a signature for a message.\n     * To be called from a Smart Account.\n     * @param dataHash Exact hash of the data that was signed.\n     * @param moduleSignature Signature to be validated.\n     * @return EIP1271_MAGIC_VALUE if signature is valid, 0xffffffff otherwise.\n     */\n    function isValidSignature(\n        bytes32 dataHash,\n        bytes memory moduleSignature\n    ) public view virtual override returns (bytes4) {\n        return\n            isValidSignatureForAddress(dataHash, moduleSignature, msg.sender);\n    }\n\n    /**\n     * @dev Validates a signature for a message signed by address.\n     * @dev Also try dataHash.toEthSignedMessageHash()\n     * @param dataHash hash of the data\n     * @param moduleSignature Signature to be validated.\n     * @param smartAccount expected signer Smart Account address.\n     * @return EIP1271_MAGIC_VALUE if signature is valid, 0xffffffff otherwise.\n     */\n    function isValidSignatureForAddress(\n        bytes32 dataHash,\n        bytes memory moduleSignature,\n        address smartAccount\n    ) public view virtual returns (bytes4) {\n        if (_verifySignature(dataHash, moduleSignature, smartAccount)) {\n            return EIP1271_MAGIC_VALUE;\n        }\n        return bytes4(0xffffffff);\n    }\n\n    /**\n     * @dev Transfers ownership for smartAccount and emits an event\n     * @param newOwner Smart Account address.\n     */\n    function _transferOwnership(\n        address smartAccount,\n        address newOwner\n    ) internal {\n        address _oldOwner = _smartAccountOwners[smartAccount];\n        _smartAccountOwners[smartAccount] = newOwner;\n        emit OwnershipTransferred(smartAccount, _oldOwner, newOwner);\n    }\n\n    /**\n     * @dev Validates a signature for a message.\n     * @dev Check if signature was made over dataHash.toEthSignedMessageHash() or just dataHash\n     * The former is for personal_sign, the latter for the typed_data sign\n     * Only EOA owners supported, no Smart Account Owners\n     * For Smart Contract Owners check SmartContractOwnership Module instead\n     * @param dataHash Hash of the data to be validated.\n     * @param signature Signature to be validated.\n     * @param smartAccount expected signer Smart Account address.\n     * @return true if signature is valid, false otherwise.\n     */\n    function _verifySignature(\n        bytes32 dataHash,\n        bytes memory signature,\n        address smartAccount\n    ) internal view returns (bool) {\n        address expectedSigner = _smartAccountOwners[smartAccount];\n        if (expectedSigner == address(0))\n            revert NoOwnerRegisteredForSmartAccount(smartAccount);\n        if (signature.length < 65) revert WrongSignatureLength();\n        address recovered = (dataHash.toEthSignedMessageHash()).recover(\n            signature\n        );\n        if (expectedSigner == recovered) {\n            return true;\n        }\n        recovered = dataHash.recover(signature);\n        if (expectedSigner == recovered) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @dev Checks if the address provided is a smart contract.\n     * @param account Address to be checked.\n     */\n    function _isSmartContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "contracts/modules/Exotic/EcdsaEthSignSupportOwnershipRegistryModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {BaseAuthorizationModule} from \"../BaseAuthorizationModule.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\n\n/**\n * @title ECDSA ownership Authorization module for Biconomy Smart Accounts.\n * @dev Compatible with Biconomy Modular Interface v 0.1\n *         - It allows to validate user operations signed by EOA private key.\n *         - EIP-1271 compatible (ensures Smart Account can validate signed messages).\n *         - One owner per Smart Account.\n *         - Supports eth_sign flow\n * !!!!!!! Only EOA owners supported, no Smart Account Owners\n *         For Smart Contract Owners check SmartContractOwnership module instead\n * @author Fil Makarov - <filipp.makarov@biconomy.io>\n */\n\ncontract EcdsaWithEthSignSupportOwnershipRegistryModule is\n    BaseAuthorizationModule\n{\n    using ECDSA for bytes32;\n\n    string public constant NAME = \"ECDSA Ownership Registry Module\";\n    string public constant VERSION = \"0.1.0\";\n    mapping(address => address) public smartAccountOwners;\n\n    error NoOwnerRegisteredForSmartAccount(address smartAccount);\n    error AlreadyInitedForSmartAccount(address smartAccount);\n    error WrongSignatureLength();\n    error NotEOA(address account);\n\n    /**\n     * @dev Initializes the module for a Smart Account.\n     * Should be used at a time of first enabling the module for a Smart Account.\n     * @param owner The owner of the Smart Account.\n     */\n    function initForSmartAccount(address owner) external returns (address) {\n        if (_isSmartAccount(owner)) revert NotEOA(owner);\n        if (smartAccountOwners[msg.sender] != address(0))\n            revert AlreadyInitedForSmartAccount(msg.sender);\n        smartAccountOwners[msg.sender] = owner;\n        return address(this);\n    }\n\n    /**\n     * @dev Sets/changes an for a Smart Account.\n     * Should be called by Smart Account itself.\n     * @param owner The owner of the Smart Account.\n     */\n    function setOwner(address owner) external {\n        if (_isSmartAccount(owner)) revert NotEOA(owner);\n        smartAccountOwners[msg.sender] = owner;\n    }\n\n    /**\n     * @dev validates userOperation\n     * @param userOp User Operation to be validated.\n     * @param userOpHash Hash of the User Operation to be validated.\n     * @return sigValidationResult 0 if signature is valid, SIG_VALIDATION_FAILED otherwise.\n     */\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external view virtual returns (uint256) {\n        (bytes memory moduleSignature, ) = abi.decode(\n            userOp.signature,\n            (bytes, address)\n        );\n        // validateUserOp gets from EP a hash not prepended with 'x\\x19Ethereum Signed Message:\\n32'\n        // so we have to do it manually, as on the user side it is signed with personal_sign\n        // that prepends with \"\\x19Ethereum Signed Message\\n32\"\n        if (\n            _verifySignature(\n                userOpHash.toEthSignedMessageHash(),\n                moduleSignature,\n                userOp.sender\n            )\n        ) {\n            return 0;\n        }\n        return SIG_VALIDATION_FAILED;\n    }\n\n    /**\n     * @dev Validates a signature for a message.\n     * To be called from a Smart Account.\n     * @param dataHash Exact hash of the data that was signed.\n     * @param moduleSignature Signature to be validated.\n     * @return EIP1271_MAGIC_VALUE if signature is valid, 0xffffffff otherwise.\n     */\n    function isValidSignature(\n        bytes32 dataHash,\n        bytes memory moduleSignature\n    ) public view virtual override returns (bytes4) {\n        return\n            isValidSignatureForAddress(dataHash, moduleSignature, msg.sender);\n    }\n\n    /**\n     * @dev Validates a signature for a message signed by address.\n     * @param dataHash Exact hash of the data that was signed.\n     * @param moduleSignature Signature to be validated.\n     * @param smartAccount expected signer Smart Account address.\n     * @return EIP1271_MAGIC_VALUE if signature is valid, 0xffffffff otherwise.\n     */\n    function isValidSignatureForAddress(\n        bytes32 dataHash,\n        bytes memory moduleSignature,\n        address smartAccount\n    ) public view virtual returns (bytes4) {\n        if (_verifySignature(dataHash, moduleSignature, smartAccount)) {\n            return EIP1271_MAGIC_VALUE;\n        }\n        return bytes4(0xffffffff);\n    }\n\n    /**\n     * @dev Validates a signature for a message.\n     * Only EOA owners supported, no Smart Account Owners\n     * For Smart Contrac Owners check SmartContractOwnership module instead\n     * @param dataHash Hash of the data to be validated.\n     * @param signature Signature to be validated.\n     * @param smartAccount expected signer Smart Account address.\n     * @return true if signature is valid, false otherwise.\n     */\n    function _verifySignature(\n        bytes32 dataHash,\n        bytes memory signature,\n        address smartAccount\n    ) internal view returns (bool) {\n        address expectedSigner = smartAccountOwners[smartAccount];\n        if (expectedSigner == address(0))\n            revert NoOwnerRegisteredForSmartAccount(smartAccount);\n        if (signature.length < 65) revert WrongSignatureLength();\n        (uint8 v, bytes32 r, bytes32 s) = _signatureSplit(signature);\n        if (v > 30) {\n            //eth_sign flow\n            (address _signer, ) = dataHash.toEthSignedMessageHash().tryRecover(\n                v - 4,\n                r,\n                s\n            );\n            return expectedSigner == _signer;\n        } else {\n            return expectedSigner == dataHash.recover(signature);\n        }\n    }\n\n    /**\n     * @dev Checks if the address provided is a smart contract.\n     * @param account Address to be checked.\n     */\n    function _isSmartAccount(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function _signatureSplit(\n        bytes memory signature\n    ) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so let's\n            // use the second best option, 'and'\n            v := and(mload(add(signature, 0x41)), 0xff)\n        }\n    }\n}\n"
    },
    "contracts/modules/ForwardFlowModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ISignatureValidator, ISignatureValidatorConstants} from \"../interfaces/ISignatureValidator.sol\";\nimport {Enum} from \"../common/Enum.sol\";\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\nimport {Math} from \"../libs/Math.sol\";\n\nstruct Transaction {\n    address to;\n    Enum.Operation operation;\n    uint256 value;\n    bytes data;\n    uint256 targetTxGas;\n}\n\nstruct FeeRefund {\n    uint256 baseGas;\n    uint256 gasPrice; //gasPrice or tokenGasPrice\n    uint256 tokenGasPriceFactor;\n    address gasToken;\n    address payable refundReceiver;\n}\n\n/**\n * @notice Throws when the address that signed the data (restored from signature)\n * differs from the address we expected to sign the data (i.e. some authorized address)\n */\nerror InvalidSignature();\n\n/**\n * @notice Throws if not enough gas is left at some point\n * @param gasLeft how much gas left at the moment of a check\n * @param gasRequired how much gas required to proceed\n */\nerror NotEnoughGasLeft(uint256 gasLeft, uint256 gasRequired);\n\n/**\n * @notice Throws if not able to estimate gas\n * It can be when amount of gas and its price are both zero and at the same time\n * transaction has failed to be executed\n * @param targetTxGas gas required for target transaction\n * @param gasPrice gas price passed in Refund Info\n * @param success whether transaction has been executed successfully or not\n */\nerror CanNotEstimateGas(uint256 targetTxGas, uint256 gasPrice, bool success);\n\n/**\n * @notice Throws if transfer of tokens failed\n * @param token token contract address\n * @param dest token transfer receiver\n * @param amount the amount of tokens in a failed transfer\n */\nerror TokenTransferFailed(address token, address dest, uint256 amount);\n\n/**\n * @notice Thrown when trying to use 0 as tokenGasPriceFactor\n */\nerror TokenGasPriceFactorCanNotBeZero();\n\n/**\n * @notice Throws when the transaction execution fails\n */\nerror ExecutionFailed();\n\ninterface IExecFromModule {\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 txGas\n    ) external returns (bool success);\n\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external returns (bool success);\n}\n\ncontract ForwardFlowModule is ReentrancyGuard, ISignatureValidatorConstants {\n    // Domain Seperators keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // solhint-disable-next-line\n    // keccak256(\"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,uint256 tokenGasPriceFactor,address gasToken,address refundReceiver,uint256 nonce)\");\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH =\n        0xda033865d68bf4a40a5a7cb4159a99e33dba8569e65ea3e38222eb12d9e66eee;\n\n    uint256 private immutable CHAIN_ID;\n\n    mapping(uint256 => uint256) public nonces;\n\n    event AccountHandlePayment(bytes32 indexed txHash, uint256 indexed payment);\n\n    constructor() {\n        CHAIN_ID = block.chainid;\n    }\n\n    /**\n     * @dev Allows to estimate a transaction.\n     * @notice This method is for estimation only, it will always revert and encode the result in the revert data.\n     * @notice Call this method to get an estimate of the handlePayment costs that are deducted with `execTransaction`\n     * @param gasUsed Gas used by the transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution\n     * (e.g. base transaction fee, signature check, payment of the refund, emitted events).\n     * @param gasPrice Gas price / TokenGasPrice (gas price in the context of token using offchain price feeds)\n     * that should be used for the payment calculation.\n     * @param tokenGasPriceFactor factor by which calculated token gas price is already multiplied.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @return requiredGas Estimate of refunds\n     */\n    function handlePaymentRevert(\n        address smartAccount,\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) external returns (uint256 requiredGas) {\n        require(tokenGasPriceFactor != 0, \"invalid tokenGasPriceFactor\");\n        uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0)\n            ? payable(tx.origin)\n            : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            uint256 payment = (gasUsed + baseGas) *\n                (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            if (\n                !IExecFromModule(smartAccount).execTransactionFromModule(\n                    receiver,\n                    payment,\n                    \"0x\",\n                    Enum.Operation.Call,\n                    0\n                )\n            ) {\n                revert TokenTransferFailed(address(0), receiver, payment);\n            }\n        } else {\n            uint256 payment = ((gasUsed + baseGas) * (gasPrice)) /\n                (tokenGasPriceFactor);\n            if (\n                !IExecFromModule(smartAccount).execTransactionFromModule(\n                    gasToken,\n                    0,\n                    abi.encodeWithSignature(\n                        \"transfer(address,uint256)\",\n                        receiver,\n                        payment\n                    ),\n                    Enum.Operation.Call,\n                    0\n                )\n            ) {\n                revert TokenTransferFailed(gasToken, receiver, payment);\n            }\n        }\n        unchecked {\n            requiredGas = startGas - gasleft();\n        }\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Allows to estimate a transaction.\n     * This method is for estimation only, it will always revert and encode the result in the revert data.\n     * Call this method to get an estimate of the handlePayment costs that are deducted with `execTransaction`\n     * @param to Destination address of the transaction.\n     * @param value Ether value of transaction.\n     * @param data Data payload of transaction.\n     * @param operation Operation type of transaction.\n     * @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n     */\n    function requiredTxGas(\n        address smartAccount,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        if (\n            !IExecFromModule(smartAccount).execTransactionFromModule(\n                to,\n                value,\n                data,\n                operation\n            )\n        ) revert ExecutionFailed();\n        // Convert response to string and return via error message\n        unchecked {\n            revert(string(abi.encodePacked(startGas - gasleft())));\n        }\n    }\n\n    /**\n     * @dev Safe (ex-Gnosis) style transaction with optional repay in native tokens or ERC20\n     * @dev Execute a transaction confirmed by required signature/s and then pays the account that submitted it.\n     * @dev Function name optimized to have hash started with zeros to make this function calls cheaper\n     * @notice The fees are always transferred, even if the user transaction fails.\n     * @param _tx Smart Account transaction\n     * @param refundInfo Required information for gas refunds\n     * @param signatures Packed signature/s data ({bytes32 r}{bytes32 s}{uint8 v})\n     *                   Should be a signature over Typed Data Hash\n     *                   Use eth_signTypedData, not a personal_sign\n     */\n\n    function execTransaction(\n        address smartAccount,\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) public payable virtual nonReentrant returns (bool success) {\n        uint256 startGas = gasleft();\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData = encodeTransactionData(\n                // Smart Account to execute Transaction\n                smartAccount,\n                // Transaction info\n                _tx,\n                // Payment info\n                refundInfo,\n                // Signature info\n                nonces[1]++\n            );\n\n            txHash = keccak256(txHashData);\n            if (\n                ISignatureValidator(smartAccount).isValidSignature(\n                    txHash,\n                    signatures\n                ) != EIP1271_MAGIC_VALUE\n            ) {\n                revert InvalidSignature();\n            }\n        }\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to\n        // perform code until the execution (7500 = call the external function + checks inside it)\n        // We also include the 1/64 in the check that is not send along with a call to counteract\n        // potential shortings because of EIP-150\n        // Bitshift left 6 bits means multiplying by 64, just more gas efficient\n        if (\n            gasleft() <\n            Math.max((_tx.targetTxGas << 6) / 63, _tx.targetTxGas + 2500) + 7500\n        )\n            revert NotEnoughGasLeft(\n                gasleft(),\n                Math.max((_tx.targetTxGas << 6) / 63, _tx.targetTxGas + 2500) +\n                    7500\n            );\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            //we always provide targetTxGas to execution\n            success = IExecFromModule(smartAccount).execTransactionFromModule(\n                _tx.to,\n                _tx.value,\n                _tx.data,\n                _tx.operation,\n                _tx.targetTxGas\n            );\n\n            // If targetTxGas and gasPrice are both 0, the internal tx must succeed.\n            // Enables safe use of `estimateGas` by finding the minimum gas where the transaction doesn't revert\n            if (!success && _tx.targetTxGas == 0 && refundInfo.gasPrice == 0)\n                revert CanNotEstimateGas(\n                    _tx.targetTxGas,\n                    refundInfo.gasPrice,\n                    success\n                );\n\n            // Transfer transaction costs to tx.origin to avoid intermediate contract payments.\n            uint256 payment;\n            if (refundInfo.gasPrice != 0) {\n                payment = _handlePayment(\n                    smartAccount,\n                    startGas - gasleft(),\n                    refundInfo.baseGas,\n                    refundInfo.gasPrice,\n                    refundInfo.tokenGasPriceFactor,\n                    refundInfo.gasToken,\n                    refundInfo.refundReceiver\n                );\n                emit AccountHandlePayment(txHash, payment);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns hash to be signed by owner.\n     * @param _nonce Transaction nonce.\n     * @param smartAccount Address of the Smart Account to execute the txn.\n     * @return Transaction hash.\n     */\n    function getTransactionHash(\n        Transaction calldata _tx,\n        FeeRefund calldata refundInfo,\n        uint256 _nonce,\n        address smartAccount\n    ) public view returns (bytes32) {\n        return\n            keccak256(\n                encodeTransactionData(smartAccount, _tx, refundInfo, _nonce)\n            );\n    }\n\n    /**\n     * @dev Returns the bytes that are hashed to be signed by owner.\n     * @param _tx The wallet transaction to be signed.\n     * @param refundInfo Required information for gas refunds.\n     * @param _nonce Transaction nonce.\n     * @return transactionHash bytes that are hashed to be signed by the owner.\n     */\n    function encodeTransactionData(\n        address smartAccount,\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 accountTxHash = keccak256(\n            abi.encode(\n                ACCOUNT_TX_TYPEHASH,\n                _tx.to,\n                _tx.value,\n                keccak256(_tx.data),\n                _tx.operation,\n                _tx.targetTxGas,\n                refundInfo.baseGas,\n                refundInfo.gasPrice,\n                refundInfo.tokenGasPriceFactor,\n                refundInfo.gasToken,\n                refundInfo.refundReceiver,\n                _nonce\n            )\n        );\n        return\n            bytes.concat(\n                bytes1(0x19),\n                bytes1(0x01),\n                domainSeparator(smartAccount),\n                accountTxHash\n            );\n    }\n\n    /**\n     * @dev returns a value from the nonces 2d mapping\n     * @param batchId : the key of the user's batch being queried\n     * @return nonce : the number of transactions made within said batch\n     */\n    function getNonce(uint256 batchId) public view virtual returns (uint256) {\n        return nonces[batchId];\n    }\n\n    /**\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\n     * @return bytes32 The domain separator hash.\n     */\n    function domainSeparator(\n        address smartAccount\n    ) public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(DOMAIN_SEPARATOR_TYPEHASH, CHAIN_ID, smartAccount)\n            );\n    }\n\n    /**\n     * @notice Returns the ID of the chain the contract is currently deployed on.\n     * @return CHAIN_ID The ID of the current chain as a uint256.\n     */\n    function getChainId() public view returns (uint256) {\n        return CHAIN_ID;\n    }\n\n    /**\n     * @dev Handles the payment for a transaction refund from Smart Account to Relayer.\n     * @param gasUsed Gas used by the transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution\n     * (e.g. base transaction fee, signature check, payment of the refund, emitted events).\n     * @param gasPrice Gas price / TokenGasPrice (gas price in the context of token using offchain price feeds)\n     * that should be used for the payment calculation.\n     * @param tokenGasPriceFactor factor by which calculated token gas price is already multiplied.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @return payment The amount of payment made in the specified token.\n     */\n    function _handlePayment(\n        address smartAccount,\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        if (tokenGasPriceFactor == 0) revert TokenGasPriceFactorCanNotBeZero();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0)\n            ? payable(tx.origin)\n            : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment =\n                (gasUsed + baseGas) *\n                (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            if (\n                !IExecFromModule(smartAccount).execTransactionFromModule(\n                    receiver,\n                    payment,\n                    \"0x\",\n                    Enum.Operation.Call,\n                    0\n                )\n            ) {\n                revert TokenTransferFailed(address(0), receiver, payment);\n            }\n        } else {\n            payment =\n                ((gasUsed + baseGas) * (gasPrice)) /\n                (tokenGasPriceFactor);\n            if (\n                !IExecFromModule(smartAccount).execTransactionFromModule(\n                    gasToken,\n                    0,\n                    abi.encodeWithSignature(\n                        \"transfer(address,uint256)\",\n                        receiver,\n                        payment\n                    ),\n                    Enum.Operation.Call,\n                    0\n                )\n            ) {\n                revert TokenTransferFailed(gasToken, receiver, payment);\n            }\n        }\n    }\n}\n"
    },
    "contracts/modules/MultichainECDSAValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\nimport {EcdsaOwnershipRegistryModule} from \"./EcdsaOwnershipRegistryModule.sol\";\nimport {UserOperationLib} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {_packValidationData} from \"@account-abstraction/contracts/core/Helpers.sol\";\n\n/**\n * @title ECDSA Multichain Validator module for Biconomy Smart Accounts.\n * @dev Biconomy’s Multichain Validator module enables use cases which\n * require several actions to be authorized for several chains with just one\n * signature required from user.\n *         - Leverages Merkle Trees to efficiently manage large datasets\n *         - Inherits from the ECDSA Ownership Registry Module\n *         - Compatible with Biconomy Modular Interface v 0.1\n *         - Does not introduce any additional security trade-offs compared to the\n *           vanilla ERC-4337 flow.\n * @author Fil Makarov - <filipp.makarov@biconomy.io>\n */\n\ncontract MultichainECDSAValidator is EcdsaOwnershipRegistryModule {\n    using UserOperationLib for UserOperation;\n\n    /**\n     * @dev Validates User Operation.\n     * leaf = validUntil + validAfter + userOpHash\n     * If the leaf is the part of the Tree with a root provided, userOp considered\n     * to be authorized by user\n     * @param userOp user operation to be validated\n     * @param userOpHash hash of the userOp provided by the EP\n     */\n\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external view virtual override returns (uint256) {\n        (bytes memory moduleSignature, ) = abi.decode(\n            userOp.signature,\n            (bytes, address)\n        );\n\n        address sender;\n        //read sender from userOp, which is first userOp member (saves gas)\n        assembly {\n            sender := calldataload(userOp)\n        }\n\n        if (moduleSignature.length == 65) {\n            //it's not a multichain signature\n            return\n                _verifySignature(\n                    userOpHash,\n                    moduleSignature,\n                    address(uint160(sender))\n                )\n                    ? VALIDATION_SUCCESS\n                    : SIG_VALIDATION_FAILED;\n        }\n\n        //otherwise it is a multichain signature\n        (\n            uint48 validUntil,\n            uint48 validAfter,\n            bytes32 merkleTreeRoot,\n            bytes32[] memory merkleProof,\n            bytes memory multichainSignature\n        ) = abi.decode(\n                moduleSignature,\n                (uint48, uint48, bytes32, bytes32[], bytes)\n            );\n\n        //make a leaf out of userOpHash, validUntil and validAfter\n        bytes32 leaf = keccak256(\n            abi.encodePacked(validUntil, validAfter, userOpHash)\n        );\n\n        if (!MerkleProof.verify(merkleProof, merkleTreeRoot, leaf)) {\n            revert(\"Invalid UserOp\");\n        }\n\n        return\n            _verifySignature(\n                merkleTreeRoot,\n                multichainSignature,\n                address(uint160(sender))\n            )\n                ? _packValidationData(\n                    false, //sigVerificationFailed = false\n                    validUntil == 0 ? type(uint48).max : validUntil,\n                    validAfter\n                )\n                : SIG_VALIDATION_FAILED;\n    }\n\n    /**\n     * Inherits isValideSignature method from EcdsaOwnershipRegistryModule\n     * isValidSignature is intended to work not with a multichain signature\n     * but with a regular ecdsa signature over a message hash\n     */\n}\n"
    },
    "contracts/modules/PasskeyRegistryModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport {BaseAuthorizationModule} from \"./BaseAuthorizationModule.sol\";\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\nimport {Base64} from \"@openzeppelin/contracts/utils/Base64.sol\";\nimport {Secp256r1, PassKeyId} from \"./PasskeyValidationModules/Secp256r1.sol\";\n\n/**\n * @title Passkey ownership Authorization module for Biconomy Smart Accounts.\n * @dev Compatible with Biconomy Modular Interface v 0.2\n *         - It allows to validate user operations signed by passkeys.\n *         - One owner per Smart Account.\n *         For Smart Contract Owners check SmartContractOwnership module instead\n * @author Aman Raj - <aman.raj@biconomy.io>\n */\n\ncontract PasskeyRegistryModule is BaseAuthorizationModule {\n    string public constant NAME = \"PassKeys Ownership Registry Module\";\n    string public constant VERSION = \"0.2.0\";\n\n    mapping(address => PassKeyId) public smartAccountPassKeys;\n\n    error NoPassKeyRegisteredForSmartAccount(address smartAccount);\n    error AlreadyInitedForSmartAccount(address smartAccount);\n\n    /**\n     * @dev Initializes the module for a Smart Account.\n     * Should be used at a time of first enabling the module for a Smart Account.\n     * @param _pubKeyX The x coordinate of the public key.\n     * @param _pubKeyY The y coordinate of the public key.\n     * @param _keyId The keyId of the Smart Account.\n     * @return address of the module.\n     */\n    function initForSmartAccount(\n        uint256 _pubKeyX,\n        uint256 _pubKeyY,\n        string calldata _keyId\n    ) external returns (address) {\n        if (\n            smartAccountPassKeys[msg.sender].pubKeyX != 0 &&\n            smartAccountPassKeys[msg.sender].pubKeyY != 0\n        ) revert AlreadyInitedForSmartAccount(msg.sender);\n        smartAccountPassKeys[msg.sender] = PassKeyId(\n            _pubKeyX,\n            _pubKeyY,\n            _keyId\n        );\n        return address(this);\n    }\n\n    /**\n     * @dev validates userOperation\n     * @param userOp User Operation to be validated.\n     * @param userOpHash Hash of the User Operation to be validated.\n     * @return sigValidationResult 0 if signature is valid, SIG_VALIDATION_FAILED otherwise.\n     */\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external view virtual returns (uint256) {\n        return _validateSignature(userOp, userOpHash);\n    }\n\n    function isValidSignature(\n        bytes32 signedDataHash,\n        bytes memory moduleSignature\n    ) public view virtual override returns (bytes4) {\n        return isValidSignatureForAddress(signedDataHash, moduleSignature);\n    }\n\n    function isValidSignatureForAddress(\n        bytes32 signedDataHash,\n        bytes memory moduleSignature\n    ) public view virtual returns (bytes4) {\n        if (_verifySignature(signedDataHash, moduleSignature)) {\n            return EIP1271_MAGIC_VALUE;\n        }\n        return bytes4(0xffffffff);\n    }\n\n    function _verifySignature(\n        bytes32 userOpDataHash,\n        bytes memory moduleSignature\n    ) internal view returns (bool) {\n        (\n            bytes32 keyHash,\n            uint256 sigx,\n            uint256 sigy,\n            bytes memory authenticatorData,\n            string memory clientDataJSONPre,\n            string memory clientDataJSONPost\n        ) = abi.decode(\n                moduleSignature,\n                (bytes32, uint256, uint256, bytes, string, string)\n            );\n        (keyHash);\n        string memory opHashBase64 = Base64.encode(\n            bytes.concat(userOpDataHash)\n        );\n        string memory clientDataJSON = string.concat(\n            clientDataJSONPre,\n            opHashBase64,\n            clientDataJSONPost\n        );\n        bytes32 clientHash = sha256(bytes(clientDataJSON));\n        bytes32 sigHash = sha256(bytes.concat(authenticatorData, clientHash));\n\n        PassKeyId memory passKey = smartAccountPassKeys[msg.sender];\n        if (passKey.pubKeyX == 0 && passKey.pubKeyY == 0)\n            revert NoPassKeyRegisteredForSmartAccount(msg.sender);\n        return Secp256r1.verify(passKey, sigx, sigy, uint256(sigHash));\n    }\n\n    function _validateSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) internal view virtual returns (uint256 sigValidationResult) {\n        if (_verifySignature(userOpHash, userOp.signature)) {\n            return 0;\n        }\n        return SIG_VALIDATION_FAILED;\n    }\n}\n"
    },
    "contracts/modules/PasskeyValidationModules/Secp256r1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.17;\n//\n// Heavily inspired from\n// https://github.com/maxrobot/elliptic-solidity/blob/master/contracts/Secp256r1.sol\n// https://github.com/tdrerup/elliptic-curve-solidity/blob/master/contracts/curves/EllipticCurve.sol\n// modified to use precompile 0x05 modexp\n// and modified jacobian double\n// optimisations to avoid to an from from affine and jacobian coordinates\n//\nstruct PassKeyId {\n    uint256 pubKeyX;\n    uint256 pubKeyY;\n    string keyId;\n}\n\nstruct JPoint {\n    uint256 x;\n    uint256 y;\n    uint256 z;\n}\n\nlibrary Secp256r1 {\n    uint256 private constant GX =\n        0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\n    uint256 private constant GY =\n        0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n    uint256 private constant PP =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n\n    uint256 private constant NN =\n        0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\n    uint256 private constant A =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\n    uint256 private constant B =\n        0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\n    uint256 private constant MOST_SIGNIFICANT =\n        0xc000000000000000000000000000000000000000000000000000000000000000;\n\n    /*\n     * verify\n     * @description - verifies that a public key has signed a given message\n     * @param X - public key coordinate X\n     * @param Y - public key coordinate Y\n     * @param R - signature half R\n     * @param S - signature half S\n     * @param input - hashed message\n     */\n    function verify(\n        PassKeyId memory passKey,\n        uint256 r,\n        uint256 s,\n        uint256 e\n    ) internal view returns (bool) {\n        if (r >= NN || s >= NN) {\n            return false;\n        }\n\n        JPoint[16] memory points = preComputeJacobianPoints(passKey);\n        return verifyWithPrecompute(points, r, s, e);\n    }\n\n    function verifyWithPrecompute(\n        JPoint[16] memory points,\n        uint256 r,\n        uint256 s,\n        uint256 e\n    ) internal view returns (bool) {\n        if (r >= NN || s >= NN) {\n            return false;\n        }\n\n        uint256 w = primemod(s, NN);\n\n        uint256 u1 = mulmod(e, w, NN);\n        uint256 u2 = mulmod(r, w, NN);\n\n        uint256 x;\n        uint256 y;\n\n        (x, y) = shamirMultJacobian(points, u1, u2);\n        return (x == r);\n    }\n\n    /*\n     * Strauss Shamir trick for EC multiplication\n     * https://stackoverflow.com/questions/50993471/ec-scalar-multiplication-with-strauss-shamir-method\n     * we optimise on this a bit to do with 2 bits at a time rather than a single bit\n     * the individual points for a single pass are precomputed\n     * overall this reduces the number of additions while keeping the same number of doublings\n     */\n    function shamirMultJacobian(\n        JPoint[16] memory points,\n        uint256 u1,\n        uint256 u2\n    ) internal view returns (uint256, uint256) {\n        uint256 x = 0;\n        uint256 y = 0;\n        uint256 z = 0;\n        uint256 bits = 128;\n        uint256 index = 0;\n\n        while (bits > 0) {\n            if (z > 0) {\n                (x, y, z) = modifiedJacobianDouble(x, y, z);\n                (x, y, z) = modifiedJacobianDouble(x, y, z);\n            }\n            index =\n                ((u1 & MOST_SIGNIFICANT) >> 252) |\n                ((u2 & MOST_SIGNIFICANT) >> 254);\n            if (index > 0) {\n                (x, y, z) = jAdd(\n                    x,\n                    y,\n                    z,\n                    points[index].x,\n                    points[index].y,\n                    points[index].z\n                );\n            }\n            u1 <<= 2;\n            u2 <<= 2;\n            bits--;\n        }\n        (x, y) = affineFromJacobian(x, y, z);\n        return (x, y);\n    }\n\n    /* affineFromJacobian\n     * @desription returns affine coordinates from a jacobian input follows\n     * golang elliptic/crypto library\n     */\n    function affineFromJacobian(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) internal view returns (uint256 ax, uint256 ay) {\n        if (z == 0) {\n            return (0, 0);\n        }\n\n        uint256 zinv = primemod(z, PP);\n        uint256 zinvsq = mulmod(zinv, zinv, PP);\n\n        ax = mulmod(x, zinvsq, PP);\n        ay = mulmod(y, mulmod(zinvsq, zinv, PP), PP);\n    }\n\n    // Fermats little theorem https://en.wikipedia.org/wiki/Fermat%27s_little_theorem\n    // a^(p-1) = 1 mod p\n    // a^(-1) ≅ a^(p-2) (mod p)\n    // we then use the precompile bigModExp to compute a^(-1)\n    function primemod(\n        uint256 value,\n        uint256 p\n    ) internal view returns (uint256 ret) {\n        ret = modexp(value, p - 2, p);\n        return ret;\n    }\n\n    // Wrapper for built-in BigNumber_modexp (contract 0x5) as described here. https://github.com/ethereum/EIPs/pull/198\n    function modexp(\n        uint256 _base,\n        uint256 _exp,\n        uint256 _mod\n    ) internal view returns (uint256 ret) {\n        // bigModExp(_base, _exp, _mod);\n        assembly {\n            if gt(_base, _mod) {\n                _base := mod(_base, _mod)\n            }\n            // Free memory pointer is always stored at 0x40\n            let freemem := mload(0x40)\n\n            mstore(freemem, 0x20)\n            mstore(add(freemem, 0x20), 0x20)\n            mstore(add(freemem, 0x40), 0x20)\n\n            mstore(add(freemem, 0x60), _base)\n            mstore(add(freemem, 0x80), _exp)\n            mstore(add(freemem, 0xa0), _mod)\n\n            let success := staticcall(1500, 0x5, freemem, 0xc0, freemem, 0x20)\n            switch success\n            case 0 {\n                revert(0x0, 0x0)\n            }\n            default {\n                ret := mload(freemem)\n            }\n        }\n    }\n\n    function preComputeJacobianPoints(\n        PassKeyId memory passKey\n    ) internal pure returns (JPoint[16] memory points) {\n        // JPoint[] memory u1Points = new JPoint[](4);\n        // u1Points[0] = JPoint(0, 0, 0);\n        // u1Points[1] = JPoint(GX, GY, 1); // u1\n        // u1Points[2] = jPointDouble(u1Points[1]);\n        // u1Points[3] = jPointAdd(u1Points[1], u1Points[2]);\n        // avoiding this intermediate step by using it in a single array below\n        // these are pre computed points for u1\n\n        // JPoint[16] memory points;\n        points[0] = JPoint(0, 0, 0);\n        points[1] = JPoint(passKey.pubKeyX, passKey.pubKeyY, 1); // u2\n        points[2] = jPointDouble(points[1]);\n        points[3] = jPointAdd(points[1], points[2]);\n\n        points[4] = JPoint(GX, GY, 1); // u1Points[1]\n        points[5] = jPointAdd(points[4], points[1]);\n        points[6] = jPointAdd(points[4], points[2]);\n        points[7] = jPointAdd(points[4], points[3]);\n\n        points[8] = jPointDouble(points[4]); // u1Points[2]\n        points[9] = jPointAdd(points[8], points[1]);\n        points[10] = jPointAdd(points[8], points[2]);\n        points[11] = jPointAdd(points[8], points[3]);\n\n        points[12] = jPointAdd(points[4], points[8]); // u1Points[3]\n        points[13] = jPointAdd(points[12], points[1]);\n        points[14] = jPointAdd(points[12], points[2]);\n        points[15] = jPointAdd(points[12], points[3]);\n    }\n\n    function jPointAdd(\n        JPoint memory p1,\n        JPoint memory p2\n    ) internal pure returns (JPoint memory) {\n        uint256 x;\n        uint256 y;\n        uint256 z;\n        (x, y, z) = jAdd(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);\n        return JPoint(x, y, z);\n    }\n\n    function jPointDouble(\n        JPoint memory p\n    ) internal pure returns (JPoint memory) {\n        uint256 x;\n        uint256 y;\n        uint256 z;\n        (x, y, z) = modifiedJacobianDouble(p.x, p.y, p.z);\n        return JPoint(x, y, z);\n    }\n\n    /*\n     * jAdd\n     * @description performs double Jacobian as defined below:\n     * https://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-3/doubling/mdbl-2007-bl.op3\n     */\n    function jAdd(\n        uint256 p1,\n        uint256 p2,\n        uint256 p3,\n        uint256 q1,\n        uint256 q2,\n        uint256 q3\n    ) internal pure returns (uint256 r1, uint256 r2, uint256 r3) {\n        if (p3 == 0) {\n            r1 = q1;\n            r2 = q2;\n            r3 = q3;\n\n            return (r1, r2, r3);\n        } else if (q3 == 0) {\n            r1 = p1;\n            r2 = p2;\n            r3 = p3;\n\n            return (r1, r2, r3);\n        }\n\n        assembly {\n            let\n                pd\n            := 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\n            let z1z1 := mulmod(p3, p3, pd) // Z1Z1 = Z1^2\n            let z2z2 := mulmod(q3, q3, pd) // Z2Z2 = Z2^2\n\n            let u1 := mulmod(p1, z2z2, pd) // U1 = X1*Z2Z2\n            let u2 := mulmod(q1, z1z1, pd) // U2 = X2*Z1Z1\n\n            let s1 := mulmod(p2, mulmod(z2z2, q3, pd), pd) // S1 = Y1*Z2*Z2Z2\n            let s2 := mulmod(q2, mulmod(z1z1, p3, pd), pd) // S2 = Y2*Z1*Z1Z1\n\n            let p3q3 := addmod(p3, q3, pd)\n\n            if lt(u2, u1) {\n                u2 := add(pd, u2) // u2 = u2+pd\n            }\n            let h := sub(u2, u1) // H = U2-U1\n\n            let i := mulmod(0x02, h, pd)\n            i := mulmod(i, i, pd) // I = (2*H)^2\n\n            let j := mulmod(h, i, pd) // J = H*I\n            if lt(s2, s1) {\n                s2 := add(pd, s2) // u2 = u2+pd\n            }\n            let rr := mulmod(0x02, sub(s2, s1), pd) // r = 2*(S2-S1)\n            r1 := mulmod(rr, rr, pd) // X3 = R^2\n\n            let v := mulmod(u1, i, pd) // V = U1*I\n            let j2v := addmod(j, mulmod(0x02, v, pd), pd)\n            if lt(r1, j2v) {\n                r1 := add(pd, r1) // X3 = X3+pd\n            }\n            r1 := sub(r1, j2v)\n\n            // Y3 = r*(V-X3)-2*S1*J\n            let s12j := mulmod(mulmod(0x02, s1, pd), j, pd)\n\n            if lt(v, r1) {\n                v := add(pd, v)\n            }\n            r2 := mulmod(rr, sub(v, r1), pd)\n\n            if lt(r2, s12j) {\n                r2 := add(pd, r2)\n            }\n            r2 := sub(r2, s12j)\n\n            // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2)*H\n            z1z1 := addmod(z1z1, z2z2, pd)\n            j2v := mulmod(p3q3, p3q3, pd)\n            if lt(j2v, z1z1) {\n                j2v := add(pd, j2v)\n            }\n            r3 := mulmod(sub(j2v, z1z1), h, pd)\n        }\n        return (r1, r2, r3);\n    }\n\n    // Point doubling on the modified jacobian coordinates\n    // http://point-at-infinity.org/ecc/Prime_Curve_Modified_Jacobian_Coordinates.html\n    function modifiedJacobianDouble(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) internal pure returns (uint256 x3, uint256 y3, uint256 z3) {\n        assembly {\n            let\n                pd\n            := 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\n            let z2 := mulmod(z, z, pd)\n            let az4 := mulmod(\n                0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC,\n                mulmod(z2, z2, pd),\n                pd\n            )\n            let y2 := mulmod(y, y, pd)\n            let s := mulmod(0x04, mulmod(x, y2, pd), pd)\n            let u := mulmod(0x08, mulmod(y2, y2, pd), pd)\n            let m := addmod(mulmod(0x03, mulmod(x, x, pd), pd), az4, pd)\n            let twos := mulmod(0x02, s, pd)\n            let m2 := mulmod(m, m, pd)\n            if lt(m2, twos) {\n                m2 := add(pd, m2)\n            }\n            x3 := sub(m2, twos)\n            if lt(s, x3) {\n                s := add(pd, s)\n            }\n            y3 := mulmod(m, sub(s, x3), pd)\n            if lt(y3, u) {\n                y3 := add(pd, y3)\n            }\n            y3 := sub(y3, u)\n            z3 := mulmod(0x02, mulmod(y, z, pd), pd)\n        }\n    }\n}\n"
    },
    "contracts/modules/SmartContractOwnershipRegistryModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {BaseAuthorizationModule, ISignatureValidator} from \"./BaseAuthorizationModule.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\n\n/**\n * @title Smart Contract Ownership Authorization module for Biconomy Smart Accounts.\n * @dev Compatible with Biconomy Modular Interface v 0.1\n *         - It allows to validate user operations signed by other smart contracts via EIP-1271.\n *         - EIP-1271 compatible (ensures Smart Account can validate signed messages).\n *         - One owner per Smart Account.\n * @dev No EOA owners supported\n *         For EOA Owners check EcdsaOwnership module instead\n * @notice !!! This module doesn't follow the Storage Access Rules set by ERC-4337 !!!\n * https://eips.ethereum.org/EIPS/eip-4337#storage-associated-with-an-address\n * Thus it will not be compatible with the standard bundlers.\n * You can still use it in private environments or with custom bundlers which have\n * less restrictions than ones participating in the unified userOps mempool.\n *\n * @author Fil Makarov - <filipp.makarov@biconomy.io>\n */\n\ncontract SmartContractOwnershipRegistryModule is BaseAuthorizationModule {\n    using ECDSA for bytes32;\n\n    string public constant NAME = \"Smart Contract Ownership Registry Module\";\n    string public constant VERSION = \"0.1.0\";\n    mapping(address => address) internal _smartAccountOwners;\n\n    event OwnershipTransferred(\n        address indexed smartAccount,\n        address indexed oldOwner,\n        address indexed newOwner\n    );\n\n    error NoOwnerRegisteredForSmartAccount(address smartAccount);\n    error AlreadyInitedForSmartAccount(address smartAccount);\n    error WrongSignatureLength();\n    error NotSmartContract(address account);\n\n    /**\n     * @dev Initializes the module for a Smart Account.\n     * @dev no need to check for address(0) as it is not a Smart Contract\n     * Should be used at a time of first enabling the module for a Smart Account.\n     * @param owner The owner of the Smart Account.\n     */\n    function initForSmartAccount(address owner) external returns (address) {\n        if (_smartAccountOwners[msg.sender] != address(0))\n            revert AlreadyInitedForSmartAccount(msg.sender);\n        if (!_isSmartContract(owner)) revert NotSmartContract(owner);\n        _smartAccountOwners[msg.sender] = owner;\n        return address(this);\n    }\n\n    /**\n     * @dev Sets/changes an for a Smart Account.\n     * @dev no need to check for address(0) as it is not a Smart Contract\n     * Should be called by Smart Account itself.\n     * @param owner The owner of the Smart Account.\n     */\n    function transferOwnership(address owner) external {\n        if (!_isSmartContract(owner)) revert NotSmartContract(owner);\n        _transferOwnership(msg.sender, owner);\n    }\n\n    /**\n     * @dev Renounces ownership\n     * should be called by Smart Account.\n     */\n    function renounceOwnership() external {\n        _transferOwnership(msg.sender, address(0));\n    }\n\n    /**\n     * @dev Returns the owner of the Smart Account. Reverts for Smart Accounts without owners.\n     * @param smartAccount Smart Account address.\n     * @return owner The owner of the Smart Account.\n     */\n    function getOwner(address smartAccount) external view returns (address) {\n        address owner = _smartAccountOwners[smartAccount];\n        if (owner == address(0))\n            revert NoOwnerRegisteredForSmartAccount(smartAccount);\n        return owner;\n    }\n\n    /**\n     * @dev validates userOperation\n     * @param userOp User Operation to be validated.\n     * @param userOpHash Hash of the User Operation to be validated.\n     * @return sigValidationResult 0 if signature is valid, SIG_VALIDATION_FAILED otherwise.\n     */\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external view virtual returns (uint256) {\n        (bytes memory moduleSignature, ) = abi.decode(\n            userOp.signature,\n            (bytes, address)\n        );\n        // we send exactly the hash that has been received from EP\n        // as in theory owner.isValidSignature can expect signatures not only\n        // over eth signed hash. So if the frontend/backend creates a signature for\n        // this module, it is in charge to provide a signature over the non-modified hash\n        // or over a hash that is modiefied in the way owner expects\n        if (_verifySignature(userOpHash, moduleSignature, userOp.sender)) {\n            return 0;\n        }\n        return SIG_VALIDATION_FAILED;\n    }\n\n    /**\n     * @dev Validates a signature for a message.\n     * To be called from a Smart Account.\n     * @param dataHash Exact hash of the data that was signed.\n     * @param moduleSignature Signature to be validated.\n     * @return EIP1271_MAGIC_VALUE if signature is valid, 0xffffffff otherwise.\n     */\n    function isValidSignature(\n        bytes32 dataHash,\n        bytes memory moduleSignature\n    ) public view virtual override returns (bytes4) {\n        return\n            isValidSignatureForAddress(dataHash, moduleSignature, msg.sender);\n    }\n\n    /**\n     * @dev Validates a signature for a message signed by address.\n     * @param dataHash Exact hash of the data that was signed.\n     * @param moduleSignature Signature to be validated.\n     * @param smartAccount expected signer Smart Account address.\n     * @return EIP1271_MAGIC_VALUE if signature is valid, 0xffffffff otherwise.\n     */\n    function isValidSignatureForAddress(\n        bytes32 dataHash,\n        bytes memory moduleSignature,\n        address smartAccount\n    ) public view virtual returns (bytes4) {\n        if (_verifySignature(dataHash, moduleSignature, smartAccount)) {\n            return EIP1271_MAGIC_VALUE;\n        }\n        return bytes4(0xffffffff);\n    }\n\n    /**\n     * @dev Transfers ownership for smartAccount and emits an event\n     * @param newOwner Smart Account address.\n     */\n    function _transferOwnership(\n        address smartAccount,\n        address newOwner\n    ) internal {\n        address _oldOwner = _smartAccountOwners[smartAccount];\n        _smartAccountOwners[smartAccount] = newOwner;\n        emit OwnershipTransferred(smartAccount, _oldOwner, newOwner);\n    }\n\n    /**\n     * @dev Validates a signature for a message.\n     * Only Smart Account Owners, no EOA owners supported\n     * For Smart Contrac Owners check SmartContractOwnership module instead\n     * @param dataHash Hash of the data to be validated.\n     * @param signature Signature to be validated.\n     * @param smartAccount expected signer Smart Account address.\n     * @return true if signature is valid, false otherwise.\n     */\n    function _verifySignature(\n        bytes32 dataHash,\n        bytes memory signature,\n        address smartAccount\n    ) internal view returns (bool) {\n        address expectedContractSigner = _smartAccountOwners[smartAccount];\n        if (expectedContractSigner == address(0))\n            revert NoOwnerRegisteredForSmartAccount(smartAccount);\n        return\n            ISignatureValidator(expectedContractSigner).isValidSignature(\n                dataHash,\n                signature\n            ) == EIP1271_MAGIC_VALUE\n                ? true\n                : false;\n    }\n\n    /**\n     * @dev Checks if the address provided is a smart contract.\n     * @param account Address to be checked.\n     */\n    function _isSmartContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "contracts/modules/SwapSessionValidationModules/BuyValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\n\nlibrary BuyValidator {\n    using BytesLib for bytes;\n\n    struct UniV3ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct AlgebraExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    bytes4 public constant WRAP_ETH_SELECTOR = 0xd0e30db0;\n    bytes4 public constant ERC20_APPROVE_SELECTOR = 0x095ea7b3;\n\n    bytes4 public constant UNIV3_EXACT_INPUT_SINGLE_SELECTOR = 0x414bf389;\n    bytes4 public constant ALGEBRA_EXACT_INPUT_SINGLE_SELECTOR = 0xbc651188;\n    bytes4 public constant UNIV2_SWAP_EXACT_ETH_FOR_TOKENS = 0x7ff36ab5;\n    bytes4 public constant UNIV2_SWAP_EXACT_TOKENS_FOR_TOKENS = 0x38ed1739;\n\n    // execute_ncC(address,uint256,bytes)\n    bytes4 public constant EXECUTE_OPTIMIZED_SELECTOR = 0x0000189a;\n    // function executeBatch_y6U( address[] calldata dest, uint256[] calldata value, bytes[] calldata func)\n    bytes4 public constant EXECUTE_BATCH_SELECTOR = 0x00004680;\n\n    /**\n     * @dev validates if the _op (UserOperation) matches the SessionKey permissions\n     * and that _op has been signed by this SessionKey\n     * Please mind the decimals of your exact token when setting maxAmount\n     * @param token the non-native token of the pair\n     * @return true if the _op is valid, false otherwise.\n     */\n    function validateBuy(\n        UserOperation memory op,\n        address token,\n        uint256 spentAmount,\n        uint256 payment,\n        address WRAPPED_NATIVE_TOKEN,\n        address ROUTER,\n        address FEE_RECIPIENT\n    ) internal pure returns (bool) {\n        bytes4 opFncSig = bytes4(op.callData.slice(0, 4));\n\n        bytes memory opData = op.callData.slice(4, op.callData.length - 4);\n\n        if (opFncSig == EXECUTE_OPTIMIZED_SELECTOR) {\n            require(payment == 0, \"BV: no payment required\");\n            (address router, uint256 callValue, bytes memory data) = abi.decode(\n                opData,\n                (address, uint256, bytes)\n            );\n            require(\n                callValue == 0 || callValue == spentAmount,\n                \"BV: invalid call value\"\n            );\n            require(router == ROUTER, \"BV: invalid router\");\n            validateBuyTx(\n                data,\n                op.sender,\n                token,\n                WRAPPED_NATIVE_TOKEN,\n                spentAmount\n            );\n        } else if (opFncSig == EXECUTE_BATCH_SELECTOR) {\n            (\n                address[] memory addresses,\n                uint256[] memory callValues,\n                bytes[] memory data\n            ) = abi.decode(opData, (address[], uint256[], bytes[]));\n\n            require(\n                addresses.length == callValues.length &&\n                    addresses.length == data.length,\n                \"BV: invalid tx list's length\"\n            );\n            uint256 fncNum = addresses.length;\n            require(fncNum >= 2 && fncNum <= 4, \"BV: invalid number of txs\");\n\n            uint256 buyTxIndex;\n\n            if (payment > 0) {\n                require(\n                    addresses[fncNum - 1] == FEE_RECIPIENT,\n                    \"BV: must pay fee\"\n                );\n                require(\n                    callValues[fncNum - 1] == payment,\n                    \"BV: invalid payment\"\n                );\n                buyTxIndex = fncNum - 2;\n            } else {\n                buyTxIndex = fncNum - 1;\n            }\n\n            require(addresses[buyTxIndex] == ROUTER, \"BV: invalid router\");\n            validateBuyTx(\n                data[buyTxIndex],\n                op.sender,\n                token,\n                WRAPPED_NATIVE_TOKEN,\n                spentAmount\n            );\n\n            if (buyTxIndex == 0) {\n                require(\n                    callValues[0] == 0 || callValues[0] == spentAmount,\n                    \"BV: invalid callvalue\"\n                );\n            } else if (buyTxIndex == 1) {\n                require(callValues[1] == 0, \"BV: invalid callvalue\");\n                require(\n                    addresses[0] == WRAPPED_NATIVE_TOKEN,\n                    \"BV: must call the wrapped native\"\n                );\n                bytes4 fncSig = bytes4(data[0].slice(0, 4));\n\n                if (fncSig == ERC20_APPROVE_SELECTOR) {\n                    validateApproveTx(data[0], ROUTER);\n                } else {\n                    require(\n                        fncSig == WRAP_ETH_SELECTOR,\n                        \"BV: Invalid op funtion signature\"\n                    );\n                }\n            } else {\n                require(callValues[2] == 0, \"BV: invalid callvalue\");\n                require(\n                    addresses[0] == WRAPPED_NATIVE_TOKEN &&\n                        addresses[1] == WRAPPED_NATIVE_TOKEN,\n                    \"BV: must call the wrapped native\"\n                );\n                require(\n                    bytes4(data[0].slice(0, 4)) == WRAP_ETH_SELECTOR &&\n                        bytes4(data[1].slice(0, 4)) == ERC20_APPROVE_SELECTOR,\n                    \"BV: Invalid op funtion signature\"\n                );\n                validateApproveTx(data[1], ROUTER);\n            }\n        } else {\n            revert(\"Invalid op funtion signature\");\n        }\n\n        return true;\n    }\n\n    function validateBuyTx(\n        bytes memory data,\n        address sender,\n        address token,\n        address WRAPPED_NATIVE_TOKEN,\n        uint256 spentAmount\n    ) internal pure {\n        bytes4 fncSig = bytes4(data.slice(0, 4));\n\n        bytes memory funcData = data.slice(4, data.length - 4);\n\n        if (fncSig == UNIV3_EXACT_INPUT_SINGLE_SELECTOR) {\n            UniV3ExactInputSingleParams memory params = abi.decode(\n                funcData,\n                (UniV3ExactInputSingleParams)\n            );\n\n            require(\n                params.tokenIn == WRAPPED_NATIVE_TOKEN,\n                \"BV: only accept Wrapped native token as tokenIn\"\n            );\n            require(params.tokenOut == token, \"BV: Wrong token out\");\n            require(\n                params.amountIn == spentAmount,\n                \"BV: spent amounts mismatch\"\n            );\n            require(params.recipient == sender, \"BV: Wrong recipient\");\n        } else if (fncSig == ALGEBRA_EXACT_INPUT_SINGLE_SELECTOR) {\n            AlgebraExactInputSingleParams memory params = abi.decode(\n                funcData,\n                (AlgebraExactInputSingleParams)\n            );\n\n            require(\n                params.tokenIn == WRAPPED_NATIVE_TOKEN,\n                \"BV: only accept Wrapped native token as tokenIn\"\n            );\n            require(params.tokenOut == token, \"BV: Wrong token out\");\n            require(\n                params.amountIn == spentAmount,\n                \"BV: spent amounts mismatch\"\n            );\n            require(params.recipient == sender, \"BV: Wrong recipient\");\n        } else if (fncSig == UNIV2_SWAP_EXACT_ETH_FOR_TOKENS) {\n            (, address[] memory path, address to, ) = abi.decode(\n                funcData,\n                (uint256, address[], address, uint256)\n            );\n            require(path[0] == WRAPPED_NATIVE_TOKEN, \"BV: invalid token in\");\n            require(path[path.length - 1] == token, \"BV: invalid token out\");\n            require(to == sender, \"BV: invalid recipient\");\n        } else if (fncSig == UNIV2_SWAP_EXACT_TOKENS_FOR_TOKENS) {\n            (uint256 amountIn, , address[] memory path, address to, ) = abi\n                .decode(\n                    funcData,\n                    (uint256, uint256, address[], address, uint256)\n                );\n            require(amountIn == spentAmount, \"BV: invalid amount in\");\n            require(path[0] == WRAPPED_NATIVE_TOKEN, \"BV: invalid token in\");\n            require(path[path.length - 1] == token, \"BV: invalid token out\");\n            require(to == sender, \"BV: invalid recipient\");\n        } else {\n            revert(\"BV: Swap function is not supported\");\n        }\n    }\n\n    function validateApproveTx(\n        bytes memory data,\n        address ROUTER\n    ) internal pure {\n        bytes memory funcData = data.slice(4, data.length - 4);\n        (address router, ) = abi.decode(funcData, (address, uint256));\n        require(router == ROUTER, \"BV: invalid spender\");\n    }\n}\n"
    },
    "contracts/modules/SwapSessionValidationModules/PreApproveValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\n\nlibrary PreApproveValidator {\n    using BytesLib for bytes;\n\n    bytes4 public constant ERC20_APPROVE_SELECTOR = 0x095ea7b3;\n    // execute_ncC(address,uint256,bytes)\n    bytes4 public constant EXECUTE_OPTIMIZED_SELECTOR = 0x0000189a;\n\n    /**\n     * @dev validates if the _op (UserOperation) matches the SessionKey permissions\n     * and that _op has been signed by this SessionKey\n     * Please mind the decimals of your exact token when setting maxAmount\n     * @param op User Operation to be validated.\n     * @param asset erc20 token to approve\n     * @return true if the _op is valid, false otherwise.\n     */\n    function validatePreApprove(\n        UserOperation calldata op,\n        address asset,\n        address ROUTER\n    ) internal pure returns (bool) {\n        require(\n            bytes4(op.callData.slice(0, 4)) == EXECUTE_OPTIMIZED_SELECTOR,\n            \"PV: Wrong function selector\"\n        );\n        (address tokenAddress,, bytes memory data) = abi\n            .decode(\n                op.callData[4:], // skip selector\n                (address, uint256, bytes)\n            );\n        if (tokenAddress != asset) {\n            revert(\"PV: Wrong approved asset\");\n        }\n        bytes4 fncSig = bytes4(data.slice(0, 4));\n\n        require(\n            fncSig == ERC20_APPROVE_SELECTOR,\n            \"PV: wrong function signature\"\n        );\n        bytes memory funcData = data.slice(4, data.length - 4);\n\n        (address routerAddr, ) = abi.decode(funcData, (address, uint256));\n        require(routerAddr == ROUTER, \"PV: can only approve router\");\n\n        return true;\n    }\n}\n"
    },
    "contracts/modules/SwapSessionValidationModules/SellValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\n\nlibrary SellValidator {\n    using BytesLib for bytes;\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    bytes4 public constant ERC20_APPROVE_SELECTOR = 0x095ea7b3;\n    bytes4 public constant EXACT_OUTPUT_SINGLE_SELECTOR = 0xdb3e2198;\n    bytes4 public constant UNIV2_SWAP_TOKENS_FOR_EXACT_ETH = 0x4a25d94a;\n\n    // execute_ncC(address,uint256,bytes)\n    bytes4 public constant EXECUTE_OPTIMIZED_SELECTOR = 0x0000189a;\n    // function executeBatch_y6U( address[] calldata dest, uint256[] calldata value, bytes[] calldata func)\n    bytes4 public constant EXECUTE_BATCH_SELECTOR = 0x00004680;\n\n    /**\n     * @dev validates if the _op (UserOperation) matches the SessionKey permissions\n     * and that _op has been signed by this SessionKey\n     * Please mind the decimals of your exact token when setting maxAmount\n     * @param token the non-native token of the pair\n     * @return true if the _op is valid, false otherwise.\n     */\n    function validateSell(\n        UserOperation memory op,\n        address token,\n        uint256 spentAmount,\n        uint256 payment,\n        address WRAPPED_NATIVE_TOKEN,\n        address ROUTER,\n        address FEE_RECIPIENT\n    ) internal pure returns (bool) {\n        bytes4 opFncSig = bytes4(op.callData.slice(0, 4));\n\n        bytes memory opData = op.callData.slice(4, op.callData.length - 4);\n\n        if (opFncSig == EXECUTE_OPTIMIZED_SELECTOR) {\n            require(payment == 0, \"SV: no payment required\");\n            (address router, , bytes memory data) = abi.decode(\n                opData,\n                (address, uint256, bytes)\n            );\n            require(router == ROUTER, \"SV: invalid router\");\n            validateSellTx(\n                data,\n                op.sender,\n                token,\n                WRAPPED_NATIVE_TOKEN,\n                spentAmount\n            );\n        } else if (opFncSig == EXECUTE_BATCH_SELECTOR) {\n            (\n                address[] memory addresses,\n                uint256[] memory callValues,\n                bytes[] memory data\n            ) = abi.decode(opData, (address[], uint256[], bytes[]));\n\n            require(\n                addresses.length == callValues.length &&\n                    addresses.length == data.length,\n                \"SV: invalid tx list's length\"\n            );\n            uint256 fncNum = addresses.length;\n            require(fncNum >= 2 && fncNum <= 3, \"SV: invalid number of txs\");\n\n            uint256 sellTxIndex;\n            if (payment > 0) {\n                require(\n                    addresses[fncNum - 1] == FEE_RECIPIENT,\n                    \"SV: must pay fee\"\n                );\n                require(\n                    callValues[fncNum - 1] == payment,\n                    \"SV: invalid payment\"\n                );\n                sellTxIndex = fncNum - 2;\n            } else {\n                sellTxIndex = fncNum - 1;\n            }\n\n            require(addresses[sellTxIndex] == ROUTER, \"SV: invalid router\");\n            validateSellTx(\n                data[sellTxIndex],\n                op.sender,\n                token,\n                WRAPPED_NATIVE_TOKEN,\n                spentAmount\n            );\n\n            if (sellTxIndex == 1) {\n                require(addresses[0] == token, \"SV: must approve token\");\n\n                bytes4 fncSig = bytes4(data[0].slice(0, 4));\n                require(\n                    fncSig == ERC20_APPROVE_SELECTOR,\n                    \"SV: Invalid op funtion signature\"\n                );\n\n                bytes memory funcData = data[0].slice(4, data[0].length - 4);\n                (address router, ) = abi.decode(funcData, (address, uint256));\n                require(router == ROUTER, \"SV: invalid spender\");\n            }\n        } else {\n            revert(\"Invalid op funtion signature\");\n        }\n\n        return true;\n    }\n\n    function validateSellTx(\n        bytes memory data,\n        address sender,\n        address token,\n        address WRAPPED_NATIVE_TOKEN,\n        uint256 spentAmount\n    ) internal pure {\n        bytes4 fncSig = bytes4(data.slice(0, 4));\n\n        bytes memory funcData = data.slice(4, data.length - 4);\n\n        if (fncSig == EXACT_OUTPUT_SINGLE_SELECTOR) {\n            ExactOutputSingleParams memory params = abi.decode(\n                funcData,\n                (ExactOutputSingleParams)\n            );\n\n            require(\n                params.tokenOut == WRAPPED_NATIVE_TOKEN,\n                \"SV: only accept Wrapped native token as tokenOut\"\n            );\n            require(params.tokenIn == token, \"SV: Wrong token out\");\n            require(\n                params.amountOut == spentAmount,\n                \"SV: spent amounts mismatch\"\n            );\n            require(params.recipient == sender, \"SV: Wrong recipient\");\n        } else if (fncSig == UNIV2_SWAP_TOKENS_FOR_EXACT_ETH) {\n            (uint256 amountOut, , address[] memory path, address to, ) = abi\n                .decode(\n                    funcData,\n                    (uint256, uint256, address[], address, uint256)\n                );\n            require(amountOut == spentAmount, \"BV: invalid amount in\");\n            require(path[0] == token, \"BV: invalid token in\");\n            require(\n                path[path.length - 1] == WRAPPED_NATIVE_TOKEN,\n                \"BV: invalid token out\"\n            );\n            require(to == sender, \"BV: invalid recipient\");\n        } else {\n            revert(\"SV: swap function is not supported\");\n        }\n    }\n}\n"
    },
    "contracts/modules/SwapSessionValidationModules/SwapSessionKeyManagerModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {BaseAuthorizationModule} from \"../BaseAuthorizationModule.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@account-abstraction/contracts/core/Helpers.sol\";\nimport {ISessionKeyManager} from \"../../interfaces/ISessionKeyManager.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./BuyValidator.sol\";\nimport \"./SellValidator.sol\";\nimport \"./PreApproveValidator.sol\";\n\ninterface ISmartAccount {\n    function getOwner(address smartAccount) external view returns (address);\n}\n\ncontract SwapSessionKeyManager is BaseAuthorizationModule {\n    address public ECDSA_MODULE_ADDRESS;\n    address public WRAPPED_NATIVE_TOKEN;\n    address public FEE_RECIPIENT;\n    uint48 public constant FEE_RATE_PRECISION = 1e6;\n    uint48 public constant HALF_FEE_RATE_PRECISION = 5e5;\n    uint48 public FEE_RATE;\n    uint256 public FEE_THRESHOLD;\n\n    constructor(\n        address _ECDSA_MODULE_ADDRESS,\n        address _WRAPPED_NATIVE_TOKEN,\n        address _FEE_RECIPIENT,\n        uint48 _FEE_RATE,\n        uint256 _FEE_THRESHOLD\n    ) {\n        ECDSA_MODULE_ADDRESS = _ECDSA_MODULE_ADDRESS;\n        WRAPPED_NATIVE_TOKEN = _WRAPPED_NATIVE_TOKEN;\n        FEE_RECIPIENT = _FEE_RECIPIENT;\n        require(\n            _FEE_RATE < FEE_RATE_PRECISION,\n            \"Fee rate must be less than 100%\"\n        );\n        FEE_RATE = _FEE_RATE;\n        FEE_THRESHOLD = _FEE_THRESHOLD;\n    }\n\n    /**\n     * @dev mapping of owner to a session root\n     */\n    mapping(address => bytes32) public merkleRoot;\n\n    /**\n     * @dev mapping of owner to trading quota\n     */\n    mapping(address => uint256) public tradingQuota;\n\n    /**\n     * @dev mapping of session key to accumulated fee\n     */\n    mapping(address => uint256) public accumulatedFee;\n\n    function setMerkleRootAndTradingQuota(bytes32 _merkleRoot, uint256 _tradingQuota) external {\n        merkleRoot[msg.sender] = _merkleRoot;\n        tradingQuota[msg.sender] = _tradingQuota;\n    }\n\n    /**\n     * @dev validates userOperation\n     * @param userOp User Operation to be validated.\n     * @param userOpHash Hash of the User Operation to be validated.\n     * @return sigValidationResult 0 if signature is valid, SIG_VALIDATION_FAILED otherwise.\n     */\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external virtual returns (uint256) {\n        address sender = userOp.sender;\n        address owner = ISmartAccount(ECDSA_MODULE_ADDRESS).getOwner(sender);\n\n        (bytes memory moduleSignature, ) = abi.decode(\n            userOp.signature,\n            (bytes, address)\n        );\n        (\n            uint48 validUntil,\n            uint48 validAfter,\n            address router,\n            address token,\n            address sessionKey,\n            uint256 maxETHSpend,\n            uint256 spentAmount,\n            bool approveAll,\n            bool isBuyOrder,\n            bytes32[] memory merkleProof,\n            bytes memory sessionKeySignature\n        ) = abi.decode(\n                moduleSignature,\n                (\n                    uint48,\n                    uint48,\n                    address,\n                    address,\n                    address,\n                    uint256,\n                    uint256,\n                    bool,\n                    bool,\n                    bytes32[],\n                    bytes\n                )\n            );\n\n        bytes32 root = merkleRoot[owner];\n\n        bytes32 leaf;\n        if (!approveAll)\n            leaf = keccak256(\n                abi.encodePacked(\n                    validUntil,\n                    validAfter,\n                    token,\n                    sessionKey,\n                    sender,\n                    router,\n                    maxETHSpend\n                )\n            );\n        else\n            leaf = keccak256(\n                abi.encodePacked(\n                    validUntil,\n                    validAfter,\n                    sessionKey,\n                    sender,\n                    router,\n                    maxETHSpend\n                )\n            );\n        if (!MerkleProof.verify(merkleProof, root, leaf)) {\n            revert(\"SessionNotApproved\");\n        }\n\n        bool validSig = ECDSA.recover(\n            ECDSA.toEthSignedMessageHash(userOpHash),\n            sessionKeySignature\n        ) == sessionKey;\n\n        bool validOp;\n\n        if (spentAmount > 0) {\n            require(\n                token != address(0) && token != WRAPPED_NATIVE_TOKEN,\n                \"Specified token must be non-native\"\n            );\n\n            if (spentAmount > maxETHSpend)\n                revert(\"Maximum ETH per tx exceeded\");\n            uint256 currentTradingQuota = tradingQuota[owner];\n            if (spentAmount > currentTradingQuota)\n                revert(\"Trading quota exceeded\");\n            tradingQuota[owner] = currentTradingQuota - spentAmount;\n\n            uint256 fee = (spentAmount * FEE_RATE + HALF_FEE_RATE_PRECISION) /\n                FEE_RATE_PRECISION;\n\n            uint256 currentAccumulatedFee = accumulatedFee[sessionKey] + fee;\n            uint256 payment;\n            if (currentAccumulatedFee >= FEE_THRESHOLD) {\n                payment = currentAccumulatedFee;\n                accumulatedFee[sessionKey] = 0;\n            } else {\n                payment = 0;\n                accumulatedFee[sessionKey] = currentAccumulatedFee;\n            }\n\n            if (isBuyOrder) {\n                validOp = BuyValidator.validateBuy(\n                    userOp,\n                    token,\n                    spentAmount,\n                    payment,\n                    WRAPPED_NATIVE_TOKEN,\n                    router,\n                    FEE_RECIPIENT\n                );\n            } else {\n                validOp = SellValidator.validateSell(\n                    userOp,\n                    token,\n                    spentAmount,\n                    payment,\n                    WRAPPED_NATIVE_TOKEN,\n                    router,\n                    FEE_RECIPIENT\n                );\n            }\n        } else {\n            // approve\n            validOp = PreApproveValidator.validatePreApprove(\n                userOp,\n                token,\n                router\n            );\n        }\n\n        return\n            _packValidationData(\n                //_packValidationData expects true if sig validation has failed, false otherwise\n                !(validOp && validSig),\n                validUntil,\n                validAfter\n            );\n    }\n\n    /**\n     * @dev returns the SessionStorage object for a given owner\n     * @param owner owner address\n     */\n    function getSessionRoot(address owner) external view returns (bytes32) {\n        return merkleRoot[owner];\n    }\n\n    /**\n     * @dev returns the accumulated fee of a given sessionKey\n     * @param sessionKey sessionKey address\n     */\n    function getAccumulatedFee(\n        address sessionKey\n    ) external view returns (uint256) {\n        return accumulatedFee[sessionKey];\n    }\n\n    /**\n     * @dev isValidSignature according to BaseAuthorizationModule\n     * @param _dataHash Hash of the data to be validated.\n     * @param _signature Signature over the the _dataHash.\n     * @return always returns 0xffffffff as signing messages is not supported by SessionKeys\n     */\n    function isValidSignature(\n        bytes32 _dataHash,\n        bytes memory _signature\n    ) public pure override returns (bytes4) {\n        (_dataHash, _signature);\n        return 0xffffffff; // do not support it here\n    }\n}\n"
    },
    "contracts/paymasters/BasePaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IPaymaster} from \"@account-abstraction/contracts/interfaces/IPaymaster.sol\";\nimport {IEntryPoint} from \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\nimport {BaseSmartAccountErrors} from \"../common/Errors.sol\";\nimport \"@account-abstraction/contracts/core/Helpers.sol\";\n\n/**\n * Helper class for creating a paymaster.\n * provides helper methods for staking.\n * validates that the postOp is called only by the ENTRY_POINT\n @notice Could have Ownable2Step\n */\nabstract contract BasePaymaster is IPaymaster, Ownable, BaseSmartAccountErrors {\n    IEntryPoint public immutable ENTRY_POINT;\n\n    constructor(address _owner, IEntryPoint _entryPoint) {\n        ENTRY_POINT = _entryPoint;\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * add a deposit for this paymaster, used for paying for transaction fees\n     */\n    function deposit() external payable virtual;\n\n    /// @inheritdoc IPaymaster\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost\n    ) external override {\n        _requireFromEntryPoint();\n        _postOp(mode, context, actualGasCost);\n    }\n\n    /// @inheritdoc IPaymaster\n    function validatePaymasterUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external override returns (bytes memory context, uint256 validationData) {\n        _requireFromEntryPoint();\n        return _validatePaymasterUserOp(userOp, userOpHash, maxCost);\n    }\n\n    /**\n     * withdraw value from the deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 amount\n    ) external virtual;\n\n    /**\n     * add stake for this paymaster.\n     * This method can also carry eth value to add to the current stake.\n     * @param unstakeDelaySec - the unstake delay for this paymaster. Can only be increased.\n     */\n    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\n        ENTRY_POINT.addStake{value: msg.value}(unstakeDelaySec);\n    }\n\n    /**\n     * unlock the stake, in order to withdraw it.\n     * The paymaster can't serve requests once unlocked, until it calls addStake again\n     */\n    function unlockStake() external onlyOwner {\n        ENTRY_POINT.unlockStake();\n    }\n\n    /**\n     * withdraw the entire paymaster's stake.\n     * stake must be unlocked first (and then wait for the unstakeDelay to be over)\n     * @param withdrawAddress the address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external onlyOwner {\n        ENTRY_POINT.withdrawStake(withdrawAddress);\n    }\n\n    /**\n     * return current paymaster's deposit on the ENTRY_POINT.\n     */\n    function getDeposit() public view returns (uint256) {\n        return ENTRY_POINT.balanceOf(address(this));\n    }\n\n    function _validatePaymasterUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) internal virtual returns (bytes memory context, uint256 validationData);\n\n    /**\n     * post-operation handler.\n     * (verified to be called only through the ENTRY_POINT)\n     * @dev if subclass returns a non-empty context from validatePaymasterUserOp, it must also implement this method.\n     * @param mode enum with the following options:\n     *      opSucceeded - user operation succeeded.\n     *      opReverted  - user op reverted. still has to pay for gas.\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\n     * @param context - the context value returned by validatePaymasterUserOp\n     * @param actualGasCost - actual gas used so far (without this postOp call).\n     */\n    function _postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost\n    ) internal virtual {\n        (mode, context, actualGasCost); // unused params\n        // subclass must override this method if validatePaymasterUserOp returns a context\n        revert(\"must override\");\n    }\n\n    /// validate the call is made from a valid entrypoint\n    function _requireFromEntryPoint() internal virtual {\n        if (msg.sender != address(ENTRY_POINT))\n            revert CallerIsNotAnEntryPoint(msg.sender);\n    }\n}\n"
    },
    "contracts/paymasters/PaymasterHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\n\nstruct PaymasterData {\n    address paymasterId;\n    uint48 validUntil;\n    uint48 validAfter;\n    bytes signature;\n    uint256 signatureLength;\n}\n\nstruct PaymasterContext {\n    address paymasterId;\n    // could add maxFeePerGas and maxPriorityFeePerGas if needed\n    // by making approprate changes in paymaster contract\n}\n\n/**\n * @title PaymasterHelpers - helper functions for paymasters\n */\nlibrary PaymasterHelpers {\n    using ECDSA for bytes32;\n\n    /**\n     * @dev Encodes the paymaster context: paymasterId and gasPrice\n     * @param data PaymasterData passed\n     */\n    function paymasterContext(\n        PaymasterData memory data\n    )\n        internal\n        pure\n        returns (\n            // Could add maxFeePerGas and maxPriorityFeePerGas if needed\n            bytes memory context\n        )\n    {\n        return abi.encode(data.paymasterId);\n    }\n\n    /**\n     * @dev Decodes paymaster data assuming it follows PaymasterData\n     */\n    function decodePaymasterData(\n        UserOperation calldata op\n    ) internal pure returns (PaymasterData memory) {\n        bytes calldata paymasterAndData = op.paymasterAndData;\n        (\n            address paymasterId,\n            uint48 validUntil,\n            uint48 validAfter,\n            bytes memory signature\n        ) = abi.decode(paymasterAndData[20:], (address, uint48, uint48, bytes));\n        return\n            PaymasterData(\n                paymasterId,\n                validUntil,\n                validAfter,\n                signature,\n                signature.length\n            );\n    }\n\n    /**\n     * @dev Decodes paymaster context assuming it follows PaymasterContext\n     */\n    function decodePaymasterContext(\n        bytes memory context\n    ) internal pure returns (PaymasterContext memory) {\n        address paymasterId = abi.decode(context, (address));\n        return PaymasterContext(paymasterId);\n    }\n}\n"
    },
    "contracts/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {UserOperation, UserOperationLib} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\nimport \"../../BasePaymaster.sol\";\nimport {PaymasterHelpers, PaymasterData, PaymasterContext} from \"../../PaymasterHelpers.sol\";\nimport {SingletonPaymasterErrors} from \"../../../common/Errors.sol\";\n\n/**\n * @title A sample paymaster that uses external service to decide whether to pay for the UserOp.\n * @dev The paymaster trusts an external signer to sign the transaction.\n * The calling user must pass the UserOp to that external signer first, which performs whatever\n * off-chain verification before signing the UserOp.\n * @notice That this signature is NOT a replacement for wallet signature:\n *  - The paymaster signs to agree to PAY for GAS.\n *  - The wallet signs to prove identity and wallet ownership.\n */\ncontract VerifyingSingletonPaymaster is\n    BasePaymaster,\n    ReentrancyGuard,\n    SingletonPaymasterErrors\n{\n    using ECDSA for bytes32;\n    using UserOperationLib for UserOperation;\n    using PaymasterHelpers for UserOperation;\n    using PaymasterHelpers for bytes;\n    using PaymasterHelpers for PaymasterData;\n\n    // Gas used in EntryPoint._handlePostOp() method (including this#postOp() call)\n    uint256 private _unaccountedEPGasOverhead;\n    mapping(address => uint256) public paymasterIdBalances;\n\n    address public verifyingSigner;\n\n    event EPGasOverheadChanged(\n        uint256 indexed _oldValue,\n        uint256 indexed _newValue\n    );\n\n    event VerifyingSignerChanged(\n        address indexed _oldSigner,\n        address indexed _newSigner,\n        address indexed _actor\n    );\n    event GasDeposited(address indexed _paymasterId, uint256 indexed _value);\n    event GasWithdrawn(\n        address indexed _paymasterId,\n        address indexed _to,\n        uint256 indexed _value\n    );\n    event GasBalanceDeducted(\n        address indexed _paymasterId,\n        uint256 indexed _charge\n    );\n\n    constructor(\n        address _owner,\n        IEntryPoint _entryPoint,\n        address _verifyingSigner\n    ) payable BasePaymaster(_owner, _entryPoint) {\n        if (address(_entryPoint) == address(0)) revert EntryPointCannotBeZero();\n        if (_verifyingSigner == address(0))\n            revert VerifyingSignerCannotBeZero();\n        assembly {\n            sstore(verifyingSigner.slot, _verifyingSigner)\n        }\n        _unaccountedEPGasOverhead = 9600;\n    }\n\n    /**\n     * @dev Deposit funds for a given paymasterId to cover transaction fees.\n     * @param paymasterId Identifier of the dapp receiving the deposit.\n     */\n    function depositFor(address paymasterId) external payable nonReentrant {\n        if (paymasterId == address(0)) revert PaymasterIdCannotBeZero();\n        if (msg.value == 0) revert DepositCanNotBeZero();\n        paymasterIdBalances[paymasterId] =\n            paymasterIdBalances[paymasterId] +\n            msg.value;\n        ENTRY_POINT.depositTo{value: msg.value}(address(this));\n        emit GasDeposited(paymasterId, msg.value);\n    }\n\n    /**\n     * @dev Set a new verifying signer address.\n     * Can only be called by the owner of the contract.\n     * @param _newVerifyingSigner The new address to be set as the verifying signer.\n     * @notice If _newVerifyingSigner is set to zero address, it will revert with an error.\n     * After setting the new signer address, it will emit an event VerifyingSignerChanged.\n     */\n    function setSigner(address _newVerifyingSigner) external payable onlyOwner {\n        if (_newVerifyingSigner == address(0))\n            revert VerifyingSignerCannotBeZero();\n        address oldSigner = verifyingSigner;\n        assembly {\n            sstore(verifyingSigner.slot, _newVerifyingSigner)\n        }\n        emit VerifyingSignerChanged(oldSigner, _newVerifyingSigner, msg.sender);\n    }\n\n    function setUnaccountedEPGasOverhead(uint256 value) external onlyOwner {\n        uint256 oldValue = _unaccountedEPGasOverhead;\n        _unaccountedEPGasOverhead = value;\n        emit EPGasOverheadChanged(oldValue, value);\n    }\n\n    /**\n     * @dev get the current deposit for paymasterId (Dapp Depositor address)\n     * @param paymasterId dapp identifier\n     */\n    function getBalance(\n        address paymasterId\n    ) external view returns (uint256 balance) {\n        balance = paymasterIdBalances[paymasterId];\n    }\n\n    /**\n     @dev Override the default implementation.\n     */\n    function deposit() public payable virtual override {\n        revert(\"user DepositFor instead\");\n    }\n\n    /**\n     * @dev Withdraws specified gas tokens from paymaster's balance to a given address.\n     * @param withdrawAddress Address receiving the gas tokens.\n     * @param amount Amount of gas tokens to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 amount\n    ) public override nonReentrant {\n        if (withdrawAddress == address(0)) revert CanNotWithdrawToZeroAddress();\n        uint256 currentBalance = paymasterIdBalances[msg.sender];\n        if (amount > currentBalance)\n            revert InsufficientBalance(amount, currentBalance);\n        paymasterIdBalances[msg.sender] =\n            paymasterIdBalances[msg.sender] -\n            amount;\n        ENTRY_POINT.withdrawTo(withdrawAddress, amount);\n        emit GasWithdrawn(msg.sender, withdrawAddress, amount);\n    }\n\n    /**\n     * @dev Called by off-chain service for signing, and on-chain in validatePaymasterUserOp for validation.\n     * @notice Signature covers all UserOperation fields except \"paymasterAndData\" which carries the signature.\n     * @return Hash to sign off-chain and validate on-chain.\n     */\n    function getHash(\n        UserOperation calldata userOp,\n        address paymasterId,\n        uint48 validUntil,\n        uint48 validAfter\n    ) public view returns (bytes32) {\n        // can't use userOp.hash(), since it contains also the paymasterAndData itself.\n        address sender = userOp.getSender();\n        return\n            keccak256(\n                abi.encode(\n                    sender,\n                    userOp.nonce,\n                    keccak256(userOp.initCode),\n                    keccak256(userOp.callData),\n                    userOp.callGasLimit,\n                    userOp.verificationGasLimit,\n                    userOp.preVerificationGas,\n                    userOp.maxFeePerGas,\n                    userOp.maxPriorityFeePerGas,\n                    block.chainid,\n                    address(this),\n                    paymasterId,\n                    validUntil,\n                    validAfter\n                )\n            );\n    }\n\n    /**\n     * @dev Executes the paymaster's payment conditions\n     * @param mode tells whether the op succeeded, reverted, or if the op succeeded but cause the postOp to revert\n     * @param context payment conditions signed by the paymaster in `validatePaymasterUserOp`\n     * @param actualGasCost amount to be paid to the entry point in wei\n     */\n    function _postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost\n    ) internal virtual override {\n        (mode);\n        PaymasterContext memory data = context.decodePaymasterContext();\n        address extractedPaymasterId = data.paymasterId;\n        uint256 balToDeduct = actualGasCost +\n            _unaccountedEPGasOverhead *\n            tx.gasprice;\n        paymasterIdBalances[extractedPaymasterId] =\n            paymasterIdBalances[extractedPaymasterId] -\n            balToDeduct;\n        emit GasBalanceDeducted(extractedPaymasterId, balToDeduct);\n    }\n\n    /**\n     * @dev Verify that an external signer signed the paymaster data of a user operation.\n     * The paymaster data is expected to be the paymaster and a signature over the entire request parameters.\n     * @param userOp The UserOperation struct that represents the current user operation.\n     * userOpHash The hash of the UserOperation struct.\n     * @param requiredPreFund The required amount of pre-funding for the paymaster.\n     * @return context A context string returned by the entry point after successful validation.\n     * @return validationData An integer returned by the entry point after successful validation.\n     */\n    function _validatePaymasterUserOp(\n        UserOperation calldata userOp,\n        bytes32 /*userOpHash*/,\n        uint256 requiredPreFund\n    )\n        internal\n        view\n        override\n        returns (bytes memory context, uint256 validationData)\n    {\n        PaymasterData memory paymasterData = userOp.decodePaymasterData();\n        bytes32 hash = getHash(\n            userOp,\n            paymasterData.paymasterId,\n            paymasterData.validUntil,\n            paymasterData.validAfter\n        );\n        uint256 sigLength = paymasterData.signatureLength;\n        // Ensure revert reason is from \"VerifyingPaymaster\" not \"ECDSA\" on invalid signature.\n\n        if (sigLength != 65) revert InvalidPaymasterSignatureLength(sigLength);\n        // Don't revert on signature failure: return SIG_VALIDATION_FAILED.\n        if (\n            verifyingSigner !=\n            hash.toEthSignedMessageHash().recover(paymasterData.signature)\n        ) {\n            // Empty context and sigFailed with time range provided\n            return (\n                \"\",\n                _packValidationData(\n                    true,\n                    paymasterData.validUntil,\n                    paymasterData.validAfter\n                )\n            );\n        }\n        if (requiredPreFund > paymasterIdBalances[paymasterData.paymasterId])\n            revert InsufficientBalance(\n                requiredPreFund,\n                paymasterIdBalances[paymasterData.paymasterId]\n            );\n        return (\n            PaymasterHelpers.paymasterContext(paymasterData),\n            _packValidationData(\n                false,\n                paymasterData.validUntil,\n                paymasterData.validAfter\n            )\n        );\n    }\n}\n"
    },
    "contracts/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @title Proxy // This is the user's Smart Account\n * @notice Basic proxy that delegates all calls to a fixed implementation contract.\n * @dev    Implementation address is stored in the slot defined by the Proxy's address\n */\ncontract Proxy {\n    constructor(address _implementation) {\n        require(\n            _implementation != address(0),\n            \"Invalid implementation address\"\n        );\n        assembly {\n            sstore(address(), _implementation)\n        }\n    }\n\n    fallback() external payable {\n        address target;\n        assembly {\n            target := sload(address())\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/SmartAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {BaseSmartAccount, IEntryPoint, UserOperation} from \"./BaseSmartAccount.sol\";\nimport {ModuleManager} from \"./base/ModuleManager.sol\";\nimport {FallbackManager} from \"./base/FallbackManager.sol\";\nimport {LibAddress} from \"./libs/LibAddress.sol\";\nimport {ISignatureValidator} from \"./interfaces/ISignatureValidator.sol\";\nimport {IERC165} from \"./interfaces/IERC165.sol\";\nimport {SmartAccountErrors} from \"./common/Errors.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {IAuthorizationModule} from \"./interfaces/IAuthorizationModule.sol\";\n\n/**\n * @title SmartAccount - EIP-4337 compatible smart contract wallet.\n * @dev This contract is the base for the Smart Account functionality.\n *         - It is modular by nature. UserOp and txns validation happens in Authorization Modules.\n *         - It provides the functionality to execute AA (EIP-4337) userOps. Gnosis style txns removed to a module.\n *         - It allows to receive and manage assets.\n *         - It is responsible for managing the modules and fallbacks.\n *         - The Smart Account can be extended with modules, such as Social Recovery, Session Key and others.\n * @author Chirag Titiya - <chirag@biconomy.io>, Filipp Makarov - <filipp.makarov@biconomy.io>\n */\ncontract SmartAccount is\n    BaseSmartAccount,\n    ModuleManager,\n    FallbackManager,\n    IERC165,\n    SmartAccountErrors,\n    ISignatureValidator\n{\n    using ECDSA for bytes32;\n    using LibAddress for address;\n\n    // Storage Version\n    string public constant VERSION = \"2.0.0\";\n\n    // Owner storage. Deprecated. Left for storage layout compatibility\n    address public ownerDeprecated;\n\n    // changed to 2D nonce below\n    // @notice there is no _nonce\n    // Deprecated. Left for storage layout compatibility\n    mapping(uint256 => uint256) public noncesDeprecated;\n\n    // AA immutable storage\n    IEntryPoint private immutable ENTRY_POINT;\n    address private immutable SELF;\n\n    // Events\n    event ImplementationUpdated(\n        address indexed oldImplementation,\n        address indexed newImplementation\n    );\n    event SmartAccountReceivedNativeToken(\n        address indexed sender,\n        uint256 indexed value\n    );\n\n    /**\n     * @dev Constructor that sets the entry point contract.\n     *      _modules[SENTINEL_MODULES] = SENTINEL_MODULES protects implementation from initialization\n     * @param anEntryPoint The address of the entry point contract.\n     */\n    constructor(IEntryPoint anEntryPoint) {\n        SELF = address(this);\n        if (address(anEntryPoint) == address(0))\n            revert EntryPointCannotBeZero();\n        ENTRY_POINT = anEntryPoint;\n        _modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n    }\n\n    /**\n     * @dev This function is a special fallback function that is triggered when the contract receives Ether.\n     * It logs an event indicating the amount of Ether received and the sender's address.\n     * @notice This function is marked as external and payable, meaning it can be called from external\n     * sources and accepts Ether as payment.\n     */\n    receive() external payable {\n        if (address(this) == SELF) revert DelegateCallsOnly();\n        emit SmartAccountReceivedNativeToken(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Initialize the Smart Account with required states\n     * @param handler Default fallback handler provided in Smart Account\n     * @param sessionKeyModuleContract Contract, that enables session key module\n     * @param authModuleSetupContract Contract, that setups initial auth module for this smart account.\n     * It can be a module factory or a registry module that serves several smart accounts\n     * @param authModuleSetupData modules setup data (a standard calldata for the module setup contract)\n     * @notice devs need to make sure it is only callable once by initializer or state check restrictions\n     * @notice any further implementations that introduces a new state must have a reinit method\n     * @notice reinitialization is not possible, as _initialSetupModules reverts if the account is already initialized\n     *         which is when there is at least one enabled module\n     */\n    function init(\n        address handler,\n        address sessionKeyModuleContract,\n        address authModuleSetupContract,\n        bytes calldata authModuleSetupData\n    ) external virtual override returns (address authAddress) {\n        if (\n            _modules[SENTINEL_MODULES] != address(0) ||\n            getFallbackHandler() != address(0)\n        ) revert AlreadyInitialized();\n        _setFallbackHandler(handler);\n        authAddress = _initialSetupModules(\n            authModuleSetupContract,\n            authModuleSetupData\n        );\n        _enableModule(sessionKeyModuleContract);\n    }\n\n    /**\n     * @dev Interface function with the standard name for execute_ncC\n     * @param dest Address of the contract to call\n     * @param value Amount of native tokens to send along with the transaction\n     * @param func Data of the transaction\n     */\n    function execute(\n        address dest,\n        uint256 value,\n        bytes calldata func\n    ) external {\n        execute_ncC(dest, value, func);\n    }\n\n    /**\n     * @dev Interface function with the standard name for executeBatch_y6U\n     * @param dest Addresses of the contracts to call\n     * @param value Amounts of native tokens to send along with the transactions\n     * @param func Data of the transactions\n     */\n    function executeBatch(\n        address[] calldata dest,\n        uint256[] calldata value,\n        bytes[] calldata func\n    ) external {\n        executeBatch_y6U(dest, value, func);\n    }\n\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external virtual override returns (uint256 validationData) {\n        if (msg.sender != address(entryPoint()))\n            revert CallerIsNotAnEntryPoint(msg.sender);\n\n        (, address validationModule) = abi.decode(\n            userOp.signature,\n            (bytes, address)\n        );\n        if (address(_modules[validationModule]) != address(0)) {\n            validationData = IAuthorizationModule(validationModule)\n                .validateUserOp(userOp, userOpHash);\n        } else {\n            revert WrongValidationModule(validationModule);\n        }\n        // Check nonce requirement if any\n        _payPrefund(missingAccountFunds);\n    }\n\n    /**\n     * @dev Adds a module to the allowlist.\n     * @notice This can only be done via a userOp or a selfcall.\n     * @notice Enables the module `module` for the wallet.\n     * @param module Module to be allow-listed.\n     */\n    function enableModule(address module) external virtual override {\n        _requireFromEntryPointOrSelf();\n        _enableModule(module);\n    }\n\n    /**\n     * @dev Setups module for this Smart Account and enables it.\n     * @notice This can only be done via userOp or a selfcall.\n     * @notice Enables the module `module` for the wallet.\n     */\n    function setupAndEnableModule(\n        address setupContract,\n        bytes memory setupData\n    ) external virtual override returns (address) {\n        _requireFromEntryPointOrSelf();\n        return _setupAndEnableModule(setupContract, setupData);\n    }\n\n    /**\n     * @dev Sets the fallback handler.\n     * @notice This can only be done via a UserOp sent by EntryPoint.\n     * @param handler Handler to be set.\n     */\n    function setFallbackHandler(address handler) external virtual override {\n        _requireFromEntryPointOrSelf();\n        _setFallbackHandler(handler);\n    }\n\n    /**\n     * @dev Returns the address of the implementation contract associated with this contract.\n     * @notice The implementation address is stored in the contract's storage slot with index 0.\n     */\n    function getImplementation()\n        external\n        view\n        returns (address _implementation)\n    {\n        assembly {\n            _implementation := sload(address())\n        }\n    }\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @param _interfaceId The interface identifier, as specified in ERC165\n     * @return `true` if the contract implements `_interfaceID`\n     */\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) external view virtual override returns (bool) {\n        return _interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n\n    /**\n     * @notice All the new implementations MUST have this method!\n     * @notice Updates the implementation of the base wallet\n     * @param _implementation New wallet implementation\n     */\n    function updateImplementation(address _implementation) public virtual {\n        _requireFromEntryPointOrSelf();\n        require(_implementation != address(0), \"Address cannot be zero\");\n        if (!_implementation.isContract())\n            revert InvalidImplementation(_implementation);\n        address oldImplementation;\n\n        assembly {\n            oldImplementation := sload(address())\n            sstore(address(), _implementation)\n        }\n        emit ImplementationUpdated(oldImplementation, _implementation);\n    }\n\n    /* solhint-disable func-name-mixedcase */\n\n    /**\n     * @dev Execute a transaction (called by entryPoint)\n     * @notice Name is optimized for this method to be cheaper to be called\n     * @param dest Address of the contract to call\n     * @param value Amount of native tokens to send along with the transaction\n     * @param func Data of the transaction\n     */\n    function execute_ncC(\n        address dest,\n        uint256 value,\n        bytes calldata func\n    ) public {\n        _requireFromEntryPoint();\n        _call(dest, value, func);\n    }\n\n    /**\n     * @dev Execute a sequence of transactions\n     * @notice Name is optimized for this method to be cheaper to be called\n     * @param dest Addresses of the contracts to call\n     * @param value Amounts of native tokens to send along with the transactions\n     * @param func Data of the transactions\n     */\n    function executeBatch_y6U(\n        address[] calldata dest,\n        uint256[] calldata value,\n        bytes[] calldata func\n    ) public {\n        _requireFromEntryPoint();\n        if (\n            dest.length == 0 ||\n            dest.length != value.length ||\n            value.length != func.length\n        ) revert WrongBatchProvided(dest.length, value.length, func.length, 0);\n        for (uint256 i; i < dest.length; ) {\n            _call(dest[i], value[i], func[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /* solhint-enable func-name-mixedcase */\n\n    /**\n     * @dev Deposit more funds for this account in the entryPoint\n     */\n    function addDeposit() public payable {\n        entryPoint().depositTo{value: msg.value}(address(this));\n    }\n\n    /**\n     * @dev Withdraw value from the account's deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawDepositTo(\n        address payable withdrawAddress,\n        uint256 amount\n    ) public payable {\n        _requireFromEntryPointOrSelf();\n        entryPoint().withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * @dev Removes a module from the allowlist.\n     * @notice This can only be done via a wallet transaction.\n     * @notice Disables the module `module` for the wallet.\n     * @param prevModule Module that pointed to the module to be removed in the linked list\n     * @param module Module to be removed.\n     */\n    function disableModule(address prevModule, address module) public virtual {\n        _requireFromEntryPointOrSelf();\n        _disableModule(prevModule, module);\n    }\n\n    /**\n     * @dev Returns the current entry point used by this account.\n     * @return EntryPoint as an `IEntryPoint` interface.\n     * @dev This function should be implemented by the subclass to return the current entry point used by this account.\n     */\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return ENTRY_POINT;\n    }\n\n    /**\n     * @dev Check current account deposit in the entryPoint\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint().balanceOf(address(this));\n    }\n\n    /**\n     * Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)\n     * @dev Forwards the validation to the module specified in the signature\n     * @param dataHash 32 bytes hash of the data signed on the behalf of address(msg.sender)\n     * @param signature Signature byte array associated with dataHash\n     * @return bytes4 value.\n     */\n    function isValidSignature(\n        bytes32 dataHash,\n        bytes memory signature\n    ) public view override returns (bytes4) {\n        (bytes memory moduleSignature, address validationModule) = abi.decode(\n            signature,\n            (bytes, address)\n        );\n        if (address(_modules[validationModule]) != address(0)) {\n            return\n                ISignatureValidator(validationModule).isValidSignature(\n                    dataHash,\n                    moduleSignature\n                );\n        } else {\n            revert WrongValidationModule(validationModule);\n        }\n    }\n\n    /**\n     * @dev internal method that fecilitates the extenral calls from SmartAccount\n     * @dev similar to execute() of Executor.sol\n     * @param target destination address contract/non-contract\n     * @param value amount of native tokens\n     * @param data function singature of destination\n     */\n    function _call(address target, uint256 value, bytes memory data) internal {\n        assembly {\n            let success := call(\n                gas(),\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, returndatasize())\n            if iszero(success) {\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This function allows entry point or SA itself to execute certain actions.\n     * If the caller is not authorized, the function will revert with an error message.\n     * @notice This function acts as modifier and is marked as internal to be be called\n     * within the contract itself only.\n     */\n    function _requireFromEntryPointOrSelf() internal view {\n        if (msg.sender != address(entryPoint()) && msg.sender != address(this))\n            revert CallerIsNotEntryPointOrSelf(msg.sender);\n    }\n\n    /**\n     * @dev This function allows entry point to execute certain actions.\n     * If the caller is not authorized, the function will revert with an error message.\n     * @notice This function acts as modifier and is marked as internal to be be called\n     * within the contract itself only.\n     */\n    function _requireFromEntryPoint() internal view {\n        if (msg.sender != address(entryPoint()))\n            revert CallerIsNotEntryPoint(msg.sender);\n    }\n}\n"
    },
    "contracts/test/ForbiddenOpcodeInvokingAuthModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {EcdsaOwnershipRegistryModule} from \"../modules/EcdsaOwnershipRegistryModule.sol\";\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\n\ncontract ForbiddenOpcodeInvokingAuthModule is EcdsaOwnershipRegistryModule {\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external view virtual override returns (uint256) {\n        // Acesss the forbidden opcode\n        require(block.timestamp > 0);\n\n        // Usual Stuff\n        (bytes memory cleanEcdsaSignature, ) = abi.decode(\n            userOp.signature,\n            (bytes, address)\n        );\n        if (_verifySignature(userOpHash, cleanEcdsaSignature, userOp.sender)) {\n            return VALIDATION_SUCCESS;\n        }\n        return SIG_VALIDATION_FAILED;\n    }\n}\n"
    },
    "contracts/test/mocks/MockAuthModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {BaseAuthorizationModule} from \"../../modules/BaseAuthorizationModule.sol\";\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\n\ncontract MockAuthModule is BaseAuthorizationModule {\n    mapping(address => bytes) internal setupData;\n\n    function init(bytes calldata setupData_) external returns (address) {\n        setupData[msg.sender] = setupData_;\n        return address(this);\n    }\n\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external returns (uint256 validationData) {\n        (userOp, userOpHash);\n        validationData = 0; //means validation success\n    }\n\n    function isValidSignature(\n        bytes32 _dataHash,\n        bytes memory _signature\n    ) public view virtual override returns (bytes4) {\n        (_dataHash, _signature);\n        return EIP1271_MAGIC_VALUE; //always valid signature\n    }\n}\n"
    },
    "contracts/test/mocks/MockEntryPoint.sol": {
      "content": "import \"@account-abstraction/contracts/core/EntryPoint.sol\";\n\ncontract MockEntryPoint is EntryPoint{}"
    },
    "contracts/test/mocks/MockInvalidAuthModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\ncontract MockInvalidAuthModule {\n    mapping(address => bytes) internal _setupData;\n\n    function init(bytes calldata setupData_) external returns (address) {\n        _setupData[msg.sender] = setupData_;\n        return address(this);\n    }\n\n    // Doesn't have validateUserOp function\n    // Doesn't have isValidSignature function\n}\n"
    },
    "contracts/test/mocks/MockInvalidInitialAuthModule copy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {BaseAuthorizationModule} from \"../../modules/BaseAuthorizationModule.sol\";\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\n\ncontract MockInvalidInitialAuthModule is BaseAuthorizationModule {\n    mapping(address => bytes) internal _setupData;\n\n    function init(bytes calldata setupData_) external returns (address) {\n        _setupData[msg.sender] = setupData_;\n        // return address(this);\n        // should return an address of a module that has been set up but it doesn't\n    }\n\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external returns (uint256 validationData) {\n        (userOp, userOpHash);\n        validationData = 0; //means validation success\n    }\n\n    function isValidSignature(\n        bytes32 _dataHash,\n        bytes memory _signature\n    ) public view virtual override returns (bytes4) {\n        (_dataHash, _signature);\n        return EIP1271_MAGIC_VALUE; //always valid signature\n    }\n}\n"
    },
    "contracts/test/mocks/MockProtocol/MockProtocol.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockProtocol {\n    function interact(address token, uint256 amount) external {\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n    }\n}\n"
    },
    "contracts/test/mocks/MockQuoter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\ncontract MockQuoter {\n    struct QuoteExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint24 fee;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function quoteExactInputSingle(\n        QuoteExactInputSingleParams memory params\n    )\n        external\n        returns (\n            uint256 amountOut,\n            uint160 sqrtPriceX96After,\n            uint32 initializedTicksCrossed,\n            uint256 gasEstimate\n        )\n    {}\n\n    struct QuoteExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amount;\n        uint24 fee;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function quoteExactOutputSingle(\n        QuoteExactOutputSingleParams memory params\n    )\n        external\n        returns (\n            uint256 amountIn,\n            uint160 sqrtPriceX96After,\n            uint32 initializedTicksCrossed,\n            uint256 gasEstimate\n        )\n    {}\n}\n"
    },
    "contracts/test/mocks/MockRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\n\ncontract MockRouter is ISwapRouter {\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external override {}\n\n    function exactInputSingle(\n        ExactInputSingleParams calldata params\n    ) external payable override returns (uint256 amountOut) {\n        \n    }\n\n    function exactInput(\n        ExactInputParams calldata params\n    ) external payable override returns (uint256 amountOut) {\n\n    }\n\n    function exactOutputSingle(\n        ExactOutputSingleParams calldata params\n    ) external payable override returns (uint256 amountIn) {\n\n    }\n\n    function exactOutput(\n        ExactOutputParams calldata params\n    ) external payable override returns (uint256 amountIn) {\n\n    }\n}"
    },
    "contracts/test/mocks/MockToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken is ERC20 {\n    constructor() ERC20(\"TST\", \"MockToken\") {}\n\n    function mint(address sender, uint256 amount) external {\n        _mint(sender, amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n}\n"
    },
    "contracts/test/mocks/MockUniswapv3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\ncontract MockPool {\n    struct Slot0 {\n        // the current price\n        uint160 sqrtPriceX96;\n        // the current tick\n        int24 tick;\n        // the most-recently updated index of the observations array\n        uint16 observationIndex;\n        // the current maximum number of observations that are being stored\n        uint16 observationCardinality;\n        // the next maximum number of observations to store, triggered in observations.write\n        uint16 observationCardinalityNext;\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\n        // represented as an integer denominator (1/x)%\n        uint8 feeProtocol;\n        // whether the pool is locked\n        bool unlocked;\n    }\n    address public token0;\n    Slot0 public slot0;\n}\n"
    },
    "contracts/test/mocks/MockWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockWrappedETH is ERC20 {\n    constructor() ERC20(\"MWE\", \"MockWrappedETH\") {}\n\n    function mint(address sender, uint256 amount) external {\n        _mint(sender, amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/test/SocialRecoveryModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\nimport \"../SmartAccount.sol\";\nimport {Enum} from \"../common/Enum.sol\";\nimport {IAuthorizationModule} from \"../interfaces/IAuthorizationModule.sol\";\n\n// TODO: To be rebuilt for an ownerless setup => like which validation method does it recover?\n\ncontract SocialRecoveryModule is IAuthorizationModule {\n    struct Friends {\n        address[] friends;\n        uint256 threshold;\n    }\n\n    string public constant NAME = \"Social Recovery Module\";\n    string public constant VERSION = \"0.1.0\";\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n    // @review\n    // Might as well keep a state to mark seen userOpHashes\n    mapping(bytes32 => bool) public opsSeen;\n\n    // @todo\n    // Notice validateAndUpdateNonce in just skipped in case of modules. To avoid replay of same userOpHash I think it should be done.\n\n    mapping(address => Friends) internal _friendsEntries;\n    mapping(address => mapping(address => bool)) public isFriend;\n\n    // isConfirmed - map of [recoveryHash][friend] to bool\n    mapping(bytes32 => mapping(address => bool)) public isConfirmed;\n    mapping(address => uint256) internal _walletsNonces;\n\n    /**\n     * @dev Setup function sets initial storage of contract.\n     */\n    function setup(\n        address[] memory _friends,\n        uint256 _threshold\n    ) public returns (address) {\n        require(\n            _threshold <= _friends.length,\n            \"Threshold exceeds friends count\"\n        );\n        require(_threshold >= 2, \"At least 2 friends required\");\n        Friends storage entry = _friendsEntries[msg.sender];\n        // check for duplicates in friends list\n        for (uint256 i = 0; i < _friends.length; i++) {\n            address friend = _friends[i];\n            require(friend != address(0), \"Invalid friend address provided\");\n            require(\n                !isFriend[msg.sender][friend],\n                \"Duplicate friends provided\"\n            );\n            isFriend[msg.sender][friend] = true;\n        }\n        // update friends list and threshold for smart account\n        entry.friends = _friends;\n        entry.threshold = _threshold;\n        return address(this);\n    }\n\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external virtual returns (uint256) {\n        (bytes memory moduleSignature, ) = abi.decode(\n            userOp.signature,\n            (bytes, address)\n        );\n        return _validateSignature(userOp, userOpHash, moduleSignature);\n    }\n\n    /**\n     * @dev standard validateSignature for modules to validate and mark userOpHash as seen\n     * @param userOp the operation that is about to be executed.\n     * @param userOpHash hash of the user's request data. can be used as the basis for signature.\n     * @return sigValidationResult sigAuthorizer to be passed back to trusting Account, aligns with validationData\n     */\n    function _validateSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        bytes memory moduleSignature\n    ) internal virtual returns (uint256 sigValidationResult) {\n        (userOp, moduleSignature);\n        if (opsSeen[userOpHash] == true) return SIG_VALIDATION_FAILED;\n        opsSeen[userOpHash] = true;\n        // can perform it's own access control logic, verify agaisnt expected signer and return SIG_VALIDATION_FAILED\n        return 0;\n    }\n\n    /**\n     * @dev Confirm friend recovery transaction. Only by friends.\n     */\n    function confirmTransaction(address _wallet, address _newOwner) public {\n        require(onlyFriends(_wallet, msg.sender), \"sender not a friend\");\n        bytes32 recoveryHash = getRecoveryHash(\n            _wallet,\n            _newOwner,\n            _walletsNonces[_wallet]\n        );\n        isConfirmed[recoveryHash][msg.sender] = true;\n    }\n\n    function recoverAccess(address payable _wallet, address _newOwner) public {\n        // require(onlyFriends(_wallet, msg.sender), \"sender not a friend\");\n        bytes32 recoveryHash = getRecoveryHash(\n            _wallet,\n            _newOwner,\n            _walletsNonces[_wallet]\n        );\n        require(\n            isConfirmedByRequiredFriends(recoveryHash, _wallet),\n            \"Not enough confirmations\"\n        );\n        SmartAccount smartAccount = SmartAccount(payable(_wallet));\n        require(\n            smartAccount.execTransactionFromModule(\n                _wallet,\n                0,\n                // abi.encodeCall(\"setOwner\", (newOwner)),\n                abi.encodeWithSignature(\"setOwner(address)\", _newOwner),\n                Enum.Operation.Call\n            ),\n            \"Could not execute recovery\"\n        );\n        _walletsNonces[_wallet]++;\n    }\n\n    function isConfirmedByRequiredFriends(\n        bytes32 recoveryHash,\n        address _wallet\n    ) public view returns (bool) {\n        uint256 confirmationCount;\n        Friends storage entry = _friendsEntries[_wallet];\n        for (uint256 i = 0; i < entry.friends.length; i++) {\n            if (isConfirmed[recoveryHash][entry.friends[i]])\n                confirmationCount++;\n            if (confirmationCount == entry.threshold) return true;\n        }\n        return false;\n    }\n\n    function onlyFriends(\n        address _wallet,\n        address _friend\n    ) public view returns (bool) {\n        Friends storage entry = _friendsEntries[_wallet];\n        for (uint256 i = 0; i < entry.friends.length; i++) {\n            if (entry.friends[i] == _friend) return true;\n        }\n        return false;\n    }\n\n    /// @dev Returns hash of data encoding owner replacement.\n    /// @return Data hash.\n    function getRecoveryHash(\n        address _wallet,\n        address _newOwner,\n        uint256 _nonce\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(_wallet, _newOwner, _nonce));\n    }\n}\n"
    },
    "contracts/test/upgrades/BaseSmartAccountNew.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport {IAccount} from \"@account-abstraction/contracts/interfaces/IAccount.sol\";\nimport {IEntryPoint} from \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport {UserOperationLib, UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\nimport {Enum} from \"../../common/Enum.sol\";\nimport {BaseSmartAccountErrors} from \"../../common/Errors.sol\";\nimport \"@account-abstraction/contracts/core/Helpers.sol\";\n\nstruct Transaction {\n    address to;\n    uint256 value;\n    bytes data;\n    Enum.Operation operation;\n    uint256 targetTxGas;\n}\n\nstruct FeeRefund {\n    uint256 baseGas;\n    uint256 gasPrice; //gasPrice or tokenGasPrice\n    uint256 tokenGasPriceFactor;\n    address gasToken;\n    address payable refundReceiver;\n}\n\n/**\n * Basic account implementation.\n * this contract provides the basic logic for implementing the IAccount interface  - validateUserOp\n * specific account implementation should inherit it and provide the account-specific logic\n */\nabstract contract BaseSmartAccountNew is IAccount, BaseSmartAccountErrors {\n    using UserOperationLib for UserOperation;\n\n    //return value in case of signature failure, with no time-range.\n    // equivalent to _packValidationData(true,0,0);\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n    /**\n     * Validate user's signature and nonce.\n     * subclass doesn't need to override this method. Instead, it should override the specific internal validation methods.\n     */\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external virtual override returns (uint256 validationData) {\n        if (msg.sender != address(entryPoint()))\n            revert CallerIsNotAnEntryPoint(msg.sender);\n        validationData = _validateSignature(userOp, userOpHash);\n        _payPrefund(missingAccountFunds);\n    }\n\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 _batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) external payable virtual returns (bool success);\n\n    function init(address _owner, address _handler) external virtual;\n\n    /**\n     * @return nonce the account nonce.\n     * @dev This method returns the next sequential nonce.\n     * @notice For a nonce of a specific key, use `entrypoint.getNonce(account, key)`\n     */\n    function nonce() public view virtual returns (uint256) {\n        return entryPoint().getNonce(address(this), 0);\n    }\n\n    /**\n     * return the entryPoint used by this account.\n     * subclass should return the current entryPoint used by this account.\n     */\n    function entryPoint() public view virtual returns (IEntryPoint);\n\n    /**\n     * validate the signature is valid for this message.\n     * @param userOp validate the userOp.signature field\n     * @param userOpHash convenient field: the hash of the request, to check the signature against\n     *          (also hashes the entrypoint and chain id)\n     * @return validationData signature and time-range of this operation\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *         otherwise, an address of an \"authorizer\" contract.\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <6-byte> validAfter - first timestamp this operation is valid\n     *      If the account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function _validateSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) internal virtual returns (uint256 validationData);\n\n    /**\n     * sends to the entrypoint (msg.sender) the missing funds for this transaction.\n     * subclass MAY override this method for better funds management\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\n     * it will not be required to send again)\n     * @param missingAccountFunds the minimum value this method should send the entrypoint.\n     *  this value MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n     */\n    function _payPrefund(uint256 missingAccountFunds) internal virtual {\n        if (missingAccountFunds != 0) {\n            (bool success, ) = payable(msg.sender).call{\n                value: missingAccountFunds,\n                gas: type(uint256).max\n            }(\"\");\n            (success);\n            //ignore failure (its EntryPoint's job to verify, not account.)\n        }\n    }\n\n    /**\n     * ensure the request comes from the known entrypoint.\n     */\n    function _requireFromEntryPoint() internal view virtual {\n        require(\n            msg.sender == address(entryPoint()),\n            \"account: not from EntryPoint\"\n        );\n    }\n}\n"
    },
    "contracts/test/upgrades/ModuleManagerNew.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"../../common/Enum.sol\";\nimport \"../../common/SelfAuthorized.sol\";\nimport \"../../base/Executor.sol\";\n\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\ncontract ModuleManagerNew is SelfAuthorized, Executor {\n    // Events\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    address internal constant SENTINEL_MODULES = address(0x1);\n    bytes32 internal constant VERSION = \"1.0.1\";\n\n    mapping(address => address) internal _modules;\n    bool internal _isActive = true;\n\n    function _setupModules(address to, bytes memory data) internal {\n        require(_modules[SENTINEL_MODULES] == address(0), \"BSA100\");\n        _modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(\n                _execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()),\n                \"BSA000\"\n            );\n    }\n\n    /// @dev Allows to add a module to the whitelist.\n    ///      This can only be done via a wallet transaction.\n    /// @notice Enables the module `module` for the wallet.\n    /// @param module Module to be whitelisted.\n    function enableModule(address module) public authorized {\n        // Module address cannot be null or sentinel.\n        require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n        // Module cannot be added twice.\n        require(_modules[module] == address(0), \"BSA102\");\n        _modules[module] = _modules[SENTINEL_MODULES];\n        _modules[SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    /// @dev Allows to remove a module from the whitelist.\n    ///      This can only be done via a wallet transaction.\n    /// @notice Disables the module `module` for the wallet.\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(\n        address prevModule,\n        address module\n    ) public authorized {\n        // Validate module address and check that it corresponds to module index.\n        require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n        require(_modules[prevModule] == module, \"BSA103\");\n        _modules[prevModule] = _modules[module];\n        delete _modules[module];\n        emit DisabledModule(module);\n    }\n\n    /// @dev Allows a Module to execute a wallet transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual returns (bool success) {\n        require(_isActive == true, \"disabled\");\n        // Only whitelisted modules are allowed.\n        require(\n            msg.sender != SENTINEL_MODULES &&\n                _modules[msg.sender] != address(0),\n            \"BSA104\"\n        );\n        // Execute transaction without further confirmations.\n        success = _execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /// @dev Allows a Module to execute a wallet transaction without any further confirmations and return data\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public returns (bool success, bytes memory returnData) {\n        success = execTransactionFromModule(to, value, data, operation);\n\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) public view returns (bool) {\n        return SENTINEL_MODULES != module && _modules[module] != address(0);\n    }\n\n    /// @dev Returns array of modules. Useful for a widget\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(\n        address start,\n        uint256 pageSize\n    ) external view returns (address[] memory array, address next) {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount;\n        address currentModule = _modules[start];\n        while (\n            currentModule != address(0x0) &&\n            currentModule != SENTINEL_MODULES &&\n            moduleCount < pageSize\n        ) {\n            array[moduleCount] = currentModule;\n            currentModule = _modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n\n    // Must reduce the gap this way!\n    uint256[23] private __gap;\n}\n"
    },
    "contracts/test/upgrades/v1/BaseSmartAccountV1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport {IAccount} from \"@account-abstraction/contracts/interfaces/IAccount.sol\";\nimport {IEntryPoint} from \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport {UserOperationLib, UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\nimport {Enum} from \"../../../common/Enum.sol\";\nimport {BaseSmartAccountErrorsV1} from \"./ErrorsV1.sol\";\nimport \"@account-abstraction/contracts/core/Helpers.sol\";\n\nstruct Transaction {\n    address to;\n    Enum.Operation operation;\n    uint256 value;\n    bytes data;\n    uint256 targetTxGas;\n}\n\nstruct FeeRefund {\n    uint256 baseGas;\n    uint256 gasPrice; //gasPrice or tokenGasPrice\n    uint256 tokenGasPriceFactor;\n    address gasToken;\n    address payable refundReceiver;\n}\n\n/**\n * Basic account implementation.\n * This contract provides the basic logic for implementing the IAccount interface: validateUserOp function\n * Specific account implementation should inherit it and provide the account-specific logic\n */\nabstract contract BaseSmartAccount is IAccount, BaseSmartAccountErrorsV1 {\n    using UserOperationLib for UserOperation;\n\n    //return value in case of signature failure, with no time-range.\n    // equivalent to _packValidationData(true,0,0);\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n    /**\n     * Validate user's signature and nonce.\n     * Subclass doesn't need to override this method.\n     * Instead, it should override the specific internal validation methods.\n     */\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external virtual override returns (uint256 validationData) {\n        if (msg.sender != address(entryPoint()))\n            revert CallerIsNotAnEntryPoint(msg.sender);\n        validationData = _validateSignature(userOp, userOpHash);\n        _payPrefund(missingAccountFunds);\n    }\n\n    /**\n     * @dev Gnosis style transaction with optional repay in native tokens OR ERC20\n     * @dev Allows to execute a transaction confirmed by required signature/s and then pays the account that submitted the transaction.\n     * @notice The fees are always transferred, even if the user transaction fails.\n     * @param _tx Smart Account transaction\n     * @param refundInfo Required information for gas refunds\n     * @param signatures Packed signature/s data ({bytes32 r}{bytes32 s}{uint8 v})\n     */\n    function execTransaction(\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) external payable virtual returns (bool success);\n\n    /**\n     * @dev Initialize the Smart Account with required states\n     * @param _owner Signatory of the Smart Account\n     * @param _handler Default fallback handler provided in Smart Account\n     * @notice devs need to make sure it is only callble once by initiazer or state check restrictions\n     */\n    function init(address _owner, address _handler) external virtual;\n\n    /**\n     * @return nonce the account nonce.\n     * @dev This method returns the next sequential nonce.\n     * @notice For a nonce of a specific key, use `entrypoint.getNonce(account, key)`\n     */\n    function nonce() public view virtual returns (uint256) {\n        return entryPoint().getNonce(address(this), 0);\n    }\n\n    /**\n     * return the entryPoint used by this account.\n     * subclass should return the current entryPoint used by this account.\n     */\n    function entryPoint() public view virtual returns (IEntryPoint);\n\n    /**\n     * validate the signature is valid for this message.\n     * @param userOp validate the userOp.signature field\n     * @param userOpHash convenient field: the hash of the request, to check the signature against\n     *          (also hashes the entrypoint and chain id)\n     * @return validationData signature and time-range of this operation\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *         otherwise, an address of an \"authorizer\" contract.\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <6-byte> validAfter - first timestamp this operation is valid\n     *      If the account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function _validateSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) internal virtual returns (uint256 validationData);\n\n    /**\n     * sends to the entrypoint (msg.sender) the missing funds for this transaction.\n     * subclass MAY override this method for better funds management\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\n     * it will not be required to send again)\n     * @param missingAccountFunds the minimum value this method should send the entrypoint.\n     *  this value MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n     */\n    function _payPrefund(uint256 missingAccountFunds) internal virtual {\n        if (missingAccountFunds != 0) {\n            payable(msg.sender).call{\n                value: missingAccountFunds,\n                gas: type(uint256).max\n            }(\"\");\n            //ignore failure (its EntryPoint's job to verify, not account.)\n        }\n    }\n}\n"
    },
    "contracts/test/upgrades/v1/ErrorsV1.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\ncontract BaseSmartAccountErrorsV1 {\n    /**\n     * @notice Throws at onlyEntryPoint when msg.sender is not an EntryPoint set for this Smart Account\n     * @param caller address that tried to call onlyEntryPoint-protected method\n     */\n    error CallerIsNotAnEntryPoint(address caller);\n}\n\ncontract FallbackManagerErrors {\n    /**\n     * @notice Throws if zero address has been provided as Fallback Handler address\n     */\n    error HandlerCannotBeZero();\n}\n\ncontract ModuleManagerErrorsV1 {\n    /**\n     * @notice Throws when trying to initialize module manager that already been initialized\n     */\n    error ModulesAlreadyInitialized();\n\n    /**\n     * @notice Throws when a delegatecall in course of module manager initialization has failed\n     */\n    error ModulesSetupExecutionFailed();\n\n    /**\n     * @notice Throws when address(0) or SENTINEL_MODULES constant has been provided as a module address\n     * @param module Module address provided\n     */\n    error ModuleCannotBeZeroOrSentinel(address module);\n\n    /**\n     * @notice Throws when trying to enable module that has already been enabled\n     * @param module Module address provided\n     */\n    error ModuleAlreadyEnabled(address module);\n\n    /**\n     * @notice Throws when module and previous module mismatch\n     * @param expectedModule expected module at modules[prevModule]\n     * @param returnedModule the module that has been found at modules[prevModule]\n     * @param prevModule previous module address provided at call\n     */\n    error ModuleAndPrevModuleMismatch(\n        address expectedModule,\n        address returnedModule,\n        address prevModule\n    );\n\n    /**\n     * @notice Throws when trying to execute transaction from module that is not enabled\n     * @param module Module address provided\n     */\n    error ModuleNotEnabled(address module);\n\n    /**\n     * @notice Throws when data for executeBatchCall provided in wrong format (i.e. empty array or lengths mismatch)\n     * @param destLength length of destination contracts array\n     * @param valueLength length of txn values array\n     * @param funcLength length of function signatures array\n     * @param operationLength length of operation types array. 0 if there's no operations\n     */\n    error WrongBatchProvided(\n        uint256 destLength,\n        uint256 valueLength,\n        uint256 funcLength,\n        uint256 operationLength\n    );\n}\n\ncontract SmartAccountErrorsV1 is\n    BaseSmartAccountErrorsV1,\n    ModuleManagerErrorsV1\n{\n    /**\n     * @notice Throws if zero address has been provided as Entry Point address\n     */\n    error EntryPointCannotBeZero();\n\n    /**\n     * @notice Throws at mixedAuth when msg.sender is not an owner neither _self\n     * @param caller address that tried to call mixedAuth-protected method\n     */\n    error MixedAuthFail(address caller);\n\n    /**\n     * @notice Throws if trying to change an owner of a SmartAccount to the zero address\n     */\n    error OwnerCannotBeZero();\n\n    /**\n     * @notice Throws if zero address has been provided as Base Implementation address\n     */\n    error BaseImplementationCannotBeZero();\n\n    /**\n     * @notice Throws if there is no code at implementationAddress\n     * @param implementationAddress implementation address provided\n     */\n    error InvalidImplementation(address implementationAddress);\n\n    /**\n     * @notice Throws at onlyOwner when msg.sender is not an owner\n     * @param caller address that tried to call onlyOwner method\n     */\n    error CallerIsNotOwner(address caller);\n\n    /**\n     * @notice Throws at _requireFromEntryPointOrOwner when msg.sender is not an EntryPoint neither an owner\n     * @param caller address that tried to call _requireFromEntryPointOrOwner-protected method\n     */\n    error CallerIsNotEntryPointOrOwner(address caller);\n\n    /**\n     * @notice Throws at _requireFromEntryPointOrSelf when msg.sender is not an EntryPoint neither self\n     * @param caller address that tried to call _requireFromEntryPointOrSelf-protected method\n     */\n    error CallerIsNotEntryPointOrSelf(address caller);\n\n    /**\n     * @notice Throws at _requireFromEntryPoint when msg.sender is not an EntryPoint\n     * @param caller address that tried to call _requireFromEntryPoint-protected method\n     */\n    error CallerIsNotEntryPoint(address caller);\n\n    /**\n     * @notice Throws if trying to initialize a Smart Account that has already been initialized\n     */\n    error AlreadyInitialized();\n\n    /**\n     * @notice Throws if contract signature is provided in frong format\n     * @param uintS s converted to uint256\n     * @param contractSignatureLength length of a contract signature\n     * @param signatureLength the whole signature length\n     */\n    error WrongContractSignatureFormat(\n        uint256 uintS,\n        uint256 contractSignatureLength,\n        uint256 signatureLength\n    );\n\n    /**\n     * @notice Throws when isValidSignature for the conrtact signature and data hash return differs from EIP1271 Magic Value\n     * @param contractSignature the contract signature that has been verified\n     */\n    error WrongContractSignature(bytes contractSignature);\n\n    /**\n     * @notice Throws when if trying to transfer to zero address\n     */\n    error TransferToZeroAddressAttempt();\n\n    /**\n     * @notice Throws when module address taken from signature is not enabled\n     * @param moduleAddressProvided module address taken from signature\n     */\n    error WrongValidationModule(address moduleAddressProvided);\n\n    /**\n     * @notice Thrown when the function that must be called only via delegatecall is called directly\n     */\n    error DelegateCallsOnly();\n\n    /**\n     * @notice Thrown when trying to use address of the Smart Account as an owner for itself\n     */\n    error OwnerCanNotBeSelf();\n\n    /**\n     * @notice Thrown when trying to use current owner as a new owner in a _setOwner() call\n     */\n    error OwnerProvidedIsSame();\n\n    /**\n     * @notice Throws when the address that signed the data (restored from signature)\n     * differs from the address we expected to sign the data (i.e. some authorized address)\n     */\n    error InvalidSignature();\n\n    /**\n     * @notice Throws if not enough gas is left at some point\n     * @param gasLeft how much gas left at the moment of a check\n     * @param gasRequired how much gas required to proceed\n     */\n    error NotEnoughGasLeft(uint256 gasLeft, uint256 gasRequired);\n\n    /**\n     * @notice Throws if not able to estimate gas\n     * It can be when amount of gas and its price are both zero and at the same time\n     * transaction has failed to be executed\n     * @param targetTxGas gas required for target transaction\n     * @param gasPrice gas price passed in Refund Info\n     * @param success whether transaction has been executed successfully or not\n     */\n    error CanNotEstimateGas(\n        uint256 targetTxGas,\n        uint256 gasPrice,\n        bool success\n    );\n\n    /**\n     * @notice Throws if transfer of tokens failed\n     * @param token token contract address\n     * @param dest token transfer receiver\n     * @param amount the amount of tokens in a failed transfer\n     */\n    error TokenTransferFailed(address token, address dest, uint256 amount);\n\n    /**\n     * @notice Thrown when trying to use 0 as tokenGasPriceFactor\n     */\n    error TokenGasPriceFactorCanNotBeZero();\n\n    /**\n     * @notice Throws when the transaction execution fails\n     */\n    error ExecutionFailed();\n}\n\ncontract SmartAccountFactoryErrorsV1 is SmartAccountErrorsV1 {\n    /**\n     * @notice Throws when the new Proxy deployment fails\n     * @param owner Owner of a Proxy (Smart Account)\n     * @param index Deployment index\n     */\n    error ProxyDeploymentFailed(address owner, uint256 index);\n}\n\ncontract SelfAuthorizedErrors {\n    /**\n     * @notice Throws when the caller is not address(this)\n     * @param caller Caller address\n     */\n    error CallerIsNotSelf(address caller);\n}\n\ncontract SingletonPaymasterErrors {\n    /**\n     * @notice Throws when the Entrypoint address provided is address(0)\n     */\n    error EntryPointCannotBeZero();\n\n    /**\n     * @notice Throws when the verifiying signer address provided is address(0)\n     */\n    error VerifyingSignerCannotBeZero();\n\n    /**\n     * @notice Throws when the paymaster address provided is address(0)\n     */\n    error PaymasterIdCannotBeZero();\n\n    /**\n     * @notice Throws when the 0 has been provided as deposit\n     */\n    error DepositCanNotBeZero();\n\n    /**\n     * @notice Throws when trying to withdraw to address(0)\n     */\n    error CanNotWithdrawToZeroAddress();\n\n    /**\n     * @notice Throws when trying to withdraw more than balance available\n     * @param amountRequired required balance\n     * @param currentBalance available balance\n     */\n    error InsufficientBalance(uint256 amountRequired, uint256 currentBalance);\n\n    /**\n     * @notice Throws when signature provided has invalid length\n     * @param sigLength length oif the signature provided\n     */\n    error InvalidPaymasterSignatureLength(uint256 sigLength);\n}\n\n//\n"
    },
    "contracts/test/upgrades/v1/FallbackManagerV1.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {SelfAuthorized} from \"../../../common/SelfAuthorized.sol\";\nimport {FallbackManagerErrors} from \"../../../common/Errors.sol\";\n\n/**\n *   @title Fallback Manager - A contract that manages fallback calls made to the Smart Account\n *   @dev Fallback calls are handled by a `handler` contract that is stored at FALLBACK_HANDLER_STORAGE_SLOT\n *        fallback calls are not delegated to the `handler` so they can not directly change Smart Account storage\n */\nabstract contract FallbackManagerV1 is SelfAuthorized, FallbackManagerErrors {\n    // keccak-256 hash of \"fallback_manager.handler.address\" subtracted by 1\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT =\n        0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d4;\n\n    event ChangedFallbackHandler(\n        address indexed previousHandler,\n        address indexed handler\n    );\n\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\n    fallback() external {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n\n        assembly {\n            let handler := sload(slot)\n            if iszero(handler) {\n                return(0, 0)\n            }\n            calldatacopy(0, 0, calldatasize())\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            mstore(calldatasize(), shl(96, caller()))\n            // Add 20 bytes for the address appended add the end\n            let success := call(\n                gas(),\n                handler,\n                0,\n                0,\n                add(calldatasize(), 20),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n            if iszero(success) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n\n    function getFallbackHandler() public view returns (address _handler) {\n        assembly {\n            _handler := sload(FALLBACK_HANDLER_STORAGE_SLOT)\n        }\n    }\n\n    /// @dev Allows to add a contract to handle fallback calls.\n    ///      Only fallback calls without value and with data will be forwarded\n    /// @param handler contract to handle fallback calls.\n    function setFallbackHandler(address handler) public authorized {\n        _setFallbackHandler(handler);\n    }\n\n    function _setFallbackHandler(address handler) internal {\n        if (handler == address(0)) revert HandlerCannotBeZero();\n        address previousHandler;\n\n        assembly {\n            previousHandler := sload(FALLBACK_HANDLER_STORAGE_SLOT)\n        }\n        //bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n\n        assembly {\n            sstore(FALLBACK_HANDLER_STORAGE_SLOT, handler)\n        }\n        emit ChangedFallbackHandler(previousHandler, handler);\n    }\n\n    uint256[24] private __gap;\n}\n"
    },
    "contracts/test/upgrades/v1/IModuleV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\n\n// interface for modules to verify singatures signed over userOpHash\ninterface IModule {\n    /**\n     * @dev standard validateSignature for modules to validate and mark userOpHash as seen\n     * @param userOp the operation that is about to be executed.\n     * @param userOpHash hash of the user's request data. can be used as the basis for signature.\n     * @return sigValidationResult sigAuthorizer to be passed back to trusting Account, aligns with validationData\n     */\n    function validateSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external returns (uint256 sigValidationResult);\n}\n"
    },
    "contracts/test/upgrades/v1/ModuleManagerV1.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {SelfAuthorized} from \"../../../common/SelfAuthorized.sol\";\nimport {Executor, Enum} from \"../../../base/Executor.sol\";\nimport {ModuleManagerErrorsV1} from \"./ErrorsV1.sol\";\n\n/**\n * @title Module Manager - A contract that manages modules that can execute transactions\n *        on behalf of the Smart Account via this contract.\n */\ncontract ModuleManagerV1 is SelfAuthorized, Executor, ModuleManagerErrorsV1 {\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    mapping(address => address) internal _modules;\n\n    // Events\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n    event ModuleTransaction(\n        address module,\n        address to,\n        uint256 value,\n        bytes data,\n        Enum.Operation operation\n    );\n\n    /**\n     * @dev Returns array of modules. Useful for a widget\n     * @param start Start of the page.\n     * @param pageSize Maximum number of modules that should be returned.\n     * @return array Array of modules.\n     * @return next Start of the next page.\n     */\n    function getModulesPaginated(\n        address start,\n        uint256 pageSize\n    ) external view returns (address[] memory array, address next) {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount;\n        address currentModule = _modules[start];\n        while (\n            currentModule != address(0x0) &&\n            currentModule != SENTINEL_MODULES &&\n            moduleCount < pageSize\n        ) {\n            array[moduleCount] = currentModule;\n            currentModule = _modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n\n    /**\n     * @dev Adds a module to the allowlist.\n     * @notice This can only be done via a wallet transaction.\n     * @notice Enables the module `module` for the wallet.\n     * @param module Module to be allow-listed.\n     */\n    function enableModule(address module) public authorized {\n        // Module address cannot be null or sentinel.\n        if (module == address(0) || module == SENTINEL_MODULES)\n            revert ModuleCannotBeZeroOrSentinel(module);\n        // Module cannot be added twice.\n        if (_modules[module] != address(0)) revert ModuleAlreadyEnabled(module);\n        _modules[module] = _modules[SENTINEL_MODULES];\n        _modules[SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    /**\n     * @dev Removes a module from the allowlist.\n     * @notice This can only be done via a wallet transaction.\n     * @notice Disables the module `module` for the wallet.\n     * @param prevModule Module that pointed to the module to be removed in the linked list\n     * @param module Module to be removed.\n     */\n    function disableModule(\n        address prevModule,\n        address module\n    ) public authorized {\n        // Validate module address and check that it corresponds to module index.\n        if (module == address(0) || module == SENTINEL_MODULES)\n            revert ModuleCannotBeZeroOrSentinel(module);\n        if (_modules[prevModule] != module)\n            revert ModuleAndPrevModuleMismatch(\n                module,\n                _modules[prevModule],\n                prevModule\n            );\n        _modules[prevModule] = _modules[module];\n        delete _modules[module];\n        emit DisabledModule(module);\n    }\n\n    /**\n     * @dev Allows a Module to execute a Smart Account transaction without any further confirmations.\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     */\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual returns (bool success) {\n        // Only whitelisted modules are allowed.\n        if (\n            msg.sender == SENTINEL_MODULES || _modules[msg.sender] == address(0)\n        ) revert ModuleNotEnabled(msg.sender);\n        // Execute transaction without further confirmations.\n        success = _execute(to, value, data, operation, gasleft());\n        if (success) {\n            emit ModuleTransaction(msg.sender, to, value, data, operation);\n            emit ExecutionFromModuleSuccess(msg.sender);\n        } else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /**\n     * @dev Allows a Module to execute a wallet transaction without any further confirmations and returns data\n     * @param to Destination address of module transaction.\n     * @param value Ether value of module transaction.\n     * @param data Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     */\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public returns (bool success, bytes memory returnData) {\n        success = execTransactionFromModule(to, value, data, operation);\n\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    /**\n     * @dev Returns if a module is enabled\n     * @return True if the module is enabled\n     */\n    function isModuleEnabled(address module) public view returns (bool) {\n        return SENTINEL_MODULES != module && _modules[module] != address(0);\n    }\n\n    /**\n     * @notice Setup function sets the initial storage of the contract.\n     *         Optionally executes a delegate call to another contract to setup the modules.\n     * @param to Optional destination address of call to execute.\n     * @param data Optional data of call to execute.\n     */\n    function _setupModules(address to, bytes memory data) internal {\n        if (_modules[SENTINEL_MODULES] != address(0))\n            revert ModulesAlreadyInitialized();\n        _modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            if (!_execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()))\n                // Setup has to complete successfully or transaction fails.\n                revert ModulesSetupExecutionFailed();\n    }\n\n    uint256[24] private __gap;\n}\n"
    },
    "contracts/test/upgrades/v1/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @title Proxy // This is the user's Smart Account\n * @notice Basic proxy that delegates all calls to a fixed implementation contract.\n * @dev    Implementation address is stored in the slot defined by the Proxy's address\n */\ncontract Proxy {\n    constructor(address _implementation) {\n        require(\n            _implementation != address(0),\n            \"Invalid implementation address\"\n        );\n\n        assembly {\n            sstore(address(), _implementation)\n        }\n    }\n\n    fallback() external payable {\n        address target;\n\n        assembly {\n            target := sload(address())\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/upgrades/v1/SmartAccountFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./Proxy.sol\";\nimport \"./BaseSmartAccountV1.sol\";\nimport {DefaultCallbackHandler} from \"../../../handler/DefaultCallbackHandler.sol\";\n\n/**\n * @title Smart Account Factory - factory responsible for deploying Smart Accounts using CREATE2 and CREATE\n * @dev It deploys Smart Accounts as proxies pointing to `basicImplementation` that is immutable.\n *      This allows keeping the same address for the same Smart Account owner on various chains via CREATE2\n * @author Chirag Titiya - <chirag@biconomy.io>\n */\ncontract SmartAccountFactoryV1 {\n    address public immutable basicImplementation;\n    DefaultCallbackHandler public immutable minimalHandler;\n\n    event AccountCreation(\n        address indexed account,\n        address indexed owner,\n        uint256 indexed index\n    );\n    event AccountCreationWithoutIndex(\n        address indexed account,\n        address indexed owner\n    );\n\n    constructor(address _basicImplementation) {\n        require(\n            _basicImplementation != address(0),\n            \"implementation cannot be zero\"\n        );\n        basicImplementation = _basicImplementation;\n        minimalHandler = new DefaultCallbackHandler();\n    }\n\n    /**\n     * @notice Deploys account using create2 and points it to basicImplementation\n     * @param _owner EOA signatory for the account to be deployed\n     * @param _index extra salt that allows to deploy more account if needed for same EOA (default 0)\n     */\n    function deployCounterFactualAccount(\n        address _owner,\n        uint256 _index\n    ) public returns (address proxy) {\n        // create initializer data based on init method, _owner and minimalHandler\n        bytes memory initializer = _getInitializer(_owner);\n\n        bytes32 salt = keccak256(\n            abi.encodePacked(keccak256(initializer), _index)\n        );\n\n        bytes memory deploymentData = abi.encodePacked(\n            type(Proxy).creationCode,\n            uint256(uint160(basicImplementation))\n        );\n\n        assembly {\n            proxy := create2(\n                0x0,\n                add(0x20, deploymentData),\n                mload(deploymentData),\n                salt\n            )\n        }\n        require(address(proxy) != address(0), \"Create2 call failed\");\n\n        // calldata for init method\n        if (initializer.length > 0) {\n            assembly {\n                if eq(\n                    call(\n                        gas(),\n                        proxy,\n                        0,\n                        add(initializer, 0x20),\n                        mload(initializer),\n                        0,\n                        0\n                    ),\n                    0\n                ) {\n                    revert(0, 0)\n                }\n            }\n        }\n        emit AccountCreation(proxy, _owner, _index);\n    }\n\n    /**\n     * @dev Allows to retrieve the creation code used for the Proxy deployment.\n     * @return The creation code for the Proxy.\n     */\n    function accountCreationCode() public pure returns (bytes memory) {\n        return type(Proxy).creationCode;\n    }\n\n    /**\n     * @notice Deploys account using create and points it to _implementation\n     * @param _owner EOA signatory for the account to be deployed\n     * @return proxy address of the deployed account\n     */\n    function deployAccount(address _owner) public returns (address proxy) {\n        bytes memory deploymentData = abi.encodePacked(\n            type(Proxy).creationCode,\n            uint256(uint160(basicImplementation))\n        );\n\n        assembly {\n            proxy := create(\n                0x0,\n                add(0x20, deploymentData),\n                mload(deploymentData)\n            )\n        }\n        require(address(proxy) != address(0), \"Create call failed\");\n\n        bytes memory initializer = _getInitializer(_owner);\n\n        // calldata for init method\n        if (initializer.length > 0) {\n            assembly {\n                if eq(\n                    call(\n                        gas(),\n                        proxy,\n                        0,\n                        add(initializer, 0x20),\n                        mload(initializer),\n                        0,\n                        0\n                    ),\n                    0\n                ) {\n                    revert(0, 0)\n                }\n            }\n        }\n        emit AccountCreationWithoutIndex(proxy, _owner);\n    }\n\n    /**\n     * @dev Allows to retrieve the initializer data for the account.\n     * @param _owner EOA signatory for the account to be deployed\n     * @return initializer bytes for init method\n     */\n    function _getInitializer(\n        address _owner\n    ) internal view returns (bytes memory) {\n        return\n            abi.encodeCall(\n                BaseSmartAccount.init,\n                (_owner, address(minimalHandler))\n            );\n    }\n\n    /**\n     * @notice Allows to find out account address prior to deployment\n     * @param _owner EOA signatory for the account to be deployed\n     * @param _index extra salt that allows to deploy more accounts if needed for same EOA (default 0)\n     */\n    function getAddressForCounterFactualAccount(\n        address _owner,\n        uint256 _index\n    ) external view returns (address _account) {\n        // create initializer data based on init method, _owner and minimalHandler\n        bytes memory initializer = _getInitializer(_owner);\n        bytes memory code = abi.encodePacked(\n            type(Proxy).creationCode,\n            uint256(uint160(basicImplementation))\n        );\n        bytes32 salt = keccak256(\n            abi.encodePacked(keccak256(initializer), _index)\n        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code))\n        );\n        _account = address(uint160(uint256(hash)));\n    }\n    // off-chain calculation\n    // return ethers.utils.getCreate2Address(<factory address>, <create2 salt>, ethers.utils.keccak256(creationCode + implementation));\n}\n"
    },
    "contracts/test/upgrades/v1/SmartAccountV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {BaseSmartAccount, IEntryPoint, Transaction, FeeRefund, Enum, UserOperation} from \"./BaseSmartAccountV1.sol\";\nimport {ModuleManagerV1} from \"./ModuleManagerV1.sol\";\nimport {FallbackManagerV1} from \"./FallbackManagerV1.sol\";\nimport {SignatureDecoder} from \"../../../common/SignatureDecoder.sol\";\nimport {SecuredTokenTransfer} from \"../../../common/SecuredTokenTransfer.sol\";\nimport {LibAddress} from \"../../../libs/LibAddress.sol\";\nimport {ISignatureValidator} from \"../../../interfaces/ISignatureValidator.sol\";\nimport {Math} from \"../../../libs/Math.sol\";\nimport {IERC165} from \"../../../interfaces/IERC165.sol\";\nimport {ReentrancyGuard} from \"../../../common/ReentrancyGuard.sol\";\nimport {SmartAccountErrorsV1} from \"./ErrorsV1.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {IModule} from \"./IModuleV1.sol\";\n\n/**\n * @title SmartAccount - EIP-4337 compatible smart contract wallet.\n * @dev This contract is the base for the Smart Account functionality.\n *         - It provides the functionality to execute both gnosis-style txns and AA (EIP-4337) userOps\n *         - It allows to receive and manage assets.\n *         - It is responsible for managing the modules and fallbacks.\n *         - The Smart Account can be extended with modules, such as Social Recovery, Session Key and others.\n * @author Chirag Titiya - <chirag@biconomy.io>\n */\ncontract SmartAccountV1 is\n    BaseSmartAccount,\n    ModuleManagerV1,\n    FallbackManagerV1,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    IERC165,\n    ReentrancyGuard,\n    SmartAccountErrorsV1,\n    ISignatureValidator\n{\n    using ECDSA for bytes32;\n    using LibAddress for address;\n\n    // Storage Version\n    string public constant VERSION = \"1.0.0\";\n\n    // Domain Seperators keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,uint256 tokenGasPriceFactor,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH =\n        0xda033865d68bf4a40a5a7cb4159a99e33dba8569e65ea3e38222eb12d9e66eee;\n\n    // Owner storage\n    address public owner;\n\n    // changed to 2D nonce below\n    // @notice there is no _nonce\n    mapping(uint256 => uint256) public nonces;\n\n    // AA immutable storage\n    IEntryPoint private immutable _entryPoint;\n    uint256 private immutable _chainId;\n    address private immutable _self;\n\n    // Events\n\n    event ImplementationUpdated(\n        address indexed oldImplementation,\n        address indexed newImplementation\n    );\n    event EOAChanged(\n        address indexed _scw,\n        address indexed _oldEOA,\n        address indexed _newEOA\n    );\n    event AccountHandlePayment(bytes32 indexed txHash, uint256 indexed payment);\n    event SmartAccountReceivedNativeToken(\n        address indexed sender,\n        uint256 indexed value\n    );\n\n    /// modifiers\n    /**\n     * @dev Modifier to allow only the owner to call the function.\n     * Reverts with CallerIsNotOwner if the caller is not the owner.\n     */\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert CallerIsNotOwner(msg.sender);\n        _;\n    }\n    /**\n     * @dev Modifier to allow only the owner or the contract itself to call the function.\n     * Reverts with MixedAuthFail if the caller is not the owner or the contract itself.\n     */\n    modifier mixedAuth() {\n        if (msg.sender != owner && msg.sender != address(this))\n            revert MixedAuthFail(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Constructor that sets the owner of the contract and the entry point contract.\n     * @param anEntryPoint The address of the entry point contract.\n     */\n    constructor(IEntryPoint anEntryPoint) {\n        _self = address(this);\n        // By setting the owner it is not possible to call init anymore,\n        // so we create an account with fixed non-zero owner.\n        // This is an unusable account, perfect for the singleton\n        owner = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n        if (address(anEntryPoint) == address(0))\n            revert EntryPointCannotBeZero();\n        _entryPoint = anEntryPoint;\n        _chainId = block.chainid;\n    }\n\n    /// Getters\n    /**\n     * @dev Returns the address of the implementation contract associated with this contract.\n     * @notice The implementation address is stored in the contract's storage slot with index 0.\n     */\n    function getImplementation()\n        external\n        view\n        returns (address _implementation)\n    {\n        assembly {\n            _implementation := sload(address())\n        }\n    }\n\n    /**\n     * @dev Allows to change the owner of the smart account by current owner or self-call (modules)\n     * @param _newOwner Address of the new signatory\n     */\n    function setOwner(address _newOwner) public mixedAuth {\n        if (_newOwner == address(0)) revert OwnerCannotBeZero();\n        if (_newOwner == address(this)) revert OwnerCanNotBeSelf();\n        if (_newOwner == owner) revert OwnerProvidedIsSame();\n        address oldOwner = owner;\n        assembly {\n            sstore(owner.slot, _newOwner)\n        }\n        emit EOAChanged(address(this), oldOwner, _newOwner);\n    }\n\n    /**\n     * @notice All the new implementations MUST have this method!\n     * @notice Updates the implementation of the base wallet\n     * @param _implementation New wallet implementation\n     */\n    function updateImplementation(\n        address _implementation\n    ) public virtual mixedAuth {\n        require(_implementation != address(0), \"Address cannot be zero\");\n        if (!_implementation.isContract())\n            revert InvalidImplementation(_implementation);\n        address oldImplementation;\n\n        assembly {\n            oldImplementation := sload(address())\n            sstore(address(), _implementation)\n        }\n        emit ImplementationUpdated(oldImplementation, _implementation);\n    }\n\n    /**\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\n     * @return bytes32 The domain separator hash.\n     */\n    function domainSeparator() public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    DOMAIN_SEPARATOR_TYPEHASH,\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n     * @notice Returns the ID of the chain the contract is currently deployed on.\n     * @return _chainId The ID of the current chain as a uint256.\n     */\n    function getChainId() public view returns (uint256) {\n        return _chainId;\n    }\n\n    /**\n     * @dev returns a value from the nonces 2d mapping\n     * @param batchId : the key of the user's batch being queried\n     * @return nonce : the number of transactions made within said batch\n     */\n    function getNonce(uint256 batchId) public view virtual returns (uint256) {\n        return nonces[batchId];\n    }\n\n    /**\n     * @dev Returns the current entry point used by this account.\n     * @return EntryPoint as an `IEntryPoint` interface.\n     * @dev This function should be implemented by the subclass to return the current entry point used by this account.\n     */\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    /**\n     * @dev Initialize the Smart Account with required states\n     * @param _owner Signatory of the Smart Account\n     * @param _handler Default fallback handler provided in Smart Account\n     * @notice devs need to make sure it is only callble once by initiazer or state check restrictions\n     * @notice any further implementations that introduces a new state must have a reinit method\n     * @notice init is prevented here by setting owner in the constructor and checking here for address(0)\n     */\n    function init(address _owner, address _handler) external virtual override {\n        if (owner != address(0)) revert AlreadyInitialized();\n        if (_owner == address(0)) revert OwnerCannotBeZero();\n        owner = _owner;\n        _setFallbackHandler(_handler);\n        _setupModules(address(0), bytes(\"\"));\n    }\n\n    /**\n     * @dev Gnosis style transaction with optional repay in native tokens OR ERC20\n     * @dev Allows to execute a transaction confirmed by required signature/s and then pays the account that submitted the transaction.\n     * @dev Function name optimized to have hash started with zeros to make this function calls cheaper\n     * @notice The fees are always transferred, even if the user transaction fails.\n     * @param _tx Smart Account transaction\n     * @param refundInfo Required information for gas refunds\n     * @param signatures Packed signature/s data ({bytes32 r}{bytes32 s}{uint8 v})\n     */\n    function execTransaction_S6W(\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) public payable virtual nonReentrant returns (bool success) {\n        uint256 startGas = gasleft();\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData = encodeTransactionData(\n                // Transaction info\n                _tx,\n                // Payment info\n                refundInfo,\n                // Signature info\n                nonces[1]++\n            );\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, signatures);\n        }\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        // Bitshift left 6 bits means multiplying by 64, just more gas efficient\n        if (\n            gasleft() <\n            Math.max((_tx.targetTxGas << 6) / 63, _tx.targetTxGas + 2500) + 500\n        )\n            revert NotEnoughGasLeft(\n                gasleft(),\n                Math.max((_tx.targetTxGas << 6) / 63, _tx.targetTxGas + 2500) +\n                    500\n            );\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than targetTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas\n            success = _execute(\n                _tx.to,\n                _tx.value,\n                _tx.data,\n                _tx.operation,\n                refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas\n            );\n            // If no targetTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            if (!success && _tx.targetTxGas == 0 && refundInfo.gasPrice == 0)\n                revert CanNotEstimateGas(\n                    _tx.targetTxGas,\n                    refundInfo.gasPrice,\n                    success\n                );\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment;\n            if (refundInfo.gasPrice != 0) {\n                payment = _handlePayment(\n                    startGas - gasleft(),\n                    refundInfo.baseGas,\n                    refundInfo.gasPrice,\n                    refundInfo.tokenGasPriceFactor,\n                    refundInfo.gasToken,\n                    refundInfo.refundReceiver\n                );\n                emit AccountHandlePayment(txHash, payment);\n            }\n        }\n    }\n\n    /**\n     * @dev Interface function with the standard name for execTransaction_S6W\n     */\n    function execTransaction(\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) external payable virtual override returns (bool) {\n        return execTransaction_S6W(_tx, refundInfo, signatures);\n    }\n\n    /**\n     * @dev Handles the payment for a transaction refund from Smart Account to Relayer.\n     * @param gasUsed Gas used by the transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution\n     * (e.g. base transaction fee, signature check, payment of the refund, emitted events).\n     * @param gasPrice Gas price / TokenGasPrice (gas price in the context of token using offchain price feeds)\n     * that should be used for the payment calculation.\n     * @param tokenGasPriceFactor factor by which calculated token gas price is already multiplied.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @return payment The amount of payment made in the specified token.\n     */\n    function _handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        if (tokenGasPriceFactor == 0) revert TokenGasPriceFactorCanNotBeZero();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0)\n            ? payable(tx.origin)\n            : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment =\n                (gasUsed + baseGas) *\n                (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            bool success;\n            assembly {\n                success := call(gas(), receiver, payment, 0, 0, 0, 0)\n            }\n            if (!success)\n                revert TokenTransferFailed(address(0), receiver, payment);\n        } else {\n            payment =\n                ((gasUsed + baseGas) * (gasPrice)) /\n                (tokenGasPriceFactor);\n            if (!_transferToken(gasToken, receiver, payment))\n                revert TokenTransferFailed(gasToken, receiver, payment);\n        }\n    }\n\n    /**\n     * @dev Allows to estimate a transaction.\n     * @notice This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n     * @notice Call this method to get an estimate of the handlePayment costs that are deducted with `execTransaction`\n     * @param gasUsed Gas used by the transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution\n     * (e.g. base transaction fee, signature check, payment of the refund, emitted events).\n     * @param gasPrice Gas price / TokenGasPrice (gas price in the context of token using offchain price feeds)\n     * that should be used for the payment calculation.\n     * @param tokenGasPriceFactor factor by which calculated token gas price is already multiplied.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @return requiredGas Estimate of refunds\n     */\n    function handlePaymentRevert(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) external returns (uint256 requiredGas) {\n        require(tokenGasPriceFactor != 0, \"invalid tokenGasPriceFactor\");\n        uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0)\n            ? payable(tx.origin)\n            : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            uint256 payment = (gasUsed + baseGas) *\n                (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            bool success;\n            assembly {\n                success := call(gas(), receiver, payment, 0, 0, 0, 0)\n            }\n            if (!success)\n                revert TokenTransferFailed(address(0), receiver, payment);\n        } else {\n            uint256 payment = ((gasUsed + baseGas) * (gasPrice)) /\n                (tokenGasPriceFactor);\n            if (!_transferToken(gasToken, receiver, payment))\n                revert TokenTransferFailed(gasToken, receiver, payment);\n        }\n        unchecked {\n            requiredGas = startGas - gasleft();\n        }\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory signatures\n    ) public view virtual {\n        require(signatures.length >= 65, \"Invalid signatures length\");\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        address _signer;\n        (v, r, s) = _signatureSplit(signatures);\n        if (v == 0) {\n            // If v is 0 then it is a contract signature\n            // When handling contract signatures the address of the signer contract is encoded into r\n            _signer = address(uint160(uint256(r)));\n\n            // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n            // Here we check that the pointer is not pointing inside the part that is being processed\n            if (uint256(s) < 65)\n                revert WrongContractSignatureFormat(uint256(s), 0, 0);\n\n            // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n            uint256 contractSignatureLen;\n\n            assembly {\n                contractSignatureLen := mload(add(add(signatures, s), 0x20))\n            }\n            if (uint256(s) + 32 + contractSignatureLen > signatures.length)\n                revert WrongContractSignatureFormat(\n                    uint256(s),\n                    contractSignatureLen,\n                    signatures.length\n                );\n\n            // Check signature\n            bytes memory contractSignature;\n\n            assembly {\n                // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                contractSignature := add(add(signatures, s), 0x20)\n            }\n            if (\n                ISignatureValidator(_signer).isValidSignature(\n                    dataHash,\n                    contractSignature\n                ) != EIP1271_MAGIC_VALUE\n            ) revert WrongContractSignature(contractSignature);\n        } else if (v > 30) {\n            // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n            // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n            (_signer, ) = dataHash.toEthSignedMessageHash().tryRecover(\n                v - 4,\n                r,\n                s\n            );\n        } else {\n            (_signer, ) = dataHash.tryRecover(v, r, s);\n        }\n        if (_signer != owner) revert InvalidSignature();\n    }\n\n    /**\n     * @dev Allows to estimate a transaction.\n     *      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n     *      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the wallet with `execTransaction`\n     * @param to Destination address of the transaction.\n     * @param value Ether value of transaction.\n     * @param data Data payload of transaction.\n     * @param operation Operation type of transaction.\n     * @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n     */\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        if (!_execute(to, value, data, operation, gasleft()))\n            revert ExecutionFailed();\n        // Convert response to string and return via error message\n        unchecked {\n            revert(string(abi.encodePacked(startGas - gasleft())));\n        }\n    }\n\n    /**\n     * @dev Returns hash to be signed by owner.\n     * @param to Destination address.\n     * @param value Ether value.\n     * @param data Data payload.\n     * @param operation Operation type.\n     * @param targetTxGas Fas that should be used for the internal Smart Account transaction.\n     * @param baseGas Additional Gas costs for data used to trigger the transaction.\n     * @param gasPrice Maximum gas price/ token gas price that should be used for this transaction.\n     * @param tokenGasPriceFactor factor by which calculated token gas price is already multiplied.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param _nonce Transaction nonce.\n     * @return Transaction hash.\n     */\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 targetTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        Transaction memory _tx = Transaction({\n            to: to,\n            value: value,\n            data: data,\n            operation: operation,\n            targetTxGas: targetTxGas\n        });\n        FeeRefund memory refundInfo = FeeRefund({\n            baseGas: baseGas,\n            gasPrice: gasPrice,\n            tokenGasPriceFactor: tokenGasPriceFactor,\n            gasToken: gasToken,\n            refundReceiver: refundReceiver\n        });\n        return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\n    }\n\n    /**\n     * @dev Returns the bytes that are hashed to be signed by owner.\n     * @param _tx The wallet transaction to be signed.\n     * @param refundInfo Required information for gas refunds.\n     * @param _nonce Transaction nonce.\n     * @return transactionHash bytes that are hashed to be signed by the owner.\n     */\n    function encodeTransactionData(\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 accountTxHash = keccak256(\n            abi.encode(\n                ACCOUNT_TX_TYPEHASH,\n                _tx.to,\n                _tx.value,\n                keccak256(_tx.data),\n                _tx.operation,\n                _tx.targetTxGas,\n                refundInfo.baseGas,\n                refundInfo.gasPrice,\n                refundInfo.tokenGasPriceFactor,\n                refundInfo.gasToken,\n                refundInfo.refundReceiver,\n                _nonce\n            )\n        );\n        return\n            bytes.concat(\n                bytes1(0x19),\n                bytes1(0x01),\n                domainSeparator(),\n                accountTxHash\n            );\n    }\n\n    /**\n     * @dev Utility method to be able to transfer native tokens out of Smart Account\n     * @notice only owner/ signatory of Smart Account with enough gas to spend can call this method\n     * @notice While enabling multisig module and renouncing ownership this will not work\n     * @param dest Destination address\n     * @param amount Amount of native tokens\n     */\n    function transfer(address payable dest, uint256 amount) external onlyOwner {\n        if (dest == address(0)) revert TransferToZeroAddressAttempt();\n        bool success;\n        assembly {\n            success := call(gas(), dest, amount, 0, 0, 0, 0)\n        }\n        if (!success) revert TokenTransferFailed(address(0), dest, amount);\n    }\n\n    /**\n     * @dev Utility method to be able to transfer ERC20 tokens out of Smart Account\n     * @notice only owner/ signatory of Smart Account with enough gas to spend can call this method\n     * @notice While enabling multisig module and renouncing ownership this will not work\n     * @param token Token address\n     * @param dest Destination/ Receiver address\n     * @param amount Amount of tokens\n     */\n    function pullTokens(\n        address token,\n        address dest,\n        uint256 amount\n    ) external onlyOwner {\n        if (dest == address(0)) revert TransferToZeroAddressAttempt();\n        if (!_transferToken(token, dest, amount))\n            revert TokenTransferFailed(token, dest, amount);\n    }\n\n    /**\n     * @dev Execute a transaction (called directly from owner, or by entryPoint)\n     * @notice Name is optimized for this method to be cheaper to be called\n     * @param dest Address of the contract to call\n     * @param value Amount of native tokens to send along with the transaction\n     * @param func Data of the transaction\n     */\n    function executeCall_s1m(\n        address dest,\n        uint256 value,\n        bytes calldata func\n    ) public {\n        _requireFromEntryPointOrOwner();\n        _call(dest, value, func);\n    }\n\n    /**\n     * @dev Interface function with the standard name for executeCall_s1m\n     * @param dest Address of the contract to call\n     * @param value Amount of native tokens to send along with the transaction\n     * @param func Data of the transaction\n     */\n    function executeCall(\n        address dest,\n        uint256 value,\n        bytes calldata func\n    ) external {\n        executeCall_s1m(dest, value, func);\n    }\n\n    /**\n     * @dev Execute a sequence of transactions\n     * @notice Name is optimized for this method to be cheaper to be called\n     * @param dest Addresses of the contracts to call\n     * @param value Amounts of native tokens to send along with the transactions\n     * @param func Data of the transactions\n     */\n    function executeBatchCall_4by(\n        address[] calldata dest,\n        uint256[] calldata value,\n        bytes[] calldata func\n    ) public {\n        _requireFromEntryPointOrOwner();\n        if (\n            dest.length == 0 ||\n            dest.length != value.length ||\n            value.length != func.length\n        ) revert WrongBatchProvided(dest.length, value.length, func.length, 0);\n        for (uint256 i; i < dest.length; ) {\n            _call(dest[i], value[i], func[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Interface function with the standard name for executeBatchCall_4by\n     * @param dest Addresses of the contracts to call\n     * @param value Amounts of native tokens to send along with the transactions\n     * @param func Data of the transactions\n     */\n    function executeBatchCall(\n        address[] calldata dest,\n        uint256[] calldata value,\n        bytes[] calldata func\n    ) external {\n        executeBatchCall_4by(dest, value, func);\n    }\n\n    /**\n     * Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)\n     * @dev If owner is a smart-contract (other smart contract wallet or module, that controls\n     *      signature verifications - like multisig), forward isValidSignature request to it.\n     *      In case of multisig, _signature can be several concatenated signatures\n     *      If owner is EOA, perform a regular ecrecover.\n     * @param _dataHash 32 bytes hash of the data signed on the behalf of address(msg.sender)\n     * @param _signature Signature byte array associated with _dataHash\n     * @return bytes4 value.\n     */\n    function isValidSignature(\n        bytes32 _dataHash,\n        bytes memory _signature\n    ) public view override returns (bytes4) {\n        if (owner.code.length > 0) {\n            return\n                ISignatureValidator(owner).isValidSignature(\n                    _dataHash,\n                    _signature\n                );\n        }\n        if (owner == _dataHash.recover(_signature)) {\n            return EIP1271_MAGIC_VALUE;\n        }\n        return bytes4(0xffffffff);\n    }\n\n    /**\n     * @dev Check current account deposit in the entryPoint\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint().balanceOf(address(this));\n    }\n\n    /**\n     * @dev Deposit more funds for this account in the entryPoint\n     */\n    function addDeposit() public payable {\n        entryPoint().depositTo{value: msg.value}(address(this));\n    }\n\n    /**\n     * @dev Withdraw value from the account's deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawDepositTo(\n        address payable withdrawAddress,\n        uint256 amount\n    ) public payable onlyOwner {\n        entryPoint().withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @param _interfaceId The interface identifier, as specified in ERC165\n     * @return `true` if the contract implements `_interfaceID`\n     */\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) external view virtual override returns (bool) {\n        return _interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n\n    /**\n     * @dev This function is a special fallback function that is triggered when the contract receives Ether.\n     * It logs an event indicating the amount of Ether received and the sender's address.\n     * @notice This function is marked as external and payable, meaning it can be called from external\n     * sources and accepts Ether as payment.\n     */\n    receive() external payable {\n        if (address(this) == _self) revert DelegateCallsOnly();\n        emit SmartAccountReceivedNativeToken(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev This function allows the owner or entry point to execute certain actions.\n     * If the caller is not authorized, the function will revert with an error message.\n     * @notice This modifier is marked as internal and can only be called within the contract itself.\n     */\n    function _requireFromEntryPointOrOwner() internal view {\n        if (msg.sender != address(entryPoint()) && msg.sender != owner)\n            revert CallerIsNotEntryPointOrOwner(msg.sender);\n    }\n\n    /**\n     * @dev internal method that fecilitates the extenral calls from SmartAccount\n     * @dev similar to execute() of Executor.sol\n     * @param target destination address contract/non-contract\n     * @param value amount of native tokens\n     * @param data function singature of destination\n     */\n    function _call(address target, uint256 value, bytes memory data) internal {\n        assembly {\n            let success := call(\n                gas(),\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, returndatasize())\n            if iszero(success) {\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Implements the template method of BaseAccount and validates the user's signature for a given operation.\n     * @notice This function is marked as internal and virtual, and it overrides the BaseAccount function of the same name.\n     * @param userOp The user operation to be validated, provided as a `UserOperation` calldata struct.\n     * @param userOpHash The hashed version of the user operation, provided as a `bytes32` value.\n     */\n    function _validateSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) internal virtual override returns (uint256 validationData) {\n        // below changes need formal verification.\n        bytes calldata userOpData = userOp.callData;\n        if (userOpData.length > 0) {\n            bytes4 methodSig = bytes4(userOpData[:4]);\n            // If method to be called is executeCall then only check for module transaction\n            if (methodSig == this.executeCall.selector) {\n                (address _to, , ) = abi.decode(\n                    userOpData[4:],\n                    (address, uint, bytes)\n                );\n                if (address(_modules[_to]) != address(0))\n                    return IModule(_to).validateSignature(userOp, userOpHash);\n            }\n        }\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        if (owner != hash.recover(userOp.signature))\n            return SIG_VALIDATION_FAILED;\n        return 0;\n    }\n}\n"
    },
    "contracts/test/WrongStorageAccessValidationModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {EcdsaOwnershipRegistryModule} from \"../modules/EcdsaOwnershipRegistryModule.sol\";\nimport {UserOperation} from \"@account-abstraction/contracts/interfaces/UserOperation.sol\";\n\ncontract WrongStorageAccessValidationModule is EcdsaOwnershipRegistryModule {\n    uint256 public constant MAX_VALIDATION_COUNT = 10;\n\n    // not associated storage\n    uint256 private _usageCounter = 0;\n\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external view virtual override returns (uint256) {\n        require(\n            _usageCounter < MAX_VALIDATION_COUNT,\n            \"Renew module subscription\"\n        );\n\n        // Usual Stuff\n        (bytes memory cleanEcdsaSignature, ) = abi.decode(\n            userOp.signature,\n            (bytes, address)\n        );\n        if (_verifySignature(userOpHash, cleanEcdsaSignature, userOp.sender)) {\n            return VALIDATION_SUCCESS;\n        }\n        return SIG_VALIDATION_FAILED;\n    }\n}\n"
    },
    "contracts/utils/Decoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Decoder {\n    function decode(\n        address to,\n        bytes memory data\n    ) public returns (bytes memory) {\n        (bool success, bytes memory result) = to.call(data);\n        require(!success, \"Call failed\");\n        return result;\n    }\n}\n"
    },
    "contracts/utils/GasEstimator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// Generic contract for estimating gas on any target and data\ncontract GasEstimator {\n    function estimate(\n        address _to,\n        bytes calldata _data\n    ) external returns (bool success, bytes memory result, uint256 gas) {\n        // solhint-disable\n        uint256 initialGas = gasleft();\n        (success, result) = _to.call(_data);\n        gas = initialGas - gasleft();\n        // solhint-enable\n    }\n}\n"
    },
    "contracts/utils/GasEstimatorSmartAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {SmartAccountFactory} from \"../factory/SmartAccountFactory.sol\";\n\n// Contract for estimating gas on undeployed smart account\n// Deploys a smart account and then calls the appropriate method\ncontract GasEstimatorSmartAccount {\n    function estimate(\n        address _actualWallet,\n        address _factory,\n        address _sessionKeyModuleContract,\n        address _authModuleSetupContract,\n        bytes calldata _authModuleSetupData,\n        uint256 _index,\n        bytes calldata _data // execTransaction data // counterFactual wallet should have assets if required\n    ) external returns (bool success, bytes memory result, uint256 gas) {\n        uint256 initialGas = gasleft();\n        SmartAccountFactory(_factory).deployCounterFactualAccount(\n            _sessionKeyModuleContract,\n            _authModuleSetupContract,\n            _authModuleSetupData,\n            _index\n        );\n        (success, result) = _actualWallet.call(_data);\n        gas = initialGas - gasleft();\n    }\n}\n"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}